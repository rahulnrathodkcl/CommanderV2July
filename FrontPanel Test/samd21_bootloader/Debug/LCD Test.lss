
LCD Test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000474c  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0000474c  0000474c  0001474c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000074  20000000  00004754  00020000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00000278  20000074  000047c8  00020074  2**2
                  ALLOC
  4 .stack        00002004  200002ec  00004a40  00020074  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  00020074  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0002009c  2**0
                  CONTENTS, READONLY
  7 .debug_info   0002ee17  00000000  00000000  000200f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003e37  00000000  00000000  0004ef0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00003ea5  00000000  00000000  00052d43  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000b90  00000000  00000000  00056be8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000a28  00000000  00000000  00057778  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  000094d0  00000000  00000000  000581a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001154f  00000000  00000000  00061670  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0009cc1a  00000000  00000000  00072bbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002a14  00000000  00000000  0010f7dc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	f0 22 00 20 9d 30 00 00 95 31 00 00 95 31 00 00     .". .0...1...1..
	...
      2c:	a1 0b 00 00 00 00 00 00 00 00 00 00 c1 0b 00 00     ................
      3c:	09 0c 00 00 95 31 00 00 95 31 00 00 59 0f 00 00     .....1...1..Y...
      4c:	95 31 00 00 09 1d 00 00 95 31 00 00 95 31 00 00     .1.......1...1..
      5c:	79 1b 00 00 95 31 00 00 ad 1b 00 00 c5 1b 00 00     y....1..........
      6c:	dd 1b 00 00 f5 1b 00 00 0d 1c 00 00 25 1c 00 00     ............%...
      7c:	95 31 00 00 95 31 00 00 95 31 00 00 95 31 00 00     .1...1...1...1..
      8c:	95 31 00 00 95 31 00 00 95 31 00 00 95 31 00 00     .1...1...1...1..
      9c:	95 31 00 00 95 31 00 00 95 31 00 00 95 31 00 00     .1...1...1...1..
      ac:	95 31 00 00 00 00 00 00                             .1......

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000074 	.word	0x20000074
      d4:	00000000 	.word	0x00000000
      d8:	00004754 	.word	0x00004754

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000078 	.word	0x20000078
     108:	00004754 	.word	0x00004754
     10c:	00004754 	.word	0x00004754
     110:	00000000 	.word	0x00000000

00000114 <system_pinmux_get_group_from_gpio_pin>:
		n += print_ch('-');
		number = -number;
	}
	
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i)
     114:	b580      	push	{r7, lr}
     116:	b084      	sub	sp, #16
     118:	af00      	add	r7, sp, #0
     11a:	0002      	movs	r2, r0
     11c:	1dfb      	adds	r3, r7, #7
     11e:	701a      	strb	r2, [r3, #0]
     120:	230f      	movs	r3, #15
     122:	18fb      	adds	r3, r7, r3
     124:	1dfa      	adds	r2, r7, #7
	rounding /= 10.0;

	number += rounding;
     126:	7812      	ldrb	r2, [r2, #0]
     128:	09d2      	lsrs	r2, r2, #7
     12a:	701a      	strb	r2, [r3, #0]
     12c:	230e      	movs	r3, #14
     12e:	18fb      	adds	r3, r7, r3
     130:	1dfa      	adds	r2, r7, #7
     132:	7812      	ldrb	r2, [r2, #0]
     134:	0952      	lsrs	r2, r2, #5
     136:	701a      	strb	r2, [r3, #0]
     138:	4b0d      	ldr	r3, [pc, #52]	; (170 <system_pinmux_get_group_from_gpio_pin+0x5c>)

	unsigned long int_part = (unsigned long)number;
     13a:	60bb      	str	r3, [r7, #8]
     13c:	230f      	movs	r3, #15
     13e:	18fb      	adds	r3, r7, r3
     140:	781b      	ldrb	r3, [r3, #0]
     142:	2b00      	cmp	r3, #0
     144:	d10f      	bne.n	166 <system_pinmux_get_group_from_gpio_pin+0x52>
	double remainder = number - (double)int_part;
     146:	230f      	movs	r3, #15
     148:	18fb      	adds	r3, r7, r3
     14a:	781b      	ldrb	r3, [r3, #0]
     14c:	009b      	lsls	r3, r3, #2
     14e:	2210      	movs	r2, #16
     150:	4694      	mov	ip, r2
     152:	44bc      	add	ip, r7
     154:	4463      	add	r3, ip
     156:	3b08      	subs	r3, #8
     158:	681a      	ldr	r2, [r3, #0]
     15a:	230e      	movs	r3, #14
     15c:	18fb      	adds	r3, r7, r3
     15e:	781b      	ldrb	r3, [r3, #0]
	n += print_uln(int_part);
     160:	01db      	lsls	r3, r3, #7
     162:	18d3      	adds	r3, r2, r3
     164:	e000      	b.n	168 <system_pinmux_get_group_from_gpio_pin+0x54>
     166:	2300      	movs	r3, #0
     168:	0018      	movs	r0, r3
     16a:	46bd      	mov	sp, r7
     16c:	b004      	add	sp, #16
     16e:	bd80      	pop	{r7, pc}

	if (digits > 0) {
     170:	41004400 	.word	0x41004400

00000174 <port_get_group_from_gpio_pin>:
     174:	b580      	push	{r7, lr}
     176:	b082      	sub	sp, #8
		n += Buffer_writer(".");
     178:	af00      	add	r7, sp, #0
     17a:	0002      	movs	r2, r0
     17c:	1dfb      	adds	r3, r7, #7
     17e:	701a      	strb	r2, [r3, #0]
     180:	1dfb      	adds	r3, r7, #7
     182:	781b      	ldrb	r3, [r3, #0]
     184:	0018      	movs	r0, r3
     186:	4b03      	ldr	r3, [pc, #12]	; (194 <port_get_group_from_gpio_pin+0x20>)
	}

	while (digits-- > 0)
     188:	4798      	blx	r3
	{
		remainder *= 10.0;
     18a:	0003      	movs	r3, r0
     18c:	0018      	movs	r0, r3
     18e:	46bd      	mov	sp, r7
     190:	b002      	add	sp, #8
     192:	bd80      	pop	{r7, pc}
     194:	00000115 	.word	0x00000115

00000198 <port_get_config_defaults>:
     198:	b580      	push	{r7, lr}
     19a:	b082      	sub	sp, #8
     19c:	af00      	add	r7, sp, #0
		int toPrint = (int)(remainder);
     19e:	6078      	str	r0, [r7, #4]
     1a0:	687b      	ldr	r3, [r7, #4]
     1a2:	2200      	movs	r2, #0
     1a4:	701a      	strb	r2, [r3, #0]
     1a6:	687b      	ldr	r3, [r7, #4]
     1a8:	2201      	movs	r2, #1
		n += print_int(toPrint);
     1aa:	705a      	strb	r2, [r3, #1]
     1ac:	687b      	ldr	r3, [r7, #4]
     1ae:	2200      	movs	r2, #0
     1b0:	709a      	strb	r2, [r3, #2]
     1b2:	46c0      	nop			; (mov r8, r8)
     1b4:	46bd      	mov	sp, r7
     1b6:	b002      	add	sp, #8
     1b8:	bd80      	pop	{r7, pc}
	...

000001bc <port_pin_set_output_level>:
		remainder -= toPrint;
     1bc:	b580      	push	{r7, lr}
     1be:	b084      	sub	sp, #16
     1c0:	af00      	add	r7, sp, #0
     1c2:	0002      	movs	r2, r0
     1c4:	1dfb      	adds	r3, r7, #7
     1c6:	701a      	strb	r2, [r3, #0]
     1c8:	1dbb      	adds	r3, r7, #6
     1ca:	1c0a      	adds	r2, r1, #0
     1cc:	701a      	strb	r2, [r3, #0]
     1ce:	1dfb      	adds	r3, r7, #7
     1d0:	781b      	ldrb	r3, [r3, #0]
     1d2:	0018      	movs	r0, r3
	while (digits-- > 0)
     1d4:	4b0d      	ldr	r3, [pc, #52]	; (20c <port_pin_set_output_level+0x50>)
     1d6:	4798      	blx	r3
     1d8:	0003      	movs	r3, r0
     1da:	60fb      	str	r3, [r7, #12]
     1dc:	1dfb      	adds	r3, r7, #7
     1de:	781b      	ldrb	r3, [r3, #0]
     1e0:	221f      	movs	r2, #31
	}

	return n;
     1e2:	4013      	ands	r3, r2
}
     1e4:	2201      	movs	r2, #1
     1e6:	409a      	lsls	r2, r3
     1e8:	0013      	movs	r3, r2
     1ea:	60bb      	str	r3, [r7, #8]
     1ec:	1dbb      	adds	r3, r7, #6
     1ee:	781b      	ldrb	r3, [r3, #0]
     1f0:	2b00      	cmp	r3, #0
     1f2:	d003      	beq.n	1fc <port_pin_set_output_level+0x40>
     1f4:	68fb      	ldr	r3, [r7, #12]
     1f6:	68ba      	ldr	r2, [r7, #8]
     1f8:	619a      	str	r2, [r3, #24]
     1fa:	e002      	b.n	202 <port_pin_set_output_level+0x46>
     1fc:	68fb      	ldr	r3, [r7, #12]
     1fe:	68ba      	ldr	r2, [r7, #8]
     200:	615a      	str	r2, [r3, #20]
     202:	46c0      	nop			; (mov r8, r8)
     204:	46bd      	mov	sp, r7
     206:	b004      	add	sp, #16
     208:	bd80      	pop	{r7, pc}
     20a:	46c0      	nop			; (mov r8, r8)
     20c:	00000175 	.word	0x00000175

00000210 <LCD_init>:
     210:	b5f0      	push	{r4, r5, r6, r7, lr}
     212:	b08b      	sub	sp, #44	; 0x2c
     214:	af00      	add	r7, sp, #0
     216:	230b      	movs	r3, #11
     218:	2218      	movs	r2, #24
     21a:	4694      	mov	ip, r2
     21c:	44bc      	add	ip, r7
     21e:	4463      	add	r3, ip
     220:	2210      	movs	r2, #16
     222:	701a      	strb	r2, [r3, #0]
     224:	230a      	movs	r3, #10
     226:	2218      	movs	r2, #24
     228:	4694      	mov	ip, r2
     22a:	44bc      	add	ip, r7
     22c:	4463      	add	r3, ip
     22e:	2202      	movs	r2, #2
     230:	701a      	strb	r2, [r3, #0]
     232:	4b90      	ldr	r3, [pc, #576]	; (474 <LCD_init+0x264>)
     234:	4798      	blx	r3
     236:	4b90      	ldr	r3, [pc, #576]	; (478 <LCD_init+0x268>)
     238:	223f      	movs	r2, #63	; 0x3f
     23a:	701a      	strb	r2, [r3, #0]
     23c:	4b8f      	ldr	r3, [pc, #572]	; (47c <LCD_init+0x26c>)
     23e:	223e      	movs	r2, #62	; 0x3e
     240:	701a      	strb	r2, [r3, #0]
     242:	4b8f      	ldr	r3, [pc, #572]	; (480 <LCD_init+0x270>)
     244:	2221      	movs	r2, #33	; 0x21
     246:	701a      	strb	r2, [r3, #0]
     248:	4b8d      	ldr	r3, [pc, #564]	; (480 <LCD_init+0x270>)
     24a:	2220      	movs	r2, #32
     24c:	705a      	strb	r2, [r3, #1]
     24e:	4b8c      	ldr	r3, [pc, #560]	; (480 <LCD_init+0x270>)
	_data_pins[2] = LCD_DATA_LINE_D6_PIN;
     250:	2223      	movs	r2, #35	; 0x23
     252:	709a      	strb	r2, [r3, #2]
	_data_pins[3] = LCD_DATA_LINE_D7_PIN;
     254:	4b8a      	ldr	r3, [pc, #552]	; (480 <LCD_init+0x270>)
     256:	2222      	movs	r2, #34	; 0x22
     258:	70da      	strb	r2, [r3, #3]
	_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
     25a:	4b8a      	ldr	r3, [pc, #552]	; (484 <LCD_init+0x274>)
     25c:	2200      	movs	r2, #0
     25e:	701a      	strb	r2, [r3, #0]
	if (lines > 1)
     260:	230a      	movs	r3, #10
     262:	2218      	movs	r2, #24
     264:	4694      	mov	ip, r2
     266:	44bc      	add	ip, r7
     268:	4463      	add	r3, ip
     26a:	781b      	ldrb	r3, [r3, #0]
     26c:	2b01      	cmp	r3, #1
     26e:	d906      	bls.n	27e <LCD_init+0x6e>
		_displayfunction |= LCD_2LINE;
     270:	4b84      	ldr	r3, [pc, #528]	; (484 <LCD_init+0x274>)
     272:	781b      	ldrb	r3, [r3, #0]
     274:	2208      	movs	r2, #8
     276:	4313      	orrs	r3, r2
     278:	b2da      	uxtb	r2, r3
     27a:	4b82      	ldr	r3, [pc, #520]	; (484 <LCD_init+0x274>)
     27c:	701a      	strb	r2, [r3, #0]
	_numlines = lines;
     27e:	4b82      	ldr	r3, [pc, #520]	; (488 <LCD_init+0x278>)
     280:	220a      	movs	r2, #10
     282:	2118      	movs	r1, #24
     284:	468c      	mov	ip, r1
     286:	44bc      	add	ip, r7
     288:	4462      	add	r2, ip
     28a:	7812      	ldrb	r2, [r2, #0]
     28c:	701a      	strb	r2, [r3, #0]
	LCD_setRowOffsets(0x00, 0x40, 0x00 + cols, 0x40 + cols);
     28e:	230b      	movs	r3, #11
     290:	2218      	movs	r2, #24
     292:	4694      	mov	ip, r2
     294:	44bc      	add	ip, r7
     296:	4463      	add	r3, ip
     298:	781a      	ldrb	r2, [r3, #0]
     29a:	230b      	movs	r3, #11
     29c:	2118      	movs	r1, #24
     29e:	468c      	mov	ip, r1
     2a0:	44bc      	add	ip, r7
     2a2:	4463      	add	r3, ip
     2a4:	781b      	ldrb	r3, [r3, #0]
     2a6:	3340      	adds	r3, #64	; 0x40
     2a8:	2140      	movs	r1, #64	; 0x40
     2aa:	2000      	movs	r0, #0
     2ac:	4c77      	ldr	r4, [pc, #476]	; (48c <LCD_init+0x27c>)
     2ae:	47a0      	blx	r4
	port_get_config_defaults(&config_port_pin);
     2b0:	231c      	movs	r3, #28
     2b2:	18fb      	adds	r3, r7, r3
     2b4:	0018      	movs	r0, r3
     2b6:	4b76      	ldr	r3, [pc, #472]	; (490 <LCD_init+0x280>)
     2b8:	4798      	blx	r3
	config_port_pin.direction = PORT_PIN_DIR_OUTPUT;
     2ba:	231c      	movs	r3, #28
     2bc:	18fb      	adds	r3, r7, r3
     2be:	2201      	movs	r2, #1
     2c0:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(_rs_pin,&config_port_pin);
     2c2:	4b6d      	ldr	r3, [pc, #436]	; (478 <LCD_init+0x268>)
     2c4:	781b      	ldrb	r3, [r3, #0]
     2c6:	221c      	movs	r2, #28
     2c8:	18ba      	adds	r2, r7, r2
     2ca:	0011      	movs	r1, r2
     2cc:	0018      	movs	r0, r3
     2ce:	4b71      	ldr	r3, [pc, #452]	; (494 <LCD_init+0x284>)
     2d0:	4798      	blx	r3
	port_pin_set_config(_enable_pin,&config_port_pin);
     2d2:	4b6a      	ldr	r3, [pc, #424]	; (47c <LCD_init+0x26c>)
     2d4:	781b      	ldrb	r3, [r3, #0]
     2d6:	221c      	movs	r2, #28
     2d8:	18ba      	adds	r2, r7, r2
     2da:	0011      	movs	r1, r2
     2dc:	0018      	movs	r0, r3
     2de:	4b6d      	ldr	r3, [pc, #436]	; (494 <LCD_init+0x284>)
     2e0:	4798      	blx	r3
	for (int i=0; i<4; ++i)
     2e2:	2300      	movs	r3, #0
     2e4:	627b      	str	r3, [r7, #36]	; 0x24
     2e6:	e00c      	b.n	302 <LCD_init+0xf2>
		port_pin_set_config(_data_pins[i],&config_port_pin);
     2e8:	4a65      	ldr	r2, [pc, #404]	; (480 <LCD_init+0x270>)
     2ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     2ec:	18d3      	adds	r3, r2, r3
     2ee:	781b      	ldrb	r3, [r3, #0]
     2f0:	221c      	movs	r2, #28
     2f2:	18ba      	adds	r2, r7, r2
     2f4:	0011      	movs	r1, r2
     2f6:	0018      	movs	r0, r3
     2f8:	4b66      	ldr	r3, [pc, #408]	; (494 <LCD_init+0x284>)
     2fa:	4798      	blx	r3
	for (int i=0; i<4; ++i)
     2fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     2fe:	3301      	adds	r3, #1
     300:	627b      	str	r3, [r7, #36]	; 0x24
     302:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     304:	2b03      	cmp	r3, #3
     306:	ddef      	ble.n	2e8 <LCD_init+0xd8>
	delay_us(50000);
     308:	2000      	movs	r0, #0
     30a:	4b63      	ldr	r3, [pc, #396]	; (498 <LCD_init+0x288>)
     30c:	4798      	blx	r3
     30e:	0003      	movs	r3, r0
     310:	613b      	str	r3, [r7, #16]
     312:	2300      	movs	r3, #0
     314:	617b      	str	r3, [r7, #20]
     316:	4c61      	ldr	r4, [pc, #388]	; (49c <LCD_init+0x28c>)
     318:	4a61      	ldr	r2, [pc, #388]	; (4a0 <LCD_init+0x290>)
     31a:	2300      	movs	r3, #0
     31c:	6938      	ldr	r0, [r7, #16]
     31e:	6979      	ldr	r1, [r7, #20]
     320:	47a0      	blx	r4
     322:	0003      	movs	r3, r0
     324:	000c      	movs	r4, r1
     326:	0019      	movs	r1, r3
     328:	0022      	movs	r2, r4
     32a:	4b5e      	ldr	r3, [pc, #376]	; (4a4 <LCD_init+0x294>)
     32c:	2400      	movs	r4, #0
     32e:	18c9      	adds	r1, r1, r3
     330:	4162      	adcs	r2, r4
     332:	0008      	movs	r0, r1
     334:	0011      	movs	r1, r2
     336:	4c5c      	ldr	r4, [pc, #368]	; (4a8 <LCD_init+0x298>)
     338:	4a5c      	ldr	r2, [pc, #368]	; (4ac <LCD_init+0x29c>)
     33a:	2300      	movs	r3, #0
     33c:	47a0      	blx	r4
     33e:	0003      	movs	r3, r0
     340:	000c      	movs	r4, r1
     342:	0018      	movs	r0, r3
     344:	4b5a      	ldr	r3, [pc, #360]	; (4b0 <LCD_init+0x2a0>)
     346:	4798      	blx	r3
	port_pin_set_output_level(_rs_pin,LOW);
     348:	4b4b      	ldr	r3, [pc, #300]	; (478 <LCD_init+0x268>)
     34a:	781b      	ldrb	r3, [r3, #0]
     34c:	2100      	movs	r1, #0
     34e:	0018      	movs	r0, r3
     350:	4b58      	ldr	r3, [pc, #352]	; (4b4 <LCD_init+0x2a4>)
     352:	4798      	blx	r3
	port_pin_set_output_level(_enable_pin,LOW);
     354:	4b49      	ldr	r3, [pc, #292]	; (47c <LCD_init+0x26c>)
     356:	781b      	ldrb	r3, [r3, #0]
     358:	2100      	movs	r1, #0
     35a:	0018      	movs	r0, r3
     35c:	4b55      	ldr	r3, [pc, #340]	; (4b4 <LCD_init+0x2a4>)
     35e:	4798      	blx	r3
	 write4bits(0x03);
     360:	2003      	movs	r0, #3
     362:	4b55      	ldr	r3, [pc, #340]	; (4b8 <LCD_init+0x2a8>)
     364:	4798      	blx	r3
	 delay_us(4500); 
     366:	2000      	movs	r0, #0
     368:	4b4b      	ldr	r3, [pc, #300]	; (498 <LCD_init+0x288>)
     36a:	4798      	blx	r3
     36c:	0003      	movs	r3, r0
     36e:	60bb      	str	r3, [r7, #8]
     370:	2300      	movs	r3, #0
     372:	60fb      	str	r3, [r7, #12]
     374:	4c49      	ldr	r4, [pc, #292]	; (49c <LCD_init+0x28c>)
     376:	4a51      	ldr	r2, [pc, #324]	; (4bc <LCD_init+0x2ac>)
     378:	2300      	movs	r3, #0
     37a:	68b8      	ldr	r0, [r7, #8]
     37c:	68f9      	ldr	r1, [r7, #12]
     37e:	47a0      	blx	r4
     380:	0003      	movs	r3, r0
     382:	000c      	movs	r4, r1
     384:	0019      	movs	r1, r3
     386:	0022      	movs	r2, r4
     388:	4b46      	ldr	r3, [pc, #280]	; (4a4 <LCD_init+0x294>)
     38a:	2400      	movs	r4, #0
     38c:	18c9      	adds	r1, r1, r3
     38e:	4162      	adcs	r2, r4
     390:	0008      	movs	r0, r1
     392:	0011      	movs	r1, r2
     394:	4c44      	ldr	r4, [pc, #272]	; (4a8 <LCD_init+0x298>)
     396:	4a45      	ldr	r2, [pc, #276]	; (4ac <LCD_init+0x29c>)
     398:	2300      	movs	r3, #0
     39a:	47a0      	blx	r4
     39c:	0003      	movs	r3, r0
     39e:	000c      	movs	r4, r1
     3a0:	0018      	movs	r0, r3
     3a2:	4b43      	ldr	r3, [pc, #268]	; (4b0 <LCD_init+0x2a0>)
     3a4:	4798      	blx	r3
	 write4bits(0x03);
     3a6:	2003      	movs	r0, #3
     3a8:	4b43      	ldr	r3, [pc, #268]	; (4b8 <LCD_init+0x2a8>)
     3aa:	4798      	blx	r3
	 delay_us(4500); 
     3ac:	2000      	movs	r0, #0
     3ae:	4b3a      	ldr	r3, [pc, #232]	; (498 <LCD_init+0x288>)
     3b0:	4798      	blx	r3
     3b2:	0003      	movs	r3, r0
     3b4:	603b      	str	r3, [r7, #0]
     3b6:	2300      	movs	r3, #0
     3b8:	607b      	str	r3, [r7, #4]
     3ba:	4c38      	ldr	r4, [pc, #224]	; (49c <LCD_init+0x28c>)
     3bc:	4a3f      	ldr	r2, [pc, #252]	; (4bc <LCD_init+0x2ac>)
     3be:	2300      	movs	r3, #0
     3c0:	6838      	ldr	r0, [r7, #0]
     3c2:	6879      	ldr	r1, [r7, #4]
     3c4:	47a0      	blx	r4
     3c6:	0003      	movs	r3, r0
     3c8:	000c      	movs	r4, r1
     3ca:	0019      	movs	r1, r3
     3cc:	0022      	movs	r2, r4
     3ce:	4b35      	ldr	r3, [pc, #212]	; (4a4 <LCD_init+0x294>)
     3d0:	2400      	movs	r4, #0
     3d2:	18c9      	adds	r1, r1, r3
     3d4:	4162      	adcs	r2, r4
     3d6:	0008      	movs	r0, r1
     3d8:	0011      	movs	r1, r2
     3da:	4c33      	ldr	r4, [pc, #204]	; (4a8 <LCD_init+0x298>)
     3dc:	4a33      	ldr	r2, [pc, #204]	; (4ac <LCD_init+0x29c>)
     3de:	2300      	movs	r3, #0
     3e0:	47a0      	blx	r4
     3e2:	0003      	movs	r3, r0
     3e4:	000c      	movs	r4, r1
     3e6:	0018      	movs	r0, r3
     3e8:	4b31      	ldr	r3, [pc, #196]	; (4b0 <LCD_init+0x2a0>)
     3ea:	4798      	blx	r3
	 write4bits(0x03);
     3ec:	2003      	movs	r0, #3
     3ee:	4b32      	ldr	r3, [pc, #200]	; (4b8 <LCD_init+0x2a8>)
     3f0:	4798      	blx	r3
	 delay_us(150);
     3f2:	2000      	movs	r0, #0
     3f4:	4b28      	ldr	r3, [pc, #160]	; (498 <LCD_init+0x288>)
     3f6:	4798      	blx	r3
     3f8:	0003      	movs	r3, r0
     3fa:	001d      	movs	r5, r3
     3fc:	2300      	movs	r3, #0
     3fe:	001e      	movs	r6, r3
     400:	4c26      	ldr	r4, [pc, #152]	; (49c <LCD_init+0x28c>)
     402:	2296      	movs	r2, #150	; 0x96
     404:	2300      	movs	r3, #0
     406:	0028      	movs	r0, r5
     408:	0031      	movs	r1, r6
     40a:	47a0      	blx	r4
     40c:	0003      	movs	r3, r0
     40e:	000c      	movs	r4, r1
     410:	0019      	movs	r1, r3
     412:	0022      	movs	r2, r4
     414:	4b23      	ldr	r3, [pc, #140]	; (4a4 <LCD_init+0x294>)
     416:	2400      	movs	r4, #0
     418:	18c9      	adds	r1, r1, r3
     41a:	4162      	adcs	r2, r4
     41c:	0008      	movs	r0, r1
     41e:	0011      	movs	r1, r2
     420:	4c21      	ldr	r4, [pc, #132]	; (4a8 <LCD_init+0x298>)
     422:	4a22      	ldr	r2, [pc, #136]	; (4ac <LCD_init+0x29c>)
     424:	2300      	movs	r3, #0
     426:	47a0      	blx	r4
     428:	0003      	movs	r3, r0
     42a:	000c      	movs	r4, r1
     42c:	0018      	movs	r0, r3
     42e:	4b20      	ldr	r3, [pc, #128]	; (4b0 <LCD_init+0x2a0>)
     430:	4798      	blx	r3
	 write4bits(0x02);
     432:	2002      	movs	r0, #2
     434:	4b20      	ldr	r3, [pc, #128]	; (4b8 <LCD_init+0x2a8>)
     436:	4798      	blx	r3
	 command(LCD_FUNCTIONSET | _displayfunction);
     438:	4b12      	ldr	r3, [pc, #72]	; (484 <LCD_init+0x274>)
     43a:	781b      	ldrb	r3, [r3, #0]
     43c:	2220      	movs	r2, #32
     43e:	4313      	orrs	r3, r2
     440:	b2db      	uxtb	r3, r3
     442:	0018      	movs	r0, r3
     444:	4b1e      	ldr	r3, [pc, #120]	; (4c0 <LCD_init+0x2b0>)
     446:	4798      	blx	r3
	_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
     448:	4b1e      	ldr	r3, [pc, #120]	; (4c4 <LCD_init+0x2b4>)
     44a:	2204      	movs	r2, #4
     44c:	701a      	strb	r2, [r3, #0]
	LCD_display();
     44e:	4b1e      	ldr	r3, [pc, #120]	; (4c8 <LCD_init+0x2b8>)
     450:	4798      	blx	r3
	LCD_clear();
     452:	4b1e      	ldr	r3, [pc, #120]	; (4cc <LCD_init+0x2bc>)
     454:	4798      	blx	r3
	_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
     456:	4b1e      	ldr	r3, [pc, #120]	; (4d0 <LCD_init+0x2c0>)
     458:	2202      	movs	r2, #2
     45a:	701a      	strb	r2, [r3, #0]
	command(LCD_ENTRYMODESET | _displaymode);
     45c:	4b1c      	ldr	r3, [pc, #112]	; (4d0 <LCD_init+0x2c0>)
     45e:	781b      	ldrb	r3, [r3, #0]
     460:	2204      	movs	r2, #4
     462:	4313      	orrs	r3, r2
     464:	b2db      	uxtb	r3, r3
     466:	0018      	movs	r0, r3
     468:	4b15      	ldr	r3, [pc, #84]	; (4c0 <LCD_init+0x2b0>)
     46a:	4798      	blx	r3
}
     46c:	46c0      	nop			; (mov r8, r8)
     46e:	46bd      	mov	sp, r7
     470:	b00b      	add	sp, #44	; 0x2c
     472:	bdf0      	pop	{r4, r5, r6, r7, pc}
     474:	00001d75 	.word	0x00001d75
     478:	20000193 	.word	0x20000193
     47c:	20000192 	.word	0x20000192
     480:	2000018c 	.word	0x2000018c
     484:	20000191 	.word	0x20000191
     488:	2000018a 	.word	0x2000018a
     48c:	00000521 	.word	0x00000521
     490:	00000199 	.word	0x00000199
     494:	00001f05 	.word	0x00001f05
     498:	00002c51 	.word	0x00002c51
     49c:	00003b79 	.word	0x00003b79
     4a0:	0000c350 	.word	0x0000c350
     4a4:	006acfbf 	.word	0x006acfbf
     4a8:	00003b39 	.word	0x00003b39
     4ac:	006acfc0 	.word	0x006acfc0
     4b0:	20000001 	.word	0x20000001
     4b4:	000001bd 	.word	0x000001bd
     4b8:	0000055d 	.word	0x0000055d
     4bc:	00001194 	.word	0x00001194
     4c0:	000006a1 	.word	0x000006a1
     4c4:	20000189 	.word	0x20000189
     4c8:	00000889 	.word	0x00000889
     4cc:	00000741 	.word	0x00000741
     4d0:	20000190 	.word	0x20000190

000004d4 <LCD_PWR_CONFIG>:
{
     4d4:	b580      	push	{r7, lr}
     4d6:	b082      	sub	sp, #8
     4d8:	af00      	add	r7, sp, #0
	port_get_config_defaults(&pin_conf_gsm_status);
     4da:	1d3b      	adds	r3, r7, #4
     4dc:	0018      	movs	r0, r3
     4de:	4b08      	ldr	r3, [pc, #32]	; (500 <LCD_PWR_CONFIG+0x2c>)
     4e0:	4798      	blx	r3
	pin_conf_gsm_status.direction  = PORT_PIN_DIR_OUTPUT;
     4e2:	1d3b      	adds	r3, r7, #4
     4e4:	2201      	movs	r2, #1
     4e6:	701a      	strb	r2, [r3, #0]
	pin_conf_gsm_status.input_pull = PORT_PIN_PULL_NONE;
     4e8:	1d3b      	adds	r3, r7, #4
     4ea:	2200      	movs	r2, #0
     4ec:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(LCD_PWR_CNTRL, &pin_conf_gsm_status);
     4ee:	1d3b      	adds	r3, r7, #4
     4f0:	0019      	movs	r1, r3
     4f2:	2024      	movs	r0, #36	; 0x24
     4f4:	4b03      	ldr	r3, [pc, #12]	; (504 <LCD_PWR_CONFIG+0x30>)
     4f6:	4798      	blx	r3
}
     4f8:	46c0      	nop			; (mov r8, r8)
     4fa:	46bd      	mov	sp, r7
     4fc:	b002      	add	sp, #8
     4fe:	bd80      	pop	{r7, pc}
     500:	00000199 	.word	0x00000199
     504:	00001f05 	.word	0x00001f05

00000508 <LCD_PWR_EN>:
{
     508:	b580      	push	{r7, lr}
     50a:	af00      	add	r7, sp, #0
	port_pin_set_output_level(LCD_PWR_CNTRL,HIGH);
     50c:	2101      	movs	r1, #1
     50e:	2024      	movs	r0, #36	; 0x24
     510:	4b02      	ldr	r3, [pc, #8]	; (51c <LCD_PWR_EN+0x14>)
     512:	4798      	blx	r3
}
     514:	46c0      	nop			; (mov r8, r8)
     516:	46bd      	mov	sp, r7
     518:	bd80      	pop	{r7, pc}
     51a:	46c0      	nop			; (mov r8, r8)
     51c:	000001bd 	.word	0x000001bd

00000520 <LCD_setRowOffsets>:
{
     520:	b580      	push	{r7, lr}
     522:	b084      	sub	sp, #16
     524:	af00      	add	r7, sp, #0
     526:	60f8      	str	r0, [r7, #12]
     528:	60b9      	str	r1, [r7, #8]
     52a:	607a      	str	r2, [r7, #4]
     52c:	603b      	str	r3, [r7, #0]
	_row_offsets[0] = row0;
     52e:	68fb      	ldr	r3, [r7, #12]
     530:	b2da      	uxtb	r2, r3
     532:	4b09      	ldr	r3, [pc, #36]	; (558 <LCD_setRowOffsets+0x38>)
     534:	701a      	strb	r2, [r3, #0]
	_row_offsets[1] = row1;
     536:	68bb      	ldr	r3, [r7, #8]
     538:	b2da      	uxtb	r2, r3
     53a:	4b07      	ldr	r3, [pc, #28]	; (558 <LCD_setRowOffsets+0x38>)
     53c:	705a      	strb	r2, [r3, #1]
	_row_offsets[2] = row2;
     53e:	687b      	ldr	r3, [r7, #4]
     540:	b2da      	uxtb	r2, r3
     542:	4b05      	ldr	r3, [pc, #20]	; (558 <LCD_setRowOffsets+0x38>)
     544:	709a      	strb	r2, [r3, #2]
	_row_offsets[3] = row3;
     546:	683b      	ldr	r3, [r7, #0]
     548:	b2da      	uxtb	r2, r3
     54a:	4b03      	ldr	r3, [pc, #12]	; (558 <LCD_setRowOffsets+0x38>)
     54c:	70da      	strb	r2, [r3, #3]
}
     54e:	46c0      	nop			; (mov r8, r8)
     550:	46bd      	mov	sp, r7
     552:	b004      	add	sp, #16
     554:	bd80      	pop	{r7, pc}
     556:	46c0      	nop			; (mov r8, r8)
     558:	20000184 	.word	0x20000184

0000055c <write4bits>:
{
     55c:	b580      	push	{r7, lr}
     55e:	b084      	sub	sp, #16
     560:	af00      	add	r7, sp, #0
     562:	0002      	movs	r2, r0
     564:	1dfb      	adds	r3, r7, #7
     566:	701a      	strb	r2, [r3, #0]
	for (int i = 0; i < 4; i++) 
     568:	2300      	movs	r3, #0
     56a:	60fb      	str	r3, [r7, #12]
     56c:	e013      	b.n	596 <write4bits+0x3a>
		port_pin_set_output_level(_data_pins[i], (value >> i) & 0x01);
     56e:	4a0e      	ldr	r2, [pc, #56]	; (5a8 <write4bits+0x4c>)
     570:	68fb      	ldr	r3, [r7, #12]
     572:	18d3      	adds	r3, r2, r3
     574:	7818      	ldrb	r0, [r3, #0]
     576:	1dfb      	adds	r3, r7, #7
     578:	781a      	ldrb	r2, [r3, #0]
     57a:	68fb      	ldr	r3, [r7, #12]
     57c:	411a      	asrs	r2, r3
     57e:	0013      	movs	r3, r2
     580:	2201      	movs	r2, #1
     582:	4013      	ands	r3, r2
     584:	1e5a      	subs	r2, r3, #1
     586:	4193      	sbcs	r3, r2
     588:	b2db      	uxtb	r3, r3
     58a:	0019      	movs	r1, r3
     58c:	4b07      	ldr	r3, [pc, #28]	; (5ac <write4bits+0x50>)
     58e:	4798      	blx	r3
	for (int i = 0; i < 4; i++) 
     590:	68fb      	ldr	r3, [r7, #12]
     592:	3301      	adds	r3, #1
     594:	60fb      	str	r3, [r7, #12]
     596:	68fb      	ldr	r3, [r7, #12]
     598:	2b03      	cmp	r3, #3
     59a:	dde8      	ble.n	56e <write4bits+0x12>
	pulseEnable();
     59c:	4b04      	ldr	r3, [pc, #16]	; (5b0 <write4bits+0x54>)
     59e:	4798      	blx	r3
}
     5a0:	46c0      	nop			; (mov r8, r8)
     5a2:	46bd      	mov	sp, r7
     5a4:	b004      	add	sp, #16
     5a6:	bd80      	pop	{r7, pc}
     5a8:	2000018c 	.word	0x2000018c
     5ac:	000001bd 	.word	0x000001bd
     5b0:	000005b5 	.word	0x000005b5

000005b4 <pulseEnable>:
{
     5b4:	b5f0      	push	{r4, r5, r6, r7, lr}
     5b6:	b085      	sub	sp, #20
     5b8:	af00      	add	r7, sp, #0
 	port_pin_set_output_level(_enable_pin, LOW);
     5ba:	4b31      	ldr	r3, [pc, #196]	; (680 <pulseEnable+0xcc>)
     5bc:	781b      	ldrb	r3, [r3, #0]
     5be:	2100      	movs	r1, #0
     5c0:	0018      	movs	r0, r3
     5c2:	4b30      	ldr	r3, [pc, #192]	; (684 <pulseEnable+0xd0>)
     5c4:	4798      	blx	r3
 	delay_us(1);
     5c6:	2000      	movs	r0, #0
     5c8:	4b2f      	ldr	r3, [pc, #188]	; (688 <pulseEnable+0xd4>)
     5ca:	4798      	blx	r3
     5cc:	0003      	movs	r3, r0
     5ce:	60bb      	str	r3, [r7, #8]
     5d0:	2300      	movs	r3, #0
     5d2:	60fb      	str	r3, [r7, #12]
     5d4:	4b2d      	ldr	r3, [pc, #180]	; (68c <pulseEnable+0xd8>)
     5d6:	2400      	movs	r4, #0
     5d8:	68b8      	ldr	r0, [r7, #8]
     5da:	68f9      	ldr	r1, [r7, #12]
     5dc:	18c0      	adds	r0, r0, r3
     5de:	4161      	adcs	r1, r4
     5e0:	4c2b      	ldr	r4, [pc, #172]	; (690 <pulseEnable+0xdc>)
     5e2:	4a2c      	ldr	r2, [pc, #176]	; (694 <pulseEnable+0xe0>)
     5e4:	2300      	movs	r3, #0
     5e6:	47a0      	blx	r4
     5e8:	0003      	movs	r3, r0
     5ea:	000c      	movs	r4, r1
     5ec:	0018      	movs	r0, r3
     5ee:	4b2a      	ldr	r3, [pc, #168]	; (698 <pulseEnable+0xe4>)
     5f0:	4798      	blx	r3
 	port_pin_set_output_level(_enable_pin, HIGH);
     5f2:	4b23      	ldr	r3, [pc, #140]	; (680 <pulseEnable+0xcc>)
     5f4:	781b      	ldrb	r3, [r3, #0]
     5f6:	2101      	movs	r1, #1
     5f8:	0018      	movs	r0, r3
     5fa:	4b22      	ldr	r3, [pc, #136]	; (684 <pulseEnable+0xd0>)
     5fc:	4798      	blx	r3
 	delay_us(1);
     5fe:	2000      	movs	r0, #0
     600:	4b21      	ldr	r3, [pc, #132]	; (688 <pulseEnable+0xd4>)
     602:	4798      	blx	r3
     604:	0003      	movs	r3, r0
     606:	001d      	movs	r5, r3
     608:	2300      	movs	r3, #0
     60a:	001e      	movs	r6, r3
     60c:	4b1f      	ldr	r3, [pc, #124]	; (68c <pulseEnable+0xd8>)
     60e:	2400      	movs	r4, #0
     610:	0028      	movs	r0, r5
     612:	0031      	movs	r1, r6
     614:	18c0      	adds	r0, r0, r3
     616:	4161      	adcs	r1, r4
     618:	4c1d      	ldr	r4, [pc, #116]	; (690 <pulseEnable+0xdc>)
     61a:	4a1e      	ldr	r2, [pc, #120]	; (694 <pulseEnable+0xe0>)
     61c:	2300      	movs	r3, #0
     61e:	47a0      	blx	r4
     620:	0003      	movs	r3, r0
     622:	000c      	movs	r4, r1
     624:	0018      	movs	r0, r3
     626:	4b1c      	ldr	r3, [pc, #112]	; (698 <pulseEnable+0xe4>)
     628:	4798      	blx	r3
 	port_pin_set_output_level(_enable_pin, LOW);
     62a:	4b15      	ldr	r3, [pc, #84]	; (680 <pulseEnable+0xcc>)
     62c:	781b      	ldrb	r3, [r3, #0]
     62e:	2100      	movs	r1, #0
     630:	0018      	movs	r0, r3
     632:	4b14      	ldr	r3, [pc, #80]	; (684 <pulseEnable+0xd0>)
     634:	4798      	blx	r3
 	delay_us(100);
     636:	2000      	movs	r0, #0
     638:	4b13      	ldr	r3, [pc, #76]	; (688 <pulseEnable+0xd4>)
     63a:	4798      	blx	r3
     63c:	0003      	movs	r3, r0
     63e:	603b      	str	r3, [r7, #0]
     640:	2300      	movs	r3, #0
     642:	607b      	str	r3, [r7, #4]
     644:	4c15      	ldr	r4, [pc, #84]	; (69c <pulseEnable+0xe8>)
     646:	2264      	movs	r2, #100	; 0x64
     648:	2300      	movs	r3, #0
     64a:	6838      	ldr	r0, [r7, #0]
     64c:	6879      	ldr	r1, [r7, #4]
     64e:	47a0      	blx	r4
     650:	0003      	movs	r3, r0
     652:	000c      	movs	r4, r1
     654:	0019      	movs	r1, r3
     656:	0022      	movs	r2, r4
     658:	4b0c      	ldr	r3, [pc, #48]	; (68c <pulseEnable+0xd8>)
     65a:	2400      	movs	r4, #0
     65c:	18c9      	adds	r1, r1, r3
     65e:	4162      	adcs	r2, r4
     660:	0008      	movs	r0, r1
     662:	0011      	movs	r1, r2
     664:	4c0a      	ldr	r4, [pc, #40]	; (690 <pulseEnable+0xdc>)
     666:	4a0b      	ldr	r2, [pc, #44]	; (694 <pulseEnable+0xe0>)
     668:	2300      	movs	r3, #0
     66a:	47a0      	blx	r4
     66c:	0003      	movs	r3, r0
     66e:	000c      	movs	r4, r1
     670:	0018      	movs	r0, r3
     672:	4b09      	ldr	r3, [pc, #36]	; (698 <pulseEnable+0xe4>)
     674:	4798      	blx	r3
}
     676:	46c0      	nop			; (mov r8, r8)
     678:	46bd      	mov	sp, r7
     67a:	b005      	add	sp, #20
     67c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     67e:	46c0      	nop			; (mov r8, r8)
     680:	20000192 	.word	0x20000192
     684:	000001bd 	.word	0x000001bd
     688:	00002c51 	.word	0x00002c51
     68c:	006acfbf 	.word	0x006acfbf
     690:	00003b39 	.word	0x00003b39
     694:	006acfc0 	.word	0x006acfc0
     698:	20000001 	.word	0x20000001
     69c:	00003b79 	.word	0x00003b79

000006a0 <command>:
{
     6a0:	b580      	push	{r7, lr}
     6a2:	b082      	sub	sp, #8
     6a4:	af00      	add	r7, sp, #0
     6a6:	0002      	movs	r2, r0
     6a8:	1dfb      	adds	r3, r7, #7
     6aa:	701a      	strb	r2, [r3, #0]
	send(value, LOW);
     6ac:	1dfb      	adds	r3, r7, #7
     6ae:	781b      	ldrb	r3, [r3, #0]
     6b0:	2100      	movs	r1, #0
     6b2:	0018      	movs	r0, r3
     6b4:	4b02      	ldr	r3, [pc, #8]	; (6c0 <command+0x20>)
     6b6:	4798      	blx	r3
}
     6b8:	46c0      	nop			; (mov r8, r8)
     6ba:	46bd      	mov	sp, r7
     6bc:	b002      	add	sp, #8
     6be:	bd80      	pop	{r7, pc}
     6c0:	000006ed 	.word	0x000006ed

000006c4 <LCD_write>:
{
     6c4:	b580      	push	{r7, lr}
     6c6:	b082      	sub	sp, #8
     6c8:	af00      	add	r7, sp, #0
     6ca:	0002      	movs	r2, r0
     6cc:	1dfb      	adds	r3, r7, #7
     6ce:	701a      	strb	r2, [r3, #0]
	send(value, HIGH);
     6d0:	1dfb      	adds	r3, r7, #7
     6d2:	781b      	ldrb	r3, [r3, #0]
     6d4:	2101      	movs	r1, #1
     6d6:	0018      	movs	r0, r3
     6d8:	4b03      	ldr	r3, [pc, #12]	; (6e8 <LCD_write+0x24>)
     6da:	4798      	blx	r3
	return 1;
     6dc:	2301      	movs	r3, #1
}
     6de:	0018      	movs	r0, r3
     6e0:	46bd      	mov	sp, r7
     6e2:	b002      	add	sp, #8
     6e4:	bd80      	pop	{r7, pc}
     6e6:	46c0      	nop			; (mov r8, r8)
     6e8:	000006ed 	.word	0x000006ed

000006ec <send>:
{
     6ec:	b580      	push	{r7, lr}
     6ee:	b082      	sub	sp, #8
     6f0:	af00      	add	r7, sp, #0
     6f2:	0002      	movs	r2, r0
     6f4:	1dfb      	adds	r3, r7, #7
     6f6:	701a      	strb	r2, [r3, #0]
     6f8:	1dbb      	adds	r3, r7, #6
     6fa:	1c0a      	adds	r2, r1, #0
     6fc:	701a      	strb	r2, [r3, #0]
	port_pin_set_output_level(_rs_pin, mode);
     6fe:	4b0d      	ldr	r3, [pc, #52]	; (734 <send+0x48>)
     700:	781a      	ldrb	r2, [r3, #0]
     702:	1dbb      	adds	r3, r7, #6
     704:	781b      	ldrb	r3, [r3, #0]
     706:	1e59      	subs	r1, r3, #1
     708:	418b      	sbcs	r3, r1
     70a:	b2db      	uxtb	r3, r3
     70c:	0019      	movs	r1, r3
     70e:	0010      	movs	r0, r2
     710:	4b09      	ldr	r3, [pc, #36]	; (738 <send+0x4c>)
     712:	4798      	blx	r3
		write4bits(value>>4);
     714:	1dfb      	adds	r3, r7, #7
     716:	781b      	ldrb	r3, [r3, #0]
     718:	091b      	lsrs	r3, r3, #4
     71a:	b2db      	uxtb	r3, r3
     71c:	0018      	movs	r0, r3
     71e:	4b07      	ldr	r3, [pc, #28]	; (73c <send+0x50>)
     720:	4798      	blx	r3
		write4bits(value);
     722:	1dfb      	adds	r3, r7, #7
     724:	781b      	ldrb	r3, [r3, #0]
     726:	0018      	movs	r0, r3
     728:	4b04      	ldr	r3, [pc, #16]	; (73c <send+0x50>)
     72a:	4798      	blx	r3
}
     72c:	46c0      	nop			; (mov r8, r8)
     72e:	46bd      	mov	sp, r7
     730:	b002      	add	sp, #8
     732:	bd80      	pop	{r7, pc}
     734:	20000193 	.word	0x20000193
     738:	000001bd 	.word	0x000001bd
     73c:	0000055d 	.word	0x0000055d

00000740 <LCD_clear>:
{
     740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     742:	af00      	add	r7, sp, #0
	command(LCD_CLEARDISPLAY);
     744:	2001      	movs	r0, #1
     746:	4b13      	ldr	r3, [pc, #76]	; (794 <LCD_clear+0x54>)
     748:	4798      	blx	r3
	delay_us(2000);
     74a:	2000      	movs	r0, #0
     74c:	4b12      	ldr	r3, [pc, #72]	; (798 <LCD_clear+0x58>)
     74e:	4798      	blx	r3
     750:	0003      	movs	r3, r0
     752:	001d      	movs	r5, r3
     754:	2300      	movs	r3, #0
     756:	001e      	movs	r6, r3
     758:	4c10      	ldr	r4, [pc, #64]	; (79c <LCD_clear+0x5c>)
     75a:	22fa      	movs	r2, #250	; 0xfa
     75c:	00d2      	lsls	r2, r2, #3
     75e:	2300      	movs	r3, #0
     760:	0028      	movs	r0, r5
     762:	0031      	movs	r1, r6
     764:	47a0      	blx	r4
     766:	0003      	movs	r3, r0
     768:	000c      	movs	r4, r1
     76a:	0019      	movs	r1, r3
     76c:	0022      	movs	r2, r4
     76e:	4b0c      	ldr	r3, [pc, #48]	; (7a0 <LCD_clear+0x60>)
     770:	2400      	movs	r4, #0
     772:	18c9      	adds	r1, r1, r3
     774:	4162      	adcs	r2, r4
     776:	0008      	movs	r0, r1
     778:	0011      	movs	r1, r2
     77a:	4c0a      	ldr	r4, [pc, #40]	; (7a4 <LCD_clear+0x64>)
     77c:	4a0a      	ldr	r2, [pc, #40]	; (7a8 <LCD_clear+0x68>)
     77e:	2300      	movs	r3, #0
     780:	47a0      	blx	r4
     782:	0003      	movs	r3, r0
     784:	000c      	movs	r4, r1
     786:	0018      	movs	r0, r3
     788:	4b08      	ldr	r3, [pc, #32]	; (7ac <LCD_clear+0x6c>)
     78a:	4798      	blx	r3
}
     78c:	46c0      	nop			; (mov r8, r8)
     78e:	46bd      	mov	sp, r7
     790:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     792:	46c0      	nop			; (mov r8, r8)
     794:	000006a1 	.word	0x000006a1
     798:	00002c51 	.word	0x00002c51
     79c:	00003b79 	.word	0x00003b79
     7a0:	006acfbf 	.word	0x006acfbf
     7a4:	00003b39 	.word	0x00003b39
     7a8:	006acfc0 	.word	0x006acfc0
     7ac:	20000001 	.word	0x20000001

000007b0 <LCD_Create_Custom_createChar>:
{
     7b0:	b580      	push	{r7, lr}
     7b2:	b084      	sub	sp, #16
     7b4:	af00      	add	r7, sp, #0
     7b6:	0002      	movs	r2, r0
     7b8:	6039      	str	r1, [r7, #0]
     7ba:	1dfb      	adds	r3, r7, #7
     7bc:	701a      	strb	r2, [r3, #0]
	location &= 0x7;
     7be:	1dfb      	adds	r3, r7, #7
     7c0:	1dfa      	adds	r2, r7, #7
     7c2:	7812      	ldrb	r2, [r2, #0]
     7c4:	2107      	movs	r1, #7
     7c6:	400a      	ands	r2, r1
     7c8:	701a      	strb	r2, [r3, #0]
	command(LCD_SETCGRAMADDR | (location << 3));
     7ca:	1dfb      	adds	r3, r7, #7
     7cc:	781b      	ldrb	r3, [r3, #0]
     7ce:	00db      	lsls	r3, r3, #3
     7d0:	b25b      	sxtb	r3, r3
     7d2:	2240      	movs	r2, #64	; 0x40
     7d4:	4313      	orrs	r3, r2
     7d6:	b25b      	sxtb	r3, r3
     7d8:	b2db      	uxtb	r3, r3
     7da:	0018      	movs	r0, r3
     7dc:	4b0a      	ldr	r3, [pc, #40]	; (808 <LCD_Create_Custom_createChar+0x58>)
     7de:	4798      	blx	r3
	for (int i=0; i<8; i++)
     7e0:	2300      	movs	r3, #0
     7e2:	60fb      	str	r3, [r7, #12]
     7e4:	e009      	b.n	7fa <LCD_Create_Custom_createChar+0x4a>
		LCD_write(charmap[i]);
     7e6:	68fb      	ldr	r3, [r7, #12]
     7e8:	683a      	ldr	r2, [r7, #0]
     7ea:	18d3      	adds	r3, r2, r3
     7ec:	781b      	ldrb	r3, [r3, #0]
     7ee:	0018      	movs	r0, r3
     7f0:	4b06      	ldr	r3, [pc, #24]	; (80c <LCD_Create_Custom_createChar+0x5c>)
     7f2:	4798      	blx	r3
	for (int i=0; i<8; i++)
     7f4:	68fb      	ldr	r3, [r7, #12]
     7f6:	3301      	adds	r3, #1
     7f8:	60fb      	str	r3, [r7, #12]
     7fa:	68fb      	ldr	r3, [r7, #12]
     7fc:	2b07      	cmp	r3, #7
     7fe:	ddf2      	ble.n	7e6 <LCD_Create_Custom_createChar+0x36>
}
     800:	46c0      	nop			; (mov r8, r8)
     802:	46bd      	mov	sp, r7
     804:	b004      	add	sp, #16
     806:	bd80      	pop	{r7, pc}
     808:	000006a1 	.word	0x000006a1
     80c:	000006c5 	.word	0x000006c5

00000810 <LCD_setCursor>:
{
     810:	b580      	push	{r7, lr}
     812:	b084      	sub	sp, #16
     814:	af00      	add	r7, sp, #0
     816:	0002      	movs	r2, r0
     818:	1dfb      	adds	r3, r7, #7
     81a:	701a      	strb	r2, [r3, #0]
     81c:	1dbb      	adds	r3, r7, #6
     81e:	1c0a      	adds	r2, r1, #0
     820:	701a      	strb	r2, [r3, #0]
	const size_t max_lines = sizeof(_row_offsets) / sizeof(*_row_offsets);
     822:	2304      	movs	r3, #4
     824:	60fb      	str	r3, [r7, #12]
	if ( row >= max_lines ) 
     826:	1dbb      	adds	r3, r7, #6
     828:	781a      	ldrb	r2, [r3, #0]
     82a:	68fb      	ldr	r3, [r7, #12]
     82c:	429a      	cmp	r2, r3
     82e:	d304      	bcc.n	83a <LCD_setCursor+0x2a>
		row = max_lines - 1; 
     830:	68fb      	ldr	r3, [r7, #12]
     832:	b2da      	uxtb	r2, r3
     834:	1dbb      	adds	r3, r7, #6
     836:	3a01      	subs	r2, #1
     838:	701a      	strb	r2, [r3, #0]
	if ( row >= _numlines )
     83a:	4b10      	ldr	r3, [pc, #64]	; (87c <LCD_setCursor+0x6c>)
     83c:	781b      	ldrb	r3, [r3, #0]
     83e:	1dba      	adds	r2, r7, #6
     840:	7812      	ldrb	r2, [r2, #0]
     842:	429a      	cmp	r2, r3
     844:	d304      	bcc.n	850 <LCD_setCursor+0x40>
		row = _numlines - 1;
     846:	4b0d      	ldr	r3, [pc, #52]	; (87c <LCD_setCursor+0x6c>)
     848:	781a      	ldrb	r2, [r3, #0]
     84a:	1dbb      	adds	r3, r7, #6
     84c:	3a01      	subs	r2, #1
     84e:	701a      	strb	r2, [r3, #0]
	command(LCD_SETDDRAMADDR | (col + _row_offsets[row]));
     850:	1dbb      	adds	r3, r7, #6
     852:	781b      	ldrb	r3, [r3, #0]
     854:	4a0a      	ldr	r2, [pc, #40]	; (880 <LCD_setCursor+0x70>)
     856:	5cd2      	ldrb	r2, [r2, r3]
     858:	1dfb      	adds	r3, r7, #7
     85a:	781b      	ldrb	r3, [r3, #0]
     85c:	18d3      	adds	r3, r2, r3
     85e:	b2db      	uxtb	r3, r3
     860:	b25b      	sxtb	r3, r3
     862:	2280      	movs	r2, #128	; 0x80
     864:	4252      	negs	r2, r2
     866:	4313      	orrs	r3, r2
     868:	b25b      	sxtb	r3, r3
     86a:	b2db      	uxtb	r3, r3
     86c:	0018      	movs	r0, r3
     86e:	4b05      	ldr	r3, [pc, #20]	; (884 <LCD_setCursor+0x74>)
     870:	4798      	blx	r3
}
     872:	46c0      	nop			; (mov r8, r8)
     874:	46bd      	mov	sp, r7
     876:	b004      	add	sp, #16
     878:	bd80      	pop	{r7, pc}
     87a:	46c0      	nop			; (mov r8, r8)
     87c:	2000018a 	.word	0x2000018a
     880:	20000184 	.word	0x20000184
     884:	000006a1 	.word	0x000006a1

00000888 <LCD_display>:
{
     888:	b580      	push	{r7, lr}
     88a:	af00      	add	r7, sp, #0
	_displaycontrol |= LCD_DISPLAYON;
     88c:	4b08      	ldr	r3, [pc, #32]	; (8b0 <LCD_display+0x28>)
     88e:	781b      	ldrb	r3, [r3, #0]
     890:	2204      	movs	r2, #4
     892:	4313      	orrs	r3, r2
     894:	b2da      	uxtb	r2, r3
     896:	4b06      	ldr	r3, [pc, #24]	; (8b0 <LCD_display+0x28>)
     898:	701a      	strb	r2, [r3, #0]
	command(LCD_DISPLAYCONTROL | _displaycontrol);
     89a:	4b05      	ldr	r3, [pc, #20]	; (8b0 <LCD_display+0x28>)
     89c:	781b      	ldrb	r3, [r3, #0]
     89e:	2208      	movs	r2, #8
     8a0:	4313      	orrs	r3, r2
     8a2:	b2db      	uxtb	r3, r3
     8a4:	0018      	movs	r0, r3
     8a6:	4b03      	ldr	r3, [pc, #12]	; (8b4 <LCD_display+0x2c>)
     8a8:	4798      	blx	r3
}
     8aa:	46c0      	nop			; (mov r8, r8)
     8ac:	46bd      	mov	sp, r7
     8ae:	bd80      	pop	{r7, pc}
     8b0:	20000189 	.word	0x20000189
     8b4:	000006a1 	.word	0x000006a1

000008b8 <Buffer_writer>:
{
     8b8:	b580      	push	{r7, lr}
     8ba:	b084      	sub	sp, #16
     8bc:	af00      	add	r7, sp, #0
     8be:	6078      	str	r0, [r7, #4]
	size_t size = strlen(buffer);
     8c0:	687b      	ldr	r3, [r7, #4]
     8c2:	0018      	movs	r0, r3
     8c4:	4b0f      	ldr	r3, [pc, #60]	; (904 <Buffer_writer+0x4c>)
     8c6:	4798      	blx	r3
     8c8:	0003      	movs	r3, r0
     8ca:	60fb      	str	r3, [r7, #12]
	size_t n = 0;
     8cc:	2300      	movs	r3, #0
     8ce:	60bb      	str	r3, [r7, #8]
	while (size--) {
     8d0:	e00b      	b.n	8ea <Buffer_writer+0x32>
		if (LCD_write(*buffer++)) n++;
     8d2:	687b      	ldr	r3, [r7, #4]
     8d4:	1c5a      	adds	r2, r3, #1
     8d6:	607a      	str	r2, [r7, #4]
     8d8:	781b      	ldrb	r3, [r3, #0]
     8da:	0018      	movs	r0, r3
     8dc:	4b0a      	ldr	r3, [pc, #40]	; (908 <Buffer_writer+0x50>)
     8de:	4798      	blx	r3
     8e0:	1e03      	subs	r3, r0, #0
     8e2:	d008      	beq.n	8f6 <Buffer_writer+0x3e>
     8e4:	68bb      	ldr	r3, [r7, #8]
     8e6:	3301      	adds	r3, #1
     8e8:	60bb      	str	r3, [r7, #8]
	while (size--) {
     8ea:	68fb      	ldr	r3, [r7, #12]
     8ec:	1e5a      	subs	r2, r3, #1
     8ee:	60fa      	str	r2, [r7, #12]
     8f0:	2b00      	cmp	r3, #0
     8f2:	d1ee      	bne.n	8d2 <Buffer_writer+0x1a>
     8f4:	e000      	b.n	8f8 <Buffer_writer+0x40>
		else break;
     8f6:	46c0      	nop			; (mov r8, r8)
	return n;
     8f8:	68bb      	ldr	r3, [r7, #8]
}
     8fa:	0018      	movs	r0, r3
     8fc:	46bd      	mov	sp, r7
     8fe:	b004      	add	sp, #16
     900:	bd80      	pop	{r7, pc}
     902:	46c0      	nop			; (mov r8, r8)
     904:	00003f6d 	.word	0x00003f6d
     908:	000006c5 	.word	0x000006c5

0000090c <lcd_printf>:


void lcd_printf(const  char *fmt, ...)
{
     90c:	b40f      	push	{r0, r1, r2, r3}
     90e:	b580      	push	{r7, lr}
     910:	b084      	sub	sp, #16
     912:	af00      	add	r7, sp, #0
	int num_chars;
	char *lcd_buff;
	num_chars = strlen(fmt) + 3;
     914:	69bb      	ldr	r3, [r7, #24]
     916:	0018      	movs	r0, r3
     918:	4b11      	ldr	r3, [pc, #68]	; (960 <lcd_printf+0x54>)
     91a:	4798      	blx	r3
     91c:	0003      	movs	r3, r0
     91e:	3303      	adds	r3, #3
     920:	60fb      	str	r3, [r7, #12]
	lcd_buff = (char *)malloc(sizeof(char) * num_chars);
     922:	68fb      	ldr	r3, [r7, #12]
     924:	0018      	movs	r0, r3
     926:	4b0f      	ldr	r3, [pc, #60]	; (964 <lcd_printf+0x58>)
     928:	4798      	blx	r3
     92a:	0003      	movs	r3, r0
     92c:	60bb      	str	r3, [r7, #8]
	va_list args;
	va_start(args, fmt);
     92e:	231c      	movs	r3, #28
     930:	18fb      	adds	r3, r7, r3
     932:	607b      	str	r3, [r7, #4]
	vsprintf(lcd_buff,fmt,args);
     934:	687a      	ldr	r2, [r7, #4]
     936:	69b9      	ldr	r1, [r7, #24]
     938:	68bb      	ldr	r3, [r7, #8]
     93a:	0018      	movs	r0, r3
     93c:	4b0a      	ldr	r3, [pc, #40]	; (968 <lcd_printf+0x5c>)
     93e:	4798      	blx	r3
	Buffer_writer(lcd_buff);
     940:	68bb      	ldr	r3, [r7, #8]
     942:	0018      	movs	r0, r3
     944:	4b09      	ldr	r3, [pc, #36]	; (96c <lcd_printf+0x60>)
     946:	4798      	blx	r3
	va_end(args);
	free(lcd_buff);
     948:	68bb      	ldr	r3, [r7, #8]
     94a:	0018      	movs	r0, r3
     94c:	4b08      	ldr	r3, [pc, #32]	; (970 <lcd_printf+0x64>)
     94e:	4798      	blx	r3
}
     950:	46c0      	nop			; (mov r8, r8)
     952:	46bd      	mov	sp, r7
     954:	b004      	add	sp, #16
     956:	bc80      	pop	{r7}
     958:	bc08      	pop	{r3}
     95a:	b004      	add	sp, #16
     95c:	4718      	bx	r3
     95e:	46c0      	nop			; (mov r8, r8)
     960:	00003f6d 	.word	0x00003f6d
     964:	00003dad 	.word	0x00003dad
     968:	00003fad 	.word	0x00003fad
     96c:	000008b9 	.word	0x000008b9
     970:	00003dc1 	.word	0x00003dc1

00000974 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
     974:	b580      	push	{r7, lr}
     976:	b082      	sub	sp, #8
     978:	af00      	add	r7, sp, #0
     97a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
     97c:	687b      	ldr	r3, [r7, #4]
     97e:	2200      	movs	r2, #0
     980:	701a      	strb	r2, [r3, #0]
}
     982:	46c0      	nop			; (mov r8, r8)
     984:	46bd      	mov	sp, r7
     986:	b002      	add	sp, #8
     988:	bd80      	pop	{r7, pc}
	...

0000098c <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
     98c:	b580      	push	{r7, lr}
     98e:	b082      	sub	sp, #8
     990:	af00      	add	r7, sp, #0
     992:	0002      	movs	r2, r0
     994:	6039      	str	r1, [r7, #0]
     996:	1dfb      	adds	r3, r7, #7
     998:	701a      	strb	r2, [r3, #0]
	switch (bus) {
     99a:	1dfb      	adds	r3, r7, #7
     99c:	781b      	ldrb	r3, [r3, #0]
     99e:	2b01      	cmp	r3, #1
     9a0:	d00a      	beq.n	9b8 <system_apb_clock_set_mask+0x2c>
     9a2:	2b02      	cmp	r3, #2
     9a4:	d00f      	beq.n	9c6 <system_apb_clock_set_mask+0x3a>
     9a6:	2b00      	cmp	r3, #0
     9a8:	d114      	bne.n	9d4 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
     9aa:	4b0e      	ldr	r3, [pc, #56]	; (9e4 <system_apb_clock_set_mask+0x58>)
     9ac:	4a0d      	ldr	r2, [pc, #52]	; (9e4 <system_apb_clock_set_mask+0x58>)
     9ae:	6991      	ldr	r1, [r2, #24]
     9b0:	683a      	ldr	r2, [r7, #0]
     9b2:	430a      	orrs	r2, r1
     9b4:	619a      	str	r2, [r3, #24]
			break;
     9b6:	e00f      	b.n	9d8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
     9b8:	4b0a      	ldr	r3, [pc, #40]	; (9e4 <system_apb_clock_set_mask+0x58>)
     9ba:	4a0a      	ldr	r2, [pc, #40]	; (9e4 <system_apb_clock_set_mask+0x58>)
     9bc:	69d1      	ldr	r1, [r2, #28]
     9be:	683a      	ldr	r2, [r7, #0]
     9c0:	430a      	orrs	r2, r1
     9c2:	61da      	str	r2, [r3, #28]
			break;
     9c4:	e008      	b.n	9d8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
     9c6:	4b07      	ldr	r3, [pc, #28]	; (9e4 <system_apb_clock_set_mask+0x58>)
     9c8:	4a06      	ldr	r2, [pc, #24]	; (9e4 <system_apb_clock_set_mask+0x58>)
     9ca:	6a11      	ldr	r1, [r2, #32]
     9cc:	683a      	ldr	r2, [r7, #0]
     9ce:	430a      	orrs	r2, r1
     9d0:	621a      	str	r2, [r3, #32]
			break;
     9d2:	e001      	b.n	9d8 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
     9d4:	2317      	movs	r3, #23
     9d6:	e000      	b.n	9da <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
     9d8:	2300      	movs	r3, #0
}
     9da:	0018      	movs	r0, r3
     9dc:	46bd      	mov	sp, r7
     9de:	b002      	add	sp, #8
     9e0:	bd80      	pop	{r7, pc}
     9e2:	46c0      	nop			; (mov r8, r8)
     9e4:	40000400 	.word	0x40000400

000009e8 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
     9e8:	b580      	push	{r7, lr}
     9ea:	b082      	sub	sp, #8
     9ec:	af00      	add	r7, sp, #0
     9ee:	0002      	movs	r2, r0
     9f0:	1dfb      	adds	r3, r7, #7
     9f2:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
     9f4:	4b06      	ldr	r3, [pc, #24]	; (a10 <system_interrupt_enable+0x28>)
     9f6:	1dfa      	adds	r2, r7, #7
     9f8:	7812      	ldrb	r2, [r2, #0]
     9fa:	0011      	movs	r1, r2
     9fc:	221f      	movs	r2, #31
     9fe:	400a      	ands	r2, r1
     a00:	2101      	movs	r1, #1
     a02:	4091      	lsls	r1, r2
     a04:	000a      	movs	r2, r1
     a06:	601a      	str	r2, [r3, #0]
}
     a08:	46c0      	nop			; (mov r8, r8)
     a0a:	46bd      	mov	sp, r7
     a0c:	b002      	add	sp, #8
     a0e:	bd80      	pop	{r7, pc}
     a10:	e000e100 	.word	0xe000e100

00000a14 <extint_is_syncing>:
 *
 * \retval true  If the module synchronization is ongoing
 * \retval false If the module has completed synchronization
 */
static inline bool extint_is_syncing(void)
{
     a14:	b580      	push	{r7, lr}
     a16:	b082      	sub	sp, #8
     a18:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
     a1a:	4b0f      	ldr	r3, [pc, #60]	; (a58 <extint_is_syncing+0x44>)
     a1c:	603b      	str	r3, [r7, #0]

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
     a1e:	2300      	movs	r3, #0
     a20:	607b      	str	r3, [r7, #4]
     a22:	e011      	b.n	a48 <extint_is_syncing+0x34>
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
     a24:	687b      	ldr	r3, [r7, #4]
     a26:	009b      	lsls	r3, r3, #2
     a28:	2208      	movs	r2, #8
     a2a:	4694      	mov	ip, r2
     a2c:	44bc      	add	ip, r7
     a2e:	4463      	add	r3, ip
     a30:	3b08      	subs	r3, #8
     a32:	681b      	ldr	r3, [r3, #0]
     a34:	785b      	ldrb	r3, [r3, #1]
     a36:	b2db      	uxtb	r3, r3
     a38:	b25b      	sxtb	r3, r3
     a3a:	2b00      	cmp	r3, #0
     a3c:	da01      	bge.n	a42 <extint_is_syncing+0x2e>
			return true;
     a3e:	2301      	movs	r3, #1
     a40:	e006      	b.n	a50 <extint_is_syncing+0x3c>
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
     a42:	687b      	ldr	r3, [r7, #4]
     a44:	3301      	adds	r3, #1
     a46:	607b      	str	r3, [r7, #4]
     a48:	687b      	ldr	r3, [r7, #4]
     a4a:	2b00      	cmp	r3, #0
     a4c:	d0ea      	beq.n	a24 <extint_is_syncing+0x10>
		}
	}
	return false;
     a4e:	2300      	movs	r3, #0
}
     a50:	0018      	movs	r0, r3
     a52:	46bd      	mov	sp, r7
     a54:	b002      	add	sp, #8
     a56:	bd80      	pop	{r7, pc}
     a58:	40001800 	.word	0x40001800

00000a5c <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
     a5c:	b580      	push	{r7, lr}
     a5e:	b084      	sub	sp, #16
     a60:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
     a62:	4b2d      	ldr	r3, [pc, #180]	; (b18 <_system_extint_init+0xbc>)
     a64:	607b      	str	r3, [r7, #4]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_EIC);
     a66:	2140      	movs	r1, #64	; 0x40
     a68:	2000      	movs	r0, #0
     a6a:	4b2c      	ldr	r3, [pc, #176]	; (b1c <_system_extint_init+0xc0>)
     a6c:	4798      	blx	r3

	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
     a6e:	003b      	movs	r3, r7
     a70:	0018      	movs	r0, r3
     a72:	4b2b      	ldr	r3, [pc, #172]	; (b20 <_system_extint_init+0xc4>)
     a74:	4798      	blx	r3
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
     a76:	003b      	movs	r3, r7
     a78:	2206      	movs	r2, #6
     a7a:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
     a7c:	003b      	movs	r3, r7
     a7e:	0019      	movs	r1, r3
     a80:	2005      	movs	r0, #5
     a82:	4b28      	ldr	r3, [pc, #160]	; (b24 <_system_extint_init+0xc8>)
     a84:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
     a86:	2005      	movs	r0, #5
     a88:	4b27      	ldr	r3, [pc, #156]	; (b28 <_system_extint_init+0xcc>)
     a8a:	4798      	blx	r3

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
     a8c:	2300      	movs	r3, #0
     a8e:	60fb      	str	r3, [r7, #12]
     a90:	e018      	b.n	ac4 <_system_extint_init+0x68>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
     a92:	68fb      	ldr	r3, [r7, #12]
     a94:	009b      	lsls	r3, r3, #2
     a96:	2210      	movs	r2, #16
     a98:	4694      	mov	ip, r2
     a9a:	44bc      	add	ip, r7
     a9c:	4463      	add	r3, ip
     a9e:	3b0c      	subs	r3, #12
     aa0:	681a      	ldr	r2, [r3, #0]
     aa2:	68fb      	ldr	r3, [r7, #12]
     aa4:	009b      	lsls	r3, r3, #2
     aa6:	2110      	movs	r1, #16
     aa8:	468c      	mov	ip, r1
     aaa:	44bc      	add	ip, r7
     aac:	4463      	add	r3, ip
     aae:	3b0c      	subs	r3, #12
     ab0:	681b      	ldr	r3, [r3, #0]
     ab2:	781b      	ldrb	r3, [r3, #0]
     ab4:	b2db      	uxtb	r3, r3
     ab6:	2101      	movs	r1, #1
     ab8:	430b      	orrs	r3, r1
     aba:	b2db      	uxtb	r3, r3
     abc:	7013      	strb	r3, [r2, #0]
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
     abe:	68fb      	ldr	r3, [r7, #12]
     ac0:	3301      	adds	r3, #1
     ac2:	60fb      	str	r3, [r7, #12]
     ac4:	68fb      	ldr	r3, [r7, #12]
     ac6:	2b00      	cmp	r3, #0
     ac8:	d0e3      	beq.n	a92 <_system_extint_init+0x36>
	}

	while (extint_is_syncing()) {
     aca:	46c0      	nop			; (mov r8, r8)
     acc:	4b17      	ldr	r3, [pc, #92]	; (b2c <_system_extint_init+0xd0>)
     ace:	4798      	blx	r3
     ad0:	1e03      	subs	r3, r0, #0
     ad2:	d1fb      	bne.n	acc <_system_extint_init+0x70>
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
     ad4:	230b      	movs	r3, #11
     ad6:	18fb      	adds	r3, r7, r3
     ad8:	2200      	movs	r2, #0
     ada:	701a      	strb	r2, [r3, #0]
     adc:	e00d      	b.n	afa <_system_extint_init+0x9e>
		_extint_dev.callbacks[j] = NULL;
     ade:	230b      	movs	r3, #11
     ae0:	18fb      	adds	r3, r7, r3
     ae2:	781a      	ldrb	r2, [r3, #0]
     ae4:	4b12      	ldr	r3, [pc, #72]	; (b30 <_system_extint_init+0xd4>)
     ae6:	0092      	lsls	r2, r2, #2
     ae8:	2100      	movs	r1, #0
     aea:	50d1      	str	r1, [r2, r3]
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
     aec:	230b      	movs	r3, #11
     aee:	18fb      	adds	r3, r7, r3
     af0:	781a      	ldrb	r2, [r3, #0]
     af2:	230b      	movs	r3, #11
     af4:	18fb      	adds	r3, r7, r3
     af6:	3201      	adds	r2, #1
     af8:	701a      	strb	r2, [r3, #0]
     afa:	230b      	movs	r3, #11
     afc:	18fb      	adds	r3, r7, r3
     afe:	781b      	ldrb	r3, [r3, #0]
     b00:	2b0f      	cmp	r3, #15
     b02:	d9ec      	bls.n	ade <_system_extint_init+0x82>
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
     b04:	2004      	movs	r0, #4
     b06:	4b0b      	ldr	r3, [pc, #44]	; (b34 <_system_extint_init+0xd8>)
     b08:	4798      	blx	r3
#endif

	/* Enables the driver for further use */
	_extint_enable();
     b0a:	4b0b      	ldr	r3, [pc, #44]	; (b38 <_system_extint_init+0xdc>)
     b0c:	4798      	blx	r3
}
     b0e:	46c0      	nop			; (mov r8, r8)
     b10:	46bd      	mov	sp, r7
     b12:	b004      	add	sp, #16
     b14:	bd80      	pop	{r7, pc}
     b16:	46c0      	nop			; (mov r8, r8)
     b18:	40001800 	.word	0x40001800
     b1c:	0000098d 	.word	0x0000098d
     b20:	00000975 	.word	0x00000975
     b24:	00002d29 	.word	0x00002d29
     b28:	00002d6d 	.word	0x00002d6d
     b2c:	00000a15 	.word	0x00000a15
     b30:	20000198 	.word	0x20000198
     b34:	000009e9 	.word	0x000009e9
     b38:	00000b3d 	.word	0x00000b3d

00000b3c <_extint_enable>:
 *
 * Enables EIC modules.
 * Registered callback list will not be affected if callback mode is used.
 */
void _extint_enable(void)
{
     b3c:	b580      	push	{r7, lr}
     b3e:	b082      	sub	sp, #8
     b40:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
     b42:	4b15      	ldr	r3, [pc, #84]	; (b98 <_extint_enable+0x5c>)
     b44:	603b      	str	r3, [r7, #0]

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
     b46:	2300      	movs	r3, #0
     b48:	607b      	str	r3, [r7, #4]
     b4a:	e018      	b.n	b7e <_extint_enable+0x42>
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
     b4c:	687b      	ldr	r3, [r7, #4]
     b4e:	009b      	lsls	r3, r3, #2
     b50:	2208      	movs	r2, #8
     b52:	4694      	mov	ip, r2
     b54:	44bc      	add	ip, r7
     b56:	4463      	add	r3, ip
     b58:	3b08      	subs	r3, #8
     b5a:	681a      	ldr	r2, [r3, #0]
     b5c:	687b      	ldr	r3, [r7, #4]
     b5e:	009b      	lsls	r3, r3, #2
     b60:	2108      	movs	r1, #8
     b62:	468c      	mov	ip, r1
     b64:	44bc      	add	ip, r7
     b66:	4463      	add	r3, ip
     b68:	3b08      	subs	r3, #8
     b6a:	681b      	ldr	r3, [r3, #0]
     b6c:	781b      	ldrb	r3, [r3, #0]
     b6e:	b2db      	uxtb	r3, r3
     b70:	2102      	movs	r1, #2
     b72:	430b      	orrs	r3, r1
     b74:	b2db      	uxtb	r3, r3
     b76:	7013      	strb	r3, [r2, #0]
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
     b78:	687b      	ldr	r3, [r7, #4]
     b7a:	3301      	adds	r3, #1
     b7c:	607b      	str	r3, [r7, #4]
     b7e:	687b      	ldr	r3, [r7, #4]
     b80:	2b00      	cmp	r3, #0
     b82:	d0e3      	beq.n	b4c <_extint_enable+0x10>
	}

	while (extint_is_syncing()) {
     b84:	46c0      	nop			; (mov r8, r8)
     b86:	4b05      	ldr	r3, [pc, #20]	; (b9c <_extint_enable+0x60>)
     b88:	4798      	blx	r3
     b8a:	1e03      	subs	r3, r0, #0
     b8c:	d1fb      	bne.n	b86 <_extint_enable+0x4a>
		/* Wait for all hardware modules to complete synchronization */
	}
}
     b8e:	46c0      	nop			; (mov r8, r8)
     b90:	46bd      	mov	sp, r7
     b92:	b002      	add	sp, #8
     b94:	bd80      	pop	{r7, pc}
     b96:	46c0      	nop			; (mov r8, r8)
     b98:	40001800 	.word	0x40001800
     b9c:	00000a15 	.word	0x00000a15

00000ba0 <SVC_Handler>:
	}
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
     ba0:	b580      	push	{r7, lr}
     ba2:	af00      	add	r7, sp, #0
	/* This function is no longer used, but retained for backward
	compatibility. */
}
     ba4:	46c0      	nop			; (mov r8, r8)
     ba6:	46bd      	mov	sp, r7
     ba8:	bd80      	pop	{r7, pc}

00000baa <ulSetInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
     baa:	f3ef 8010 	mrs	r0, PRIMASK
     bae:	b672      	cpsid	i
     bb0:	4770      	bx	lr
	/* To avoid compiler warnings.  The return statement will nevere be reached,
	but some compilers warn if it is not included, while others won't compile if
	it is. */
	return 0;
#endif
}
     bb2:	46c0      	nop			; (mov r8, r8)
     bb4:	0018      	movs	r0, r3

00000bb6 <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
	__asm volatile(
     bb6:	f380 8810 	msr	PRIMASK, r0
     bba:	4770      	bx	lr
	/* Just to avoid compiler warning.  ulMask is used from the asm code but
	the compiler can't see that.  Some compilers generate warnings without the
	following line, while others generate warnings if the line is included. */
	( void ) ulMask;
#endif
}
     bbc:	46c0      	nop			; (mov r8, r8)
	...

00000bc0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
     bc0:	f3ef 8009 	mrs	r0, PSP
     bc4:	4b0e      	ldr	r3, [pc, #56]	; (c00 <pxCurrentTCBConst>)
     bc6:	681a      	ldr	r2, [r3, #0]
     bc8:	3820      	subs	r0, #32
     bca:	6010      	str	r0, [r2, #0]
     bcc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     bce:	4644      	mov	r4, r8
     bd0:	464d      	mov	r5, r9
     bd2:	4656      	mov	r6, sl
     bd4:	465f      	mov	r7, fp
     bd6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     bd8:	b508      	push	{r3, lr}
     bda:	b672      	cpsid	i
     bdc:	f000 f938 	bl	e50 <vTaskSwitchContext>
     be0:	b662      	cpsie	i
     be2:	bc0c      	pop	{r2, r3}
     be4:	6811      	ldr	r1, [r2, #0]
     be6:	6808      	ldr	r0, [r1, #0]
     be8:	3010      	adds	r0, #16
     bea:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     bec:	46a0      	mov	r8, r4
     bee:	46a9      	mov	r9, r5
     bf0:	46b2      	mov	sl, r6
     bf2:	46bb      	mov	fp, r7
     bf4:	f380 8809 	msr	PSP, r0
     bf8:	3820      	subs	r0, #32
     bfa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     bfc:	4718      	bx	r3
     bfe:	46c0      	nop			; (mov r8, r8)

00000c00 <pxCurrentTCBConst>:
     c00:	20000090 	.word	0x20000090
	"	bx r3								\n"
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	  "
	);
}
     c04:	46c0      	nop			; (mov r8, r8)
     c06:	46c0      	nop			; (mov r8, r8)

00000c08 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
     c08:	b580      	push	{r7, lr}
     c0a:	b082      	sub	sp, #8
     c0c:	af00      	add	r7, sp, #0
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     c0e:	4b0a      	ldr	r3, [pc, #40]	; (c38 <SysTick_Handler+0x30>)
     c10:	4798      	blx	r3
     c12:	0003      	movs	r3, r0
     c14:	607b      	str	r3, [r7, #4]
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
     c16:	4b09      	ldr	r3, [pc, #36]	; (c3c <SysTick_Handler+0x34>)
     c18:	4798      	blx	r3
     c1a:	1e03      	subs	r3, r0, #0
     c1c:	d003      	beq.n	c26 <SysTick_Handler+0x1e>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     c1e:	4b08      	ldr	r3, [pc, #32]	; (c40 <SysTick_Handler+0x38>)
     c20:	2280      	movs	r2, #128	; 0x80
     c22:	0552      	lsls	r2, r2, #21
     c24:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     c26:	687b      	ldr	r3, [r7, #4]
     c28:	0018      	movs	r0, r3
     c2a:	4b06      	ldr	r3, [pc, #24]	; (c44 <SysTick_Handler+0x3c>)
     c2c:	4798      	blx	r3
}
     c2e:	46c0      	nop			; (mov r8, r8)
     c30:	46bd      	mov	sp, r7
     c32:	b002      	add	sp, #8
     c34:	bd80      	pop	{r7, pc}
     c36:	46c0      	nop			; (mov r8, r8)
     c38:	00000bab 	.word	0x00000bab
     c3c:	00000cdd 	.word	0x00000cdd
     c40:	e000ed04 	.word	0xe000ed04
     c44:	00000bb7 	.word	0x00000bb7

00000c48 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c48:	b580      	push	{r7, lr}
     c4a:	b084      	sub	sp, #16
     c4c:	af00      	add	r7, sp, #0
     c4e:	6078      	str	r0, [r7, #4]
     c50:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
     c52:	687b      	ldr	r3, [r7, #4]
     c54:	685b      	ldr	r3, [r3, #4]
     c56:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     c58:	683b      	ldr	r3, [r7, #0]
     c5a:	68fa      	ldr	r2, [r7, #12]
     c5c:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     c5e:	68fb      	ldr	r3, [r7, #12]
     c60:	689a      	ldr	r2, [r3, #8]
     c62:	683b      	ldr	r3, [r7, #0]
     c64:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c66:	68fb      	ldr	r3, [r7, #12]
     c68:	689b      	ldr	r3, [r3, #8]
     c6a:	683a      	ldr	r2, [r7, #0]
     c6c:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
     c6e:	68fb      	ldr	r3, [r7, #12]
     c70:	683a      	ldr	r2, [r7, #0]
     c72:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c74:	683b      	ldr	r3, [r7, #0]
     c76:	687a      	ldr	r2, [r7, #4]
     c78:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
     c7a:	687b      	ldr	r3, [r7, #4]
     c7c:	681b      	ldr	r3, [r3, #0]
     c7e:	1c5a      	adds	r2, r3, #1
     c80:	687b      	ldr	r3, [r7, #4]
     c82:	601a      	str	r2, [r3, #0]
}
     c84:	46c0      	nop			; (mov r8, r8)
     c86:	46bd      	mov	sp, r7
     c88:	b004      	add	sp, #16
     c8a:	bd80      	pop	{r7, pc}

00000c8c <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     c8c:	b580      	push	{r7, lr}
     c8e:	b084      	sub	sp, #16
     c90:	af00      	add	r7, sp, #0
     c92:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     c94:	687b      	ldr	r3, [r7, #4]
     c96:	691b      	ldr	r3, [r3, #16]
     c98:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     c9a:	687b      	ldr	r3, [r7, #4]
     c9c:	685b      	ldr	r3, [r3, #4]
     c9e:	687a      	ldr	r2, [r7, #4]
     ca0:	6892      	ldr	r2, [r2, #8]
     ca2:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ca4:	687b      	ldr	r3, [r7, #4]
     ca6:	689b      	ldr	r3, [r3, #8]
     ca8:	687a      	ldr	r2, [r7, #4]
     caa:	6852      	ldr	r2, [r2, #4]
     cac:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     cae:	68fb      	ldr	r3, [r7, #12]
     cb0:	685a      	ldr	r2, [r3, #4]
     cb2:	687b      	ldr	r3, [r7, #4]
     cb4:	429a      	cmp	r2, r3
     cb6:	d103      	bne.n	cc0 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     cb8:	687b      	ldr	r3, [r7, #4]
     cba:	689a      	ldr	r2, [r3, #8]
     cbc:	68fb      	ldr	r3, [r7, #12]
     cbe:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     cc0:	687b      	ldr	r3, [r7, #4]
     cc2:	2200      	movs	r2, #0
     cc4:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
     cc6:	68fb      	ldr	r3, [r7, #12]
     cc8:	681b      	ldr	r3, [r3, #0]
     cca:	1e5a      	subs	r2, r3, #1
     ccc:	68fb      	ldr	r3, [r7, #12]
     cce:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     cd0:	68fb      	ldr	r3, [r7, #12]
     cd2:	681b      	ldr	r3, [r3, #0]
}
     cd4:	0018      	movs	r0, r3
     cd6:	46bd      	mov	sp, r7
     cd8:	b004      	add	sp, #16
     cda:	bd80      	pop	{r7, pc}

00000cdc <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     cdc:	b580      	push	{r7, lr}
     cde:	b086      	sub	sp, #24
     ce0:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     ce2:	2300      	movs	r3, #0
     ce4:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ce6:	4b4c      	ldr	r3, [pc, #304]	; (e18 <xTaskIncrementTick+0x13c>)
     ce8:	681b      	ldr	r3, [r3, #0]
     cea:	2b00      	cmp	r3, #0
     cec:	d000      	beq.n	cf0 <xTaskIncrementTick+0x14>
     cee:	e083      	b.n	df8 <xTaskIncrementTick+0x11c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     cf0:	4b4a      	ldr	r3, [pc, #296]	; (e1c <xTaskIncrementTick+0x140>)
     cf2:	681b      	ldr	r3, [r3, #0]
     cf4:	3301      	adds	r3, #1
     cf6:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     cf8:	4b48      	ldr	r3, [pc, #288]	; (e1c <xTaskIncrementTick+0x140>)
     cfa:	693a      	ldr	r2, [r7, #16]
     cfc:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     cfe:	693b      	ldr	r3, [r7, #16]
     d00:	2b00      	cmp	r3, #0
     d02:	d117      	bne.n	d34 <xTaskIncrementTick+0x58>
		{
			taskSWITCH_DELAYED_LISTS();
     d04:	4b46      	ldr	r3, [pc, #280]	; (e20 <xTaskIncrementTick+0x144>)
     d06:	681b      	ldr	r3, [r3, #0]
     d08:	681b      	ldr	r3, [r3, #0]
     d0a:	2b00      	cmp	r3, #0
     d0c:	d001      	beq.n	d12 <xTaskIncrementTick+0x36>
     d0e:	b672      	cpsid	i
     d10:	e7fe      	b.n	d10 <xTaskIncrementTick+0x34>
     d12:	4b43      	ldr	r3, [pc, #268]	; (e20 <xTaskIncrementTick+0x144>)
     d14:	681b      	ldr	r3, [r3, #0]
     d16:	60fb      	str	r3, [r7, #12]
     d18:	4b42      	ldr	r3, [pc, #264]	; (e24 <xTaskIncrementTick+0x148>)
     d1a:	681a      	ldr	r2, [r3, #0]
     d1c:	4b40      	ldr	r3, [pc, #256]	; (e20 <xTaskIncrementTick+0x144>)
     d1e:	601a      	str	r2, [r3, #0]
     d20:	4b40      	ldr	r3, [pc, #256]	; (e24 <xTaskIncrementTick+0x148>)
     d22:	68fa      	ldr	r2, [r7, #12]
     d24:	601a      	str	r2, [r3, #0]
     d26:	4b40      	ldr	r3, [pc, #256]	; (e28 <xTaskIncrementTick+0x14c>)
     d28:	681b      	ldr	r3, [r3, #0]
     d2a:	1c5a      	adds	r2, r3, #1
     d2c:	4b3e      	ldr	r3, [pc, #248]	; (e28 <xTaskIncrementTick+0x14c>)
     d2e:	601a      	str	r2, [r3, #0]
     d30:	4b3e      	ldr	r3, [pc, #248]	; (e2c <xTaskIncrementTick+0x150>)
     d32:	4798      	blx	r3

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     d34:	4b3e      	ldr	r3, [pc, #248]	; (e30 <xTaskIncrementTick+0x154>)
     d36:	681b      	ldr	r3, [r3, #0]
     d38:	693a      	ldr	r2, [r7, #16]
     d3a:	429a      	cmp	r2, r3
     d3c:	d34e      	bcc.n	ddc <xTaskIncrementTick+0x100>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d3e:	4b38      	ldr	r3, [pc, #224]	; (e20 <xTaskIncrementTick+0x144>)
     d40:	681b      	ldr	r3, [r3, #0]
     d42:	681b      	ldr	r3, [r3, #0]
     d44:	2b00      	cmp	r3, #0
     d46:	d101      	bne.n	d4c <xTaskIncrementTick+0x70>
     d48:	2301      	movs	r3, #1
     d4a:	e000      	b.n	d4e <xTaskIncrementTick+0x72>
     d4c:	2300      	movs	r3, #0
     d4e:	2b00      	cmp	r3, #0
     d50:	d004      	beq.n	d5c <xTaskIncrementTick+0x80>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d52:	4b37      	ldr	r3, [pc, #220]	; (e30 <xTaskIncrementTick+0x154>)
     d54:	2201      	movs	r2, #1
     d56:	4252      	negs	r2, r2
     d58:	601a      	str	r2, [r3, #0]
					break;
     d5a:	e03f      	b.n	ddc <xTaskIncrementTick+0x100>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d5c:	4b30      	ldr	r3, [pc, #192]	; (e20 <xTaskIncrementTick+0x144>)
     d5e:	681b      	ldr	r3, [r3, #0]
     d60:	68db      	ldr	r3, [r3, #12]
     d62:	68db      	ldr	r3, [r3, #12]
     d64:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     d66:	68bb      	ldr	r3, [r7, #8]
     d68:	685b      	ldr	r3, [r3, #4]
     d6a:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
     d6c:	693a      	ldr	r2, [r7, #16]
     d6e:	687b      	ldr	r3, [r7, #4]
     d70:	429a      	cmp	r2, r3
     d72:	d203      	bcs.n	d7c <xTaskIncrementTick+0xa0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     d74:	4b2e      	ldr	r3, [pc, #184]	; (e30 <xTaskIncrementTick+0x154>)
     d76:	687a      	ldr	r2, [r7, #4]
     d78:	601a      	str	r2, [r3, #0]
						break;
     d7a:	e02f      	b.n	ddc <xTaskIncrementTick+0x100>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     d7c:	68bb      	ldr	r3, [r7, #8]
     d7e:	3304      	adds	r3, #4
     d80:	0018      	movs	r0, r3
     d82:	4b2c      	ldr	r3, [pc, #176]	; (e34 <xTaskIncrementTick+0x158>)
     d84:	4798      	blx	r3

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     d86:	68bb      	ldr	r3, [r7, #8]
     d88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     d8a:	2b00      	cmp	r3, #0
     d8c:	d004      	beq.n	d98 <xTaskIncrementTick+0xbc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     d8e:	68bb      	ldr	r3, [r7, #8]
     d90:	3318      	adds	r3, #24
     d92:	0018      	movs	r0, r3
     d94:	4b27      	ldr	r3, [pc, #156]	; (e34 <xTaskIncrementTick+0x158>)
     d96:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     d98:	68bb      	ldr	r3, [r7, #8]
     d9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     d9c:	4b26      	ldr	r3, [pc, #152]	; (e38 <xTaskIncrementTick+0x15c>)
     d9e:	681b      	ldr	r3, [r3, #0]
     da0:	429a      	cmp	r2, r3
     da2:	d903      	bls.n	dac <xTaskIncrementTick+0xd0>
     da4:	68bb      	ldr	r3, [r7, #8]
     da6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     da8:	4b23      	ldr	r3, [pc, #140]	; (e38 <xTaskIncrementTick+0x15c>)
     daa:	601a      	str	r2, [r3, #0]
     dac:	68bb      	ldr	r3, [r7, #8]
     dae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     db0:	0013      	movs	r3, r2
     db2:	009b      	lsls	r3, r3, #2
     db4:	189b      	adds	r3, r3, r2
     db6:	009b      	lsls	r3, r3, #2
     db8:	4a20      	ldr	r2, [pc, #128]	; (e3c <xTaskIncrementTick+0x160>)
     dba:	189a      	adds	r2, r3, r2
     dbc:	68bb      	ldr	r3, [r7, #8]
     dbe:	3304      	adds	r3, #4
     dc0:	0019      	movs	r1, r3
     dc2:	0010      	movs	r0, r2
     dc4:	4b1e      	ldr	r3, [pc, #120]	; (e40 <xTaskIncrementTick+0x164>)
     dc6:	4798      	blx	r3
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     dc8:	68bb      	ldr	r3, [r7, #8]
     dca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     dcc:	4b1d      	ldr	r3, [pc, #116]	; (e44 <xTaskIncrementTick+0x168>)
     dce:	681b      	ldr	r3, [r3, #0]
     dd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     dd2:	429a      	cmp	r2, r3
     dd4:	d3b3      	bcc.n	d3e <xTaskIncrementTick+0x62>
						{
							xSwitchRequired = pdTRUE;
     dd6:	2301      	movs	r3, #1
     dd8:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     dda:	e7b0      	b.n	d3e <xTaskIncrementTick+0x62>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     ddc:	4b19      	ldr	r3, [pc, #100]	; (e44 <xTaskIncrementTick+0x168>)
     dde:	681b      	ldr	r3, [r3, #0]
     de0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     de2:	4916      	ldr	r1, [pc, #88]	; (e3c <xTaskIncrementTick+0x160>)
     de4:	0013      	movs	r3, r2
     de6:	009b      	lsls	r3, r3, #2
     de8:	189b      	adds	r3, r3, r2
     dea:	009b      	lsls	r3, r3, #2
     dec:	585b      	ldr	r3, [r3, r1]
     dee:	2b01      	cmp	r3, #1
     df0:	d907      	bls.n	e02 <xTaskIncrementTick+0x126>
			{
				xSwitchRequired = pdTRUE;
     df2:	2301      	movs	r3, #1
     df4:	617b      	str	r3, [r7, #20]
     df6:	e004      	b.n	e02 <xTaskIncrementTick+0x126>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     df8:	4b13      	ldr	r3, [pc, #76]	; (e48 <xTaskIncrementTick+0x16c>)
     dfa:	681b      	ldr	r3, [r3, #0]
     dfc:	1c5a      	adds	r2, r3, #1
     dfe:	4b12      	ldr	r3, [pc, #72]	; (e48 <xTaskIncrementTick+0x16c>)
     e00:	601a      	str	r2, [r3, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     e02:	4b12      	ldr	r3, [pc, #72]	; (e4c <xTaskIncrementTick+0x170>)
     e04:	681b      	ldr	r3, [r3, #0]
     e06:	2b00      	cmp	r3, #0
     e08:	d001      	beq.n	e0e <xTaskIncrementTick+0x132>
		{
			xSwitchRequired = pdTRUE;
     e0a:	2301      	movs	r3, #1
     e0c:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
     e0e:	697b      	ldr	r3, [r7, #20]
}
     e10:	0018      	movs	r0, r3
     e12:	46bd      	mov	sp, r7
     e14:	b006      	add	sp, #24
     e16:	bd80      	pop	{r7, pc}
     e18:	20000118 	.word	0x20000118
     e1c:	20000100 	.word	0x20000100
     e20:	200000f8 	.word	0x200000f8
     e24:	200000fc 	.word	0x200000fc
     e28:	20000110 	.word	0x20000110
     e2c:	00000ef5 	.word	0x00000ef5
     e30:	20000114 	.word	0x20000114
     e34:	00000c8d 	.word	0x00000c8d
     e38:	20000104 	.word	0x20000104
     e3c:	20000094 	.word	0x20000094
     e40:	00000c49 	.word	0x00000c49
     e44:	20000090 	.word	0x20000090
     e48:	20000108 	.word	0x20000108
     e4c:	2000010c 	.word	0x2000010c

00000e50 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
     e50:	b580      	push	{r7, lr}
     e52:	b082      	sub	sp, #8
     e54:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     e56:	4b22      	ldr	r3, [pc, #136]	; (ee0 <vTaskSwitchContext+0x90>)
     e58:	681b      	ldr	r3, [r3, #0]
     e5a:	2b00      	cmp	r3, #0
     e5c:	d003      	beq.n	e66 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e5e:	4b21      	ldr	r3, [pc, #132]	; (ee4 <vTaskSwitchContext+0x94>)
     e60:	2201      	movs	r2, #1
     e62:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
     e64:	e037      	b.n	ed6 <vTaskSwitchContext+0x86>
		xYieldPending = pdFALSE;
     e66:	4b1f      	ldr	r3, [pc, #124]	; (ee4 <vTaskSwitchContext+0x94>)
     e68:	2200      	movs	r2, #0
     e6a:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
     e6c:	4b1e      	ldr	r3, [pc, #120]	; (ee8 <vTaskSwitchContext+0x98>)
     e6e:	681b      	ldr	r3, [r3, #0]
     e70:	607b      	str	r3, [r7, #4]
     e72:	e007      	b.n	e84 <vTaskSwitchContext+0x34>
     e74:	687b      	ldr	r3, [r7, #4]
     e76:	2b00      	cmp	r3, #0
     e78:	d101      	bne.n	e7e <vTaskSwitchContext+0x2e>
     e7a:	b672      	cpsid	i
     e7c:	e7fe      	b.n	e7c <vTaskSwitchContext+0x2c>
     e7e:	687b      	ldr	r3, [r7, #4]
     e80:	3b01      	subs	r3, #1
     e82:	607b      	str	r3, [r7, #4]
     e84:	4919      	ldr	r1, [pc, #100]	; (eec <vTaskSwitchContext+0x9c>)
     e86:	687a      	ldr	r2, [r7, #4]
     e88:	0013      	movs	r3, r2
     e8a:	009b      	lsls	r3, r3, #2
     e8c:	189b      	adds	r3, r3, r2
     e8e:	009b      	lsls	r3, r3, #2
     e90:	585b      	ldr	r3, [r3, r1]
     e92:	2b00      	cmp	r3, #0
     e94:	d0ee      	beq.n	e74 <vTaskSwitchContext+0x24>
     e96:	687a      	ldr	r2, [r7, #4]
     e98:	0013      	movs	r3, r2
     e9a:	009b      	lsls	r3, r3, #2
     e9c:	189b      	adds	r3, r3, r2
     e9e:	009b      	lsls	r3, r3, #2
     ea0:	4a12      	ldr	r2, [pc, #72]	; (eec <vTaskSwitchContext+0x9c>)
     ea2:	189b      	adds	r3, r3, r2
     ea4:	603b      	str	r3, [r7, #0]
     ea6:	683b      	ldr	r3, [r7, #0]
     ea8:	685b      	ldr	r3, [r3, #4]
     eaa:	685a      	ldr	r2, [r3, #4]
     eac:	683b      	ldr	r3, [r7, #0]
     eae:	605a      	str	r2, [r3, #4]
     eb0:	683b      	ldr	r3, [r7, #0]
     eb2:	685a      	ldr	r2, [r3, #4]
     eb4:	683b      	ldr	r3, [r7, #0]
     eb6:	3308      	adds	r3, #8
     eb8:	429a      	cmp	r2, r3
     eba:	d104      	bne.n	ec6 <vTaskSwitchContext+0x76>
     ebc:	683b      	ldr	r3, [r7, #0]
     ebe:	685b      	ldr	r3, [r3, #4]
     ec0:	685a      	ldr	r2, [r3, #4]
     ec2:	683b      	ldr	r3, [r7, #0]
     ec4:	605a      	str	r2, [r3, #4]
     ec6:	683b      	ldr	r3, [r7, #0]
     ec8:	685b      	ldr	r3, [r3, #4]
     eca:	68da      	ldr	r2, [r3, #12]
     ecc:	4b08      	ldr	r3, [pc, #32]	; (ef0 <vTaskSwitchContext+0xa0>)
     ece:	601a      	str	r2, [r3, #0]
     ed0:	4b05      	ldr	r3, [pc, #20]	; (ee8 <vTaskSwitchContext+0x98>)
     ed2:	687a      	ldr	r2, [r7, #4]
     ed4:	601a      	str	r2, [r3, #0]
}
     ed6:	46c0      	nop			; (mov r8, r8)
     ed8:	46bd      	mov	sp, r7
     eda:	b002      	add	sp, #8
     edc:	bd80      	pop	{r7, pc}
     ede:	46c0      	nop			; (mov r8, r8)
     ee0:	20000118 	.word	0x20000118
     ee4:	2000010c 	.word	0x2000010c
     ee8:	20000104 	.word	0x20000104
     eec:	20000094 	.word	0x20000094
     ef0:	20000090 	.word	0x20000090

00000ef4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
     ef4:	b580      	push	{r7, lr}
     ef6:	b082      	sub	sp, #8
     ef8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     efa:	4b0e      	ldr	r3, [pc, #56]	; (f34 <prvResetNextTaskUnblockTime+0x40>)
     efc:	681b      	ldr	r3, [r3, #0]
     efe:	681b      	ldr	r3, [r3, #0]
     f00:	2b00      	cmp	r3, #0
     f02:	d101      	bne.n	f08 <prvResetNextTaskUnblockTime+0x14>
     f04:	2301      	movs	r3, #1
     f06:	e000      	b.n	f0a <prvResetNextTaskUnblockTime+0x16>
     f08:	2300      	movs	r3, #0
     f0a:	2b00      	cmp	r3, #0
     f0c:	d004      	beq.n	f18 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     f0e:	4b0a      	ldr	r3, [pc, #40]	; (f38 <prvResetNextTaskUnblockTime+0x44>)
     f10:	2201      	movs	r2, #1
     f12:	4252      	negs	r2, r2
     f14:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
     f16:	e008      	b.n	f2a <prvResetNextTaskUnblockTime+0x36>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     f18:	4b06      	ldr	r3, [pc, #24]	; (f34 <prvResetNextTaskUnblockTime+0x40>)
     f1a:	681b      	ldr	r3, [r3, #0]
     f1c:	68db      	ldr	r3, [r3, #12]
     f1e:	68db      	ldr	r3, [r3, #12]
     f20:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     f22:	687b      	ldr	r3, [r7, #4]
     f24:	685a      	ldr	r2, [r3, #4]
     f26:	4b04      	ldr	r3, [pc, #16]	; (f38 <prvResetNextTaskUnblockTime+0x44>)
     f28:	601a      	str	r2, [r3, #0]
}
     f2a:	46c0      	nop			; (mov r8, r8)
     f2c:	46bd      	mov	sp, r7
     f2e:	b002      	add	sp, #8
     f30:	bd80      	pop	{r7, pc}
     f32:	46c0      	nop			; (mov r8, r8)
     f34:	200000f8 	.word	0x200000f8
     f38:	20000114 	.word	0x20000114

00000f3c <wdt_clear_early_warning>:
 *
 *  Clears the Watchdog timer early warning period elapsed flag, so that a new
 *  early warning period can be detected.
 */
static inline void wdt_clear_early_warning(void)
{
     f3c:	b580      	push	{r7, lr}
     f3e:	b082      	sub	sp, #8
     f40:	af00      	add	r7, sp, #0
	Wdt *const WDT_module = WDT;
     f42:	4b04      	ldr	r3, [pc, #16]	; (f54 <wdt_clear_early_warning+0x18>)
     f44:	607b      	str	r3, [r7, #4]

	WDT_module->INTFLAG.reg = WDT_INTFLAG_EW;
     f46:	687b      	ldr	r3, [r7, #4]
     f48:	2201      	movs	r2, #1
     f4a:	719a      	strb	r2, [r3, #6]
}
     f4c:	46c0      	nop			; (mov r8, r8)
     f4e:	46bd      	mov	sp, r7
     f50:	b002      	add	sp, #8
     f52:	bd80      	pop	{r7, pc}
     f54:	40001000 	.word	0x40001000

00000f58 <WDT_Handler>:
	}
}

/** Handler for the WDT hardware module interrupt. */
void WDT_Handler(void)
{
     f58:	b580      	push	{r7, lr}
     f5a:	af00      	add	r7, sp, #0
	wdt_clear_early_warning();
     f5c:	4b05      	ldr	r3, [pc, #20]	; (f74 <WDT_Handler+0x1c>)
     f5e:	4798      	blx	r3

	if (wdt_early_warning_callback) {
     f60:	4b05      	ldr	r3, [pc, #20]	; (f78 <WDT_Handler+0x20>)
     f62:	681b      	ldr	r3, [r3, #0]
     f64:	2b00      	cmp	r3, #0
     f66:	d002      	beq.n	f6e <WDT_Handler+0x16>
		wdt_early_warning_callback();
     f68:	4b03      	ldr	r3, [pc, #12]	; (f78 <WDT_Handler+0x20>)
     f6a:	681b      	ldr	r3, [r3, #0]
     f6c:	4798      	blx	r3
	}
}
     f6e:	46c0      	nop			; (mov r8, r8)
     f70:	46bd      	mov	sp, r7
     f72:	bd80      	pop	{r7, pc}
     f74:	00000f3d 	.word	0x00000f3d
     f78:	200001d8 	.word	0x200001d8

00000f7c <_usb_host_interrupt_handler>:
 *   (Device dis/connection, SOF, reset, resume, wakeup, error)
 * - Pipe events
 *   (End of data transfer, setup, stall, error)
 */
static void _usb_host_interrupt_handler(void)
{
     f7c:	b580      	push	{r7, lr}
     f7e:	b082      	sub	sp, #8
     f80:	af00      	add	r7, sp, #0
	uint32_t pipe_int;
	uint32_t flags;

	/* Manage pipe interrupts */
	pipe_int = ctz(_usb_instances->hw->HOST.PINTSMRY.reg);
     f82:	4ba4      	ldr	r3, [pc, #656]	; (1214 <_usb_host_interrupt_handler+0x298>)
     f84:	681b      	ldr	r3, [r3, #0]
     f86:	681b      	ldr	r3, [r3, #0]
     f88:	8c1b      	ldrh	r3, [r3, #32]
     f8a:	b29b      	uxth	r3, r3
     f8c:	2b00      	cmp	r3, #0
     f8e:	d00a      	beq.n	fa6 <_usb_host_interrupt_handler+0x2a>
     f90:	4ba0      	ldr	r3, [pc, #640]	; (1214 <_usb_host_interrupt_handler+0x298>)
     f92:	681b      	ldr	r3, [r3, #0]
     f94:	681b      	ldr	r3, [r3, #0]
     f96:	8c1b      	ldrh	r3, [r3, #32]
     f98:	b29b      	uxth	r3, r3
     f9a:	001a      	movs	r2, r3
     f9c:	4b9e      	ldr	r3, [pc, #632]	; (1218 <_usb_host_interrupt_handler+0x29c>)
     f9e:	0010      	movs	r0, r2
     fa0:	4798      	blx	r3
     fa2:	0003      	movs	r3, r0
     fa4:	e000      	b.n	fa8 <_usb_host_interrupt_handler+0x2c>
     fa6:	2320      	movs	r3, #32
     fa8:	607b      	str	r3, [r7, #4]
	if (pipe_int < 32) {
     faa:	687b      	ldr	r3, [r7, #4]
     fac:	2b1f      	cmp	r3, #31
     fae:	d900      	bls.n	fb2 <_usb_host_interrupt_handler+0x36>
     fb0:	e204      	b.n	13bc <_usb_host_interrupt_handler+0x440>
		/* pipe interrupts */

		/* get interrupt flags */
		flags = _usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg;
     fb2:	4b98      	ldr	r3, [pc, #608]	; (1214 <_usb_host_interrupt_handler+0x298>)
     fb4:	681b      	ldr	r3, [r3, #0]
     fb6:	681a      	ldr	r2, [r3, #0]
     fb8:	687b      	ldr	r3, [r7, #4]
     fba:	3308      	adds	r3, #8
     fbc:	015b      	lsls	r3, r3, #5
     fbe:	18d3      	adds	r3, r2, r3
     fc0:	3307      	adds	r3, #7
     fc2:	781b      	ldrb	r3, [r3, #0]
     fc4:	b2db      	uxtb	r3, r3
     fc6:	603b      	str	r3, [r7, #0]

		/* host pipe transfer complete interrupt */
		if (flags & USB_HOST_PINTFLAG_TRCPT_Msk) {
     fc8:	683b      	ldr	r3, [r7, #0]
     fca:	2203      	movs	r2, #3
     fcc:	4013      	ands	r3, r2
     fce:	d100      	bne.n	fd2 <_usb_host_interrupt_handler+0x56>
     fd0:	e088      	b.n	10e4 <_usb_host_interrupt_handler+0x168>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
     fd2:	2201      	movs	r2, #1
     fd4:	687b      	ldr	r3, [r7, #4]
     fd6:	409a      	lsls	r2, r3
     fd8:	0013      	movs	r3, r2
     fda:	43db      	mvns	r3, r3
     fdc:	001a      	movs	r2, r3
     fde:	4b8f      	ldr	r3, [pc, #572]	; (121c <_usb_host_interrupt_handler+0x2a0>)
     fe0:	681b      	ldr	r3, [r3, #0]
     fe2:	401a      	ands	r2, r3
     fe4:	4b8d      	ldr	r3, [pc, #564]	; (121c <_usb_host_interrupt_handler+0x2a0>)
     fe6:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
     fe8:	4b8a      	ldr	r3, [pc, #552]	; (1214 <_usb_host_interrupt_handler+0x298>)
     fea:	681b      	ldr	r3, [r3, #0]
     fec:	681a      	ldr	r2, [r3, #0]
     fee:	687b      	ldr	r3, [r7, #4]
     ff0:	3308      	adds	r3, #8
     ff2:	015b      	lsls	r3, r3, #5
     ff4:	18d3      	adds	r3, r2, r3
     ff6:	3307      	adds	r3, #7
     ff8:	2203      	movs	r2, #3
     ffa:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_TRCPT_Msk;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
     ffc:	4b85      	ldr	r3, [pc, #532]	; (1214 <_usb_host_interrupt_handler+0x298>)
     ffe:	681a      	ldr	r2, [r3, #0]
    1000:	21ae      	movs	r1, #174	; 0xae
    1002:	687b      	ldr	r3, [r7, #4]
    1004:	18d3      	adds	r3, r2, r3
    1006:	185b      	adds	r3, r3, r1
    1008:	781b      	ldrb	r3, [r3, #0]
    100a:	001a      	movs	r2, r3
    100c:	2301      	movs	r3, #1
    100e:	4013      	ands	r3, r2
    1010:	d068      	beq.n	10e4 <_usb_host_interrupt_handler+0x168>
					(1 << USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE)) {
				pipe_callback_para.pipe_num = pipe_int;
    1012:	687b      	ldr	r3, [r7, #4]
    1014:	b2da      	uxtb	r2, r3
    1016:	4b82      	ldr	r3, [pc, #520]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    1018:	701a      	strb	r2, [r3, #0]
				if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTOKEN ==
    101a:	4b7e      	ldr	r3, [pc, #504]	; (1214 <_usb_host_interrupt_handler+0x298>)
    101c:	681b      	ldr	r3, [r3, #0]
    101e:	681b      	ldr	r3, [r3, #0]
    1020:	687a      	ldr	r2, [r7, #4]
    1022:	3208      	adds	r2, #8
    1024:	0152      	lsls	r2, r2, #5
    1026:	5cd3      	ldrb	r3, [r2, r3]
    1028:	079b      	lsls	r3, r3, #30
    102a:	0f9b      	lsrs	r3, r3, #30
    102c:	b2db      	uxtb	r3, r3
    102e:	2b01      	cmp	r3, #1
    1030:	d11e      	bne.n	1070 <_usb_host_interrupt_handler+0xf4>
							USB_HOST_PIPE_TOKEN_IN) {
					/* in  */
					pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    1032:	4a7c      	ldr	r2, [pc, #496]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    1034:	687b      	ldr	r3, [r7, #4]
    1036:	015b      	lsls	r3, r3, #5
    1038:	18d3      	adds	r3, r2, r3
    103a:	685b      	ldr	r3, [r3, #4]
    103c:	049b      	lsls	r3, r3, #18
    103e:	0c9b      	lsrs	r3, r3, #18
    1040:	b29b      	uxth	r3, r3
    1042:	001a      	movs	r2, r3
    1044:	4b76      	ldr	r3, [pc, #472]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    1046:	805a      	strh	r2, [r3, #2]
					pipe_callback_para.required_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    1048:	4a76      	ldr	r2, [pc, #472]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    104a:	687b      	ldr	r3, [r7, #4]
    104c:	015b      	lsls	r3, r3, #5
    104e:	18d3      	adds	r3, r2, r3
    1050:	685b      	ldr	r3, [r3, #4]
    1052:	011b      	lsls	r3, r3, #4
    1054:	0c9b      	lsrs	r3, r3, #18
    1056:	b29b      	uxth	r3, r3
    1058:	001a      	movs	r2, r3
    105a:	4b71      	ldr	r3, [pc, #452]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    105c:	809a      	strh	r2, [r3, #4]
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT = 0;
    105e:	4a71      	ldr	r2, [pc, #452]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    1060:	687b      	ldr	r3, [r7, #4]
    1062:	015b      	lsls	r3, r3, #5
    1064:	18d3      	adds	r3, r2, r3
    1066:	685a      	ldr	r2, [r3, #4]
    1068:	0b92      	lsrs	r2, r2, #14
    106a:	0392      	lsls	r2, r2, #14
    106c:	605a      	str	r2, [r3, #4]
    106e:	e02c      	b.n	10ca <_usb_host_interrupt_handler+0x14e>
				} else {
					/* out */
					pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    1070:	4a6c      	ldr	r2, [pc, #432]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    1072:	687b      	ldr	r3, [r7, #4]
    1074:	015b      	lsls	r3, r3, #5
    1076:	18d3      	adds	r3, r2, r3
    1078:	685b      	ldr	r3, [r3, #4]
    107a:	011b      	lsls	r3, r3, #4
    107c:	0c9b      	lsrs	r3, r3, #18
    107e:	b29b      	uxth	r3, r3
    1080:	001a      	movs	r2, r3
    1082:	4b67      	ldr	r3, [pc, #412]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    1084:	805a      	strh	r2, [r3, #2]
					pipe_callback_para.required_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    1086:	4a67      	ldr	r2, [pc, #412]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    1088:	687b      	ldr	r3, [r7, #4]
    108a:	015b      	lsls	r3, r3, #5
    108c:	18d3      	adds	r3, r2, r3
    108e:	685b      	ldr	r3, [r3, #4]
    1090:	049b      	lsls	r3, r3, #18
    1092:	0c9b      	lsrs	r3, r3, #18
    1094:	b29b      	uxth	r3, r3
    1096:	001a      	movs	r2, r3
    1098:	4b61      	ldr	r3, [pc, #388]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    109a:	809a      	strh	r2, [r3, #4]
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
    109c:	4a61      	ldr	r2, [pc, #388]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    109e:	687b      	ldr	r3, [r7, #4]
    10a0:	015b      	lsls	r3, r3, #5
    10a2:	18d3      	adds	r3, r2, r3
    10a4:	685a      	ldr	r2, [r3, #4]
    10a6:	4960      	ldr	r1, [pc, #384]	; (1228 <_usb_host_interrupt_handler+0x2ac>)
    10a8:	400a      	ands	r2, r1
    10aa:	605a      	str	r2, [r3, #4]
					if (0 == pipe_callback_para.transfered_size) {
    10ac:	4b5c      	ldr	r3, [pc, #368]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    10ae:	885b      	ldrh	r3, [r3, #2]
    10b0:	2b00      	cmp	r3, #0
    10b2:	d10a      	bne.n	10ca <_usb_host_interrupt_handler+0x14e>
						pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.BYTE_COUNT;
    10b4:	4a5b      	ldr	r2, [pc, #364]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    10b6:	687b      	ldr	r3, [r7, #4]
    10b8:	015b      	lsls	r3, r3, #5
    10ba:	18d3      	adds	r3, r2, r3
    10bc:	685b      	ldr	r3, [r3, #4]
    10be:	049b      	lsls	r3, r3, #18
    10c0:	0c9b      	lsrs	r3, r3, #18
    10c2:	b29b      	uxth	r3, r3
    10c4:	001a      	movs	r2, r3
    10c6:	4b56      	ldr	r3, [pc, #344]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    10c8:	805a      	strh	r2, [r3, #2]
					}
				}
				(_usb_instances->host_pipe_callback[pipe_int]
    10ca:	4b52      	ldr	r3, [pc, #328]	; (1214 <_usb_host_interrupt_handler+0x298>)
    10cc:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE])(_usb_instances, &pipe_callback_para);
    10ce:	687b      	ldr	r3, [r7, #4]
    10d0:	3302      	adds	r3, #2
    10d2:	011b      	lsls	r3, r3, #4
    10d4:	18d3      	adds	r3, r2, r3
    10d6:	3304      	adds	r3, #4
    10d8:	681a      	ldr	r2, [r3, #0]
    10da:	4b4e      	ldr	r3, [pc, #312]	; (1214 <_usb_host_interrupt_handler+0x298>)
    10dc:	681b      	ldr	r3, [r3, #0]
    10de:	4950      	ldr	r1, [pc, #320]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    10e0:	0018      	movs	r0, r3
    10e2:	4790      	blx	r2
			}
		}

		/* host pipe transfer fail interrupt */
		if (flags & USB_HOST_PINTFLAG_TRFAIL) {
    10e4:	683b      	ldr	r3, [r7, #0]
    10e6:	2204      	movs	r2, #4
    10e8:	4013      	ands	r3, r2
    10ea:	d100      	bne.n	10ee <_usb_host_interrupt_handler+0x172>
    10ec:	e0af      	b.n	124e <_usb_host_interrupt_handler+0x2d2>
			/* For ISO IN, check CRC error */
			if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTYPE == USB_HOST_PIPE_TYPE_ISO &&
    10ee:	4b49      	ldr	r3, [pc, #292]	; (1214 <_usb_host_interrupt_handler+0x298>)
    10f0:	681b      	ldr	r3, [r3, #0]
    10f2:	681b      	ldr	r3, [r3, #0]
    10f4:	687a      	ldr	r2, [r7, #4]
    10f6:	3208      	adds	r2, #8
    10f8:	0152      	lsls	r2, r2, #5
    10fa:	5cd3      	ldrb	r3, [r2, r3]
    10fc:	069b      	lsls	r3, r3, #26
    10fe:	0f5b      	lsrs	r3, r3, #29
    1100:	b2db      	uxtb	r3, r3
    1102:	2b02      	cmp	r3, #2
    1104:	d151      	bne.n	11aa <_usb_host_interrupt_handler+0x22e>
					_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTOKEN == USB_HOST_PIPE_TOKEN_IN &&
    1106:	4b43      	ldr	r3, [pc, #268]	; (1214 <_usb_host_interrupt_handler+0x298>)
    1108:	681b      	ldr	r3, [r3, #0]
    110a:	681b      	ldr	r3, [r3, #0]
    110c:	687a      	ldr	r2, [r7, #4]
    110e:	3208      	adds	r2, #8
    1110:	0152      	lsls	r2, r2, #5
    1112:	5cd3      	ldrb	r3, [r2, r3]
    1114:	079b      	lsls	r3, r3, #30
    1116:	0f9b      	lsrs	r3, r3, #30
    1118:	b2db      	uxtb	r3, r3
			if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTYPE == USB_HOST_PIPE_TYPE_ISO &&
    111a:	2b01      	cmp	r3, #1
    111c:	d145      	bne.n	11aa <_usb_host_interrupt_handler+0x22e>
					usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_BK.bit.CRCERR) {
    111e:	4a41      	ldr	r2, [pc, #260]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    1120:	687b      	ldr	r3, [r7, #4]
    1122:	015b      	lsls	r3, r3, #5
    1124:	18d3      	adds	r3, r2, r3
    1126:	3308      	adds	r3, #8
    1128:	789b      	ldrb	r3, [r3, #2]
    112a:	07db      	lsls	r3, r3, #31
    112c:	0fdb      	lsrs	r3, r3, #31
    112e:	b2db      	uxtb	r3, r3
					_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTOKEN == USB_HOST_PIPE_TOKEN_IN &&
    1130:	2b00      	cmp	r3, #0
    1132:	d03a      	beq.n	11aa <_usb_host_interrupt_handler+0x22e>
				/* Clear busy status */
				host_pipe_job_busy_status &= ~(1 << pipe_int);
    1134:	2201      	movs	r2, #1
    1136:	687b      	ldr	r3, [r7, #4]
    1138:	409a      	lsls	r2, r3
    113a:	0013      	movs	r3, r2
    113c:	43db      	mvns	r3, r3
    113e:	001a      	movs	r2, r3
    1140:	4b36      	ldr	r3, [pc, #216]	; (121c <_usb_host_interrupt_handler+0x2a0>)
    1142:	681b      	ldr	r3, [r3, #0]
    1144:	401a      	ands	r2, r3
    1146:	4b35      	ldr	r3, [pc, #212]	; (121c <_usb_host_interrupt_handler+0x2a0>)
    1148:	601a      	str	r2, [r3, #0]
				/* clear the flag */
				usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_BK.reg = 0;
    114a:	4a36      	ldr	r2, [pc, #216]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    114c:	687b      	ldr	r3, [r7, #4]
    114e:	015b      	lsls	r3, r3, #5
    1150:	18d3      	adds	r3, r2, r3
    1152:	330a      	adds	r3, #10
    1154:	2200      	movs	r2, #0
    1156:	701a      	strb	r2, [r3, #0]
				_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    1158:	4b2e      	ldr	r3, [pc, #184]	; (1214 <_usb_host_interrupt_handler+0x298>)
    115a:	681b      	ldr	r3, [r3, #0]
    115c:	681a      	ldr	r2, [r3, #0]
    115e:	687b      	ldr	r3, [r7, #4]
    1160:	3308      	adds	r3, #8
    1162:	015b      	lsls	r3, r3, #5
    1164:	18d3      	adds	r3, r2, r3
    1166:	3307      	adds	r3, #7
    1168:	2204      	movs	r2, #4
    116a:	701a      	strb	r2, [r3, #0]
						USB_HOST_PINTFLAG_TRFAIL;
				if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    116c:	4b29      	ldr	r3, [pc, #164]	; (1214 <_usb_host_interrupt_handler+0x298>)
    116e:	681a      	ldr	r2, [r3, #0]
    1170:	21ae      	movs	r1, #174	; 0xae
    1172:	687b      	ldr	r3, [r7, #4]
    1174:	18d3      	adds	r3, r2, r3
    1176:	185b      	adds	r3, r3, r1
    1178:	781b      	ldrb	r3, [r3, #0]
    117a:	001a      	movs	r2, r3
    117c:	2302      	movs	r3, #2
    117e:	4013      	ands	r3, r2
    1180:	d065      	beq.n	124e <_usb_host_interrupt_handler+0x2d2>
						(1 << USB_HOST_PIPE_CALLBACK_ERROR)) {
					pipe_callback_para.pipe_num = pipe_int;
    1182:	687b      	ldr	r3, [r7, #4]
    1184:	b2da      	uxtb	r2, r3
    1186:	4b26      	ldr	r3, [pc, #152]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    1188:	701a      	strb	r2, [r3, #0]
					#define USB_STATUS_PIPE_CRC16ER   (1 << 4)
					pipe_callback_para.pipe_error_status = USB_STATUS_PIPE_CRC16ER;
    118a:	4b25      	ldr	r3, [pc, #148]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    118c:	2210      	movs	r2, #16
    118e:	705a      	strb	r2, [r3, #1]
					(_usb_instances->host_pipe_callback[pipe_int]
    1190:	4b20      	ldr	r3, [pc, #128]	; (1214 <_usb_host_interrupt_handler+0x298>)
    1192:	681a      	ldr	r2, [r3, #0]
							[USB_HOST_PIPE_CALLBACK_ERROR])(_usb_instances, &pipe_callback_para);
    1194:	687b      	ldr	r3, [r7, #4]
    1196:	011b      	lsls	r3, r3, #4
    1198:	18d3      	adds	r3, r2, r3
    119a:	3328      	adds	r3, #40	; 0x28
    119c:	681a      	ldr	r2, [r3, #0]
    119e:	4b1d      	ldr	r3, [pc, #116]	; (1214 <_usb_host_interrupt_handler+0x298>)
    11a0:	681b      	ldr	r3, [r3, #0]
    11a2:	491f      	ldr	r1, [pc, #124]	; (1220 <_usb_host_interrupt_handler+0x2a4>)
    11a4:	0018      	movs	r0, r3
    11a6:	4790      	blx	r2
				if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    11a8:	e051      	b.n	124e <_usb_host_interrupt_handler+0x2d2>
				}
			}
#if UHD_BULK_INTERVAL_MIN
			/* For Bulk IN, check flow error */
			else if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTYPE == USB_HOST_PIPE_TYPE_BULK &&
    11aa:	4b1a      	ldr	r3, [pc, #104]	; (1214 <_usb_host_interrupt_handler+0x298>)
    11ac:	681b      	ldr	r3, [r3, #0]
    11ae:	681b      	ldr	r3, [r3, #0]
    11b0:	687a      	ldr	r2, [r7, #4]
    11b2:	3208      	adds	r2, #8
    11b4:	0152      	lsls	r2, r2, #5
    11b6:	5cd3      	ldrb	r3, [r2, r3]
    11b8:	069b      	lsls	r3, r3, #26
    11ba:	0f5b      	lsrs	r3, r3, #29
    11bc:	b2db      	uxtb	r3, r3
    11be:	2b03      	cmp	r3, #3
    11c0:	d134      	bne.n	122c <_usb_host_interrupt_handler+0x2b0>
					_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTOKEN == USB_HOST_PIPE_TOKEN_IN) {
    11c2:	4b14      	ldr	r3, [pc, #80]	; (1214 <_usb_host_interrupt_handler+0x298>)
    11c4:	681b      	ldr	r3, [r3, #0]
    11c6:	681b      	ldr	r3, [r3, #0]
    11c8:	687a      	ldr	r2, [r7, #4]
    11ca:	3208      	adds	r2, #8
    11cc:	0152      	lsls	r2, r2, #5
    11ce:	5cd3      	ldrb	r3, [r2, r3]
    11d0:	079b      	lsls	r3, r3, #30
    11d2:	0f9b      	lsrs	r3, r3, #30
    11d4:	b2db      	uxtb	r3, r3
			else if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTYPE == USB_HOST_PIPE_TYPE_BULK &&
    11d6:	2b01      	cmp	r3, #1
    11d8:	d128      	bne.n	122c <_usb_host_interrupt_handler+0x2b0>
				/* clear the flag */
				usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_BK.reg = 0;
    11da:	4a12      	ldr	r2, [pc, #72]	; (1224 <_usb_host_interrupt_handler+0x2a8>)
    11dc:	687b      	ldr	r3, [r7, #4]
    11de:	015b      	lsls	r3, r3, #5
    11e0:	18d3      	adds	r3, r2, r3
    11e2:	330a      	adds	r3, #10
    11e4:	2200      	movs	r2, #0
    11e6:	701a      	strb	r2, [r3, #0]
				_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    11e8:	4b0a      	ldr	r3, [pc, #40]	; (1214 <_usb_host_interrupt_handler+0x298>)
    11ea:	681b      	ldr	r3, [r3, #0]
    11ec:	681a      	ldr	r2, [r3, #0]
    11ee:	687b      	ldr	r3, [r7, #4]
    11f0:	3308      	adds	r3, #8
    11f2:	015b      	lsls	r3, r3, #5
    11f4:	18d3      	adds	r3, r2, r3
    11f6:	3307      	adds	r3, #7
    11f8:	2204      	movs	r2, #4
    11fa:	701a      	strb	r2, [r3, #0]
						USB_HOST_PINTFLAG_TRFAIL;
				/* Freeze until next SOF */
				_usb_instances->hw->HOST.HostPipe[pipe_int].PSTATUSSET.reg = USB_HOST_PSTATUS_PFREEZE;
    11fc:	4b05      	ldr	r3, [pc, #20]	; (1214 <_usb_host_interrupt_handler+0x298>)
    11fe:	681b      	ldr	r3, [r3, #0]
    1200:	681a      	ldr	r2, [r3, #0]
    1202:	687b      	ldr	r3, [r7, #4]
    1204:	3308      	adds	r3, #8
    1206:	015b      	lsls	r3, r3, #5
    1208:	18d3      	adds	r3, r2, r3
    120a:	3305      	adds	r3, #5
    120c:	2210      	movs	r2, #16
    120e:	701a      	strb	r2, [r3, #0]
    1210:	e01d      	b.n	124e <_usb_host_interrupt_handler+0x2d2>
    1212:	46c0      	nop			; (mov r8, r8)
    1214:	2000011c 	.word	0x2000011c
    1218:	00003af9 	.word	0x00003af9
    121c:	20000134 	.word	0x20000134
    1220:	20000120 	.word	0x20000120
    1224:	200001dc 	.word	0x200001dc
    1228:	f0003fff 	.word	0xf0003fff
			}
#endif
			/* Clear flag anyway */
			else {
				/* clear the flag */
				usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_BK.reg = 0;
    122c:	4a83      	ldr	r2, [pc, #524]	; (143c <_usb_host_interrupt_handler+0x4c0>)
    122e:	687b      	ldr	r3, [r7, #4]
    1230:	015b      	lsls	r3, r3, #5
    1232:	18d3      	adds	r3, r2, r3
    1234:	330a      	adds	r3, #10
    1236:	2200      	movs	r2, #0
    1238:	701a      	strb	r2, [r3, #0]
				_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    123a:	4b81      	ldr	r3, [pc, #516]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    123c:	681b      	ldr	r3, [r3, #0]
    123e:	681a      	ldr	r2, [r3, #0]
    1240:	687b      	ldr	r3, [r7, #4]
    1242:	3308      	adds	r3, #8
    1244:	015b      	lsls	r3, r3, #5
    1246:	18d3      	adds	r3, r2, r3
    1248:	3307      	adds	r3, #7
    124a:	2204      	movs	r2, #4
    124c:	701a      	strb	r2, [r3, #0]
						USB_HOST_PINTFLAG_TRFAIL;
			}
		}

		/* host pipe error interrupt */
		if (flags & USB_HOST_PINTFLAG_PERR) {
    124e:	683b      	ldr	r3, [r7, #0]
    1250:	2208      	movs	r2, #8
    1252:	4013      	ands	r3, r2
    1254:	d03c      	beq.n	12d0 <_usb_host_interrupt_handler+0x354>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    1256:	2201      	movs	r2, #1
    1258:	687b      	ldr	r3, [r7, #4]
    125a:	409a      	lsls	r2, r3
    125c:	0013      	movs	r3, r2
    125e:	43db      	mvns	r3, r3
    1260:	001a      	movs	r2, r3
    1262:	4b78      	ldr	r3, [pc, #480]	; (1444 <_usb_host_interrupt_handler+0x4c8>)
    1264:	681b      	ldr	r3, [r3, #0]
    1266:	401a      	ands	r2, r3
    1268:	4b76      	ldr	r3, [pc, #472]	; (1444 <_usb_host_interrupt_handler+0x4c8>)
    126a:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    126c:	4b74      	ldr	r3, [pc, #464]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    126e:	681b      	ldr	r3, [r3, #0]
    1270:	681a      	ldr	r2, [r3, #0]
    1272:	687b      	ldr	r3, [r7, #4]
    1274:	3308      	adds	r3, #8
    1276:	015b      	lsls	r3, r3, #5
    1278:	18d3      	adds	r3, r2, r3
    127a:	3307      	adds	r3, #7
    127c:	2208      	movs	r2, #8
    127e:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_PERR;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    1280:	4b6f      	ldr	r3, [pc, #444]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    1282:	681a      	ldr	r2, [r3, #0]
    1284:	21ae      	movs	r1, #174	; 0xae
    1286:	687b      	ldr	r3, [r7, #4]
    1288:	18d3      	adds	r3, r2, r3
    128a:	185b      	adds	r3, r3, r1
    128c:	781b      	ldrb	r3, [r3, #0]
    128e:	001a      	movs	r2, r3
    1290:	2302      	movs	r3, #2
    1292:	4013      	ands	r3, r2
    1294:	d01c      	beq.n	12d0 <_usb_host_interrupt_handler+0x354>
					(1 << USB_HOST_PIPE_CALLBACK_ERROR)) {
				pipe_callback_para.pipe_num = pipe_int;
    1296:	687b      	ldr	r3, [r7, #4]
    1298:	b2da      	uxtb	r2, r3
    129a:	4b6b      	ldr	r3, [pc, #428]	; (1448 <_usb_host_interrupt_handler+0x4cc>)
    129c:	701a      	strb	r2, [r3, #0]
				pipe_callback_para.pipe_error_status =
						usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].STATUS_PIPE.reg & 0x1F;
    129e:	4a67      	ldr	r2, [pc, #412]	; (143c <_usb_host_interrupt_handler+0x4c0>)
    12a0:	687b      	ldr	r3, [r7, #4]
    12a2:	015b      	lsls	r3, r3, #5
    12a4:	18d3      	adds	r3, r2, r3
    12a6:	330e      	adds	r3, #14
    12a8:	881b      	ldrh	r3, [r3, #0]
    12aa:	b29b      	uxth	r3, r3
    12ac:	b2db      	uxtb	r3, r3
    12ae:	221f      	movs	r2, #31
    12b0:	4013      	ands	r3, r2
    12b2:	b2da      	uxtb	r2, r3
				pipe_callback_para.pipe_error_status =
    12b4:	4b64      	ldr	r3, [pc, #400]	; (1448 <_usb_host_interrupt_handler+0x4cc>)
    12b6:	705a      	strb	r2, [r3, #1]
				(_usb_instances->host_pipe_callback[pipe_int]
    12b8:	4b61      	ldr	r3, [pc, #388]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    12ba:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_ERROR])(_usb_instances, &pipe_callback_para);
    12bc:	687b      	ldr	r3, [r7, #4]
    12be:	011b      	lsls	r3, r3, #4
    12c0:	18d3      	adds	r3, r2, r3
    12c2:	3328      	adds	r3, #40	; 0x28
    12c4:	681a      	ldr	r2, [r3, #0]
    12c6:	4b5e      	ldr	r3, [pc, #376]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    12c8:	681b      	ldr	r3, [r3, #0]
    12ca:	495f      	ldr	r1, [pc, #380]	; (1448 <_usb_host_interrupt_handler+0x4cc>)
    12cc:	0018      	movs	r0, r3
    12ce:	4790      	blx	r2
			}
		}

		/* host pipe transmitted setup interrupt */
		if (flags & USB_HOST_PINTFLAG_TXSTP) {
    12d0:	683b      	ldr	r3, [r7, #0]
    12d2:	2210      	movs	r2, #16
    12d4:	4013      	ands	r3, r2
    12d6:	d03a      	beq.n	134e <_usb_host_interrupt_handler+0x3d2>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    12d8:	2201      	movs	r2, #1
    12da:	687b      	ldr	r3, [r7, #4]
    12dc:	409a      	lsls	r2, r3
    12de:	0013      	movs	r3, r2
    12e0:	43db      	mvns	r3, r3
    12e2:	001a      	movs	r2, r3
    12e4:	4b57      	ldr	r3, [pc, #348]	; (1444 <_usb_host_interrupt_handler+0x4c8>)
    12e6:	681b      	ldr	r3, [r3, #0]
    12e8:	401a      	ands	r2, r3
    12ea:	4b56      	ldr	r3, [pc, #344]	; (1444 <_usb_host_interrupt_handler+0x4c8>)
    12ec:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    12ee:	4b54      	ldr	r3, [pc, #336]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    12f0:	681b      	ldr	r3, [r3, #0]
    12f2:	681a      	ldr	r2, [r3, #0]
    12f4:	687b      	ldr	r3, [r7, #4]
    12f6:	3308      	adds	r3, #8
    12f8:	015b      	lsls	r3, r3, #5
    12fa:	18d3      	adds	r3, r2, r3
    12fc:	3307      	adds	r3, #7
    12fe:	2210      	movs	r2, #16
    1300:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_TXSTP;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    1302:	4b4f      	ldr	r3, [pc, #316]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    1304:	681a      	ldr	r2, [r3, #0]
    1306:	21ae      	movs	r1, #174	; 0xae
    1308:	687b      	ldr	r3, [r7, #4]
    130a:	18d3      	adds	r3, r2, r3
    130c:	185b      	adds	r3, r3, r1
    130e:	781b      	ldrb	r3, [r3, #0]
    1310:	001a      	movs	r2, r3
    1312:	2304      	movs	r3, #4
    1314:	4013      	ands	r3, r2
    1316:	d01a      	beq.n	134e <_usb_host_interrupt_handler+0x3d2>
					(1 << USB_HOST_PIPE_CALLBACK_SETUP)) {
				pipe_callback_para.pipe_num = pipe_int;
    1318:	687b      	ldr	r3, [r7, #4]
    131a:	b2da      	uxtb	r2, r3
    131c:	4b4a      	ldr	r3, [pc, #296]	; (1448 <_usb_host_interrupt_handler+0x4cc>)
    131e:	701a      	strb	r2, [r3, #0]
				pipe_callback_para.transfered_size = usb_descriptor_table.usb_pipe_table[pipe_int].HostDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE;
    1320:	4a46      	ldr	r2, [pc, #280]	; (143c <_usb_host_interrupt_handler+0x4c0>)
    1322:	687b      	ldr	r3, [r7, #4]
    1324:	015b      	lsls	r3, r3, #5
    1326:	18d3      	adds	r3, r2, r3
    1328:	685b      	ldr	r3, [r3, #4]
    132a:	011b      	lsls	r3, r3, #4
    132c:	0c9b      	lsrs	r3, r3, #18
    132e:	b29b      	uxth	r3, r3
    1330:	001a      	movs	r2, r3
    1332:	4b45      	ldr	r3, [pc, #276]	; (1448 <_usb_host_interrupt_handler+0x4cc>)
    1334:	805a      	strh	r2, [r3, #2]
				(_usb_instances->host_pipe_callback[pipe_int]
    1336:	4b42      	ldr	r3, [pc, #264]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    1338:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_SETUP])(_usb_instances, NULL);
    133a:	687b      	ldr	r3, [r7, #4]
    133c:	011b      	lsls	r3, r3, #4
    133e:	18d3      	adds	r3, r2, r3
    1340:	332c      	adds	r3, #44	; 0x2c
    1342:	681a      	ldr	r2, [r3, #0]
    1344:	4b3e      	ldr	r3, [pc, #248]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    1346:	681b      	ldr	r3, [r3, #0]
    1348:	2100      	movs	r1, #0
    134a:	0018      	movs	r0, r3
    134c:	4790      	blx	r2
			}
		}

		/* host pipe stall interrupt */
		if (flags & USB_HOST_PINTFLAG_STALL) {
    134e:	683b      	ldr	r3, [r7, #0]
    1350:	2220      	movs	r2, #32
    1352:	4013      	ands	r3, r2
    1354:	d100      	bne.n	1358 <_usb_host_interrupt_handler+0x3dc>
    1356:	e146      	b.n	15e6 <_usb_host_interrupt_handler+0x66a>
			/* Clear busy status */
			host_pipe_job_busy_status &= ~(1 << pipe_int);
    1358:	2201      	movs	r2, #1
    135a:	687b      	ldr	r3, [r7, #4]
    135c:	409a      	lsls	r2, r3
    135e:	0013      	movs	r3, r2
    1360:	43db      	mvns	r3, r3
    1362:	001a      	movs	r2, r3
    1364:	4b37      	ldr	r3, [pc, #220]	; (1444 <_usb_host_interrupt_handler+0x4c8>)
    1366:	681b      	ldr	r3, [r3, #0]
    1368:	401a      	ands	r2, r3
    136a:	4b36      	ldr	r3, [pc, #216]	; (1444 <_usb_host_interrupt_handler+0x4c8>)
    136c:	601a      	str	r2, [r3, #0]
			/* clear the flag */
			_usb_instances->hw->HOST.HostPipe[pipe_int].PINTFLAG.reg =
    136e:	4b34      	ldr	r3, [pc, #208]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    1370:	681b      	ldr	r3, [r3, #0]
    1372:	681a      	ldr	r2, [r3, #0]
    1374:	687b      	ldr	r3, [r7, #4]
    1376:	3308      	adds	r3, #8
    1378:	015b      	lsls	r3, r3, #5
    137a:	18d3      	adds	r3, r2, r3
    137c:	3307      	adds	r3, #7
    137e:	2220      	movs	r2, #32
    1380:	701a      	strb	r2, [r3, #0]
					USB_HOST_PINTFLAG_STALL;
			if(_usb_instances->host_pipe_enabled_callback_mask[pipe_int] &
    1382:	4b2f      	ldr	r3, [pc, #188]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    1384:	681a      	ldr	r2, [r3, #0]
    1386:	21ae      	movs	r1, #174	; 0xae
    1388:	687b      	ldr	r3, [r7, #4]
    138a:	18d3      	adds	r3, r2, r3
    138c:	185b      	adds	r3, r3, r1
    138e:	781b      	ldrb	r3, [r3, #0]
    1390:	001a      	movs	r2, r3
    1392:	2308      	movs	r3, #8
    1394:	4013      	ands	r3, r2
    1396:	d100      	bne.n	139a <_usb_host_interrupt_handler+0x41e>
    1398:	e125      	b.n	15e6 <_usb_host_interrupt_handler+0x66a>
					(1 << USB_HOST_PIPE_CALLBACK_STALL)) {
				pipe_callback_para.pipe_num = pipe_int;
    139a:	687b      	ldr	r3, [r7, #4]
    139c:	b2da      	uxtb	r2, r3
    139e:	4b2a      	ldr	r3, [pc, #168]	; (1448 <_usb_host_interrupt_handler+0x4cc>)
    13a0:	701a      	strb	r2, [r3, #0]
				(_usb_instances->host_pipe_callback[pipe_int]
    13a2:	4b27      	ldr	r3, [pc, #156]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    13a4:	681a      	ldr	r2, [r3, #0]
						[USB_HOST_PIPE_CALLBACK_STALL])(_usb_instances, &pipe_callback_para);
    13a6:	687b      	ldr	r3, [r7, #4]
    13a8:	011b      	lsls	r3, r3, #4
    13aa:	18d3      	adds	r3, r2, r3
    13ac:	3330      	adds	r3, #48	; 0x30
    13ae:	681a      	ldr	r2, [r3, #0]
    13b0:	4b23      	ldr	r3, [pc, #140]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    13b2:	681b      	ldr	r3, [r3, #0]
    13b4:	4924      	ldr	r1, [pc, #144]	; (1448 <_usb_host_interrupt_handler+0x4cc>)
    13b6:	0018      	movs	r0, r3
    13b8:	4790      	blx	r2
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DISCONNECT])(_usb_instances);
			}
		}

	}
}
    13ba:	e114      	b.n	15e6 <_usb_host_interrupt_handler+0x66a>
		flags = _usb_instances->hw->HOST.INTFLAG.reg;
    13bc:	4b20      	ldr	r3, [pc, #128]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    13be:	681b      	ldr	r3, [r3, #0]
    13c0:	681b      	ldr	r3, [r3, #0]
    13c2:	8b9b      	ldrh	r3, [r3, #28]
    13c4:	b29b      	uxth	r3, r3
    13c6:	603b      	str	r3, [r7, #0]
		if (flags & USB_HOST_INTFLAG_HSOF) {
    13c8:	683b      	ldr	r3, [r7, #0]
    13ca:	2204      	movs	r2, #4
    13cc:	4013      	ands	r3, r2
    13ce:	d053      	beq.n	1478 <_usb_host_interrupt_handler+0x4fc>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_HSOF;
    13d0:	4b1b      	ldr	r3, [pc, #108]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    13d2:	681b      	ldr	r3, [r3, #0]
    13d4:	681b      	ldr	r3, [r3, #0]
    13d6:	2204      	movs	r2, #4
    13d8:	839a      	strh	r2, [r3, #28]
			for (pipe_int = 1; pipe_int < USB_PIPE_NUM; pipe_int ++) {
    13da:	2301      	movs	r3, #1
    13dc:	607b      	str	r3, [r7, #4]
    13de:	e039      	b.n	1454 <_usb_host_interrupt_handler+0x4d8>
				if (!(host_pipe_job_busy_status & (1 << pipe_int))) {
    13e0:	2201      	movs	r2, #1
    13e2:	687b      	ldr	r3, [r7, #4]
    13e4:	409a      	lsls	r2, r3
    13e6:	0013      	movs	r3, r2
    13e8:	001a      	movs	r2, r3
    13ea:	4b16      	ldr	r3, [pc, #88]	; (1444 <_usb_host_interrupt_handler+0x4c8>)
    13ec:	681b      	ldr	r3, [r3, #0]
    13ee:	4013      	ands	r3, r2
    13f0:	d022      	beq.n	1438 <_usb_host_interrupt_handler+0x4bc>
				if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTYPE != USB_HOST_PIPE_TYPE_BULK ||
    13f2:	4b13      	ldr	r3, [pc, #76]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    13f4:	681b      	ldr	r3, [r3, #0]
    13f6:	681b      	ldr	r3, [r3, #0]
    13f8:	687a      	ldr	r2, [r7, #4]
    13fa:	3208      	adds	r2, #8
    13fc:	0152      	lsls	r2, r2, #5
    13fe:	5cd3      	ldrb	r3, [r2, r3]
    1400:	069b      	lsls	r3, r3, #26
    1402:	0f5b      	lsrs	r3, r3, #29
    1404:	b2db      	uxtb	r3, r3
    1406:	2b03      	cmp	r3, #3
    1408:	d120      	bne.n	144c <_usb_host_interrupt_handler+0x4d0>
					_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTOKEN != USB_HOST_PIPE_TOKEN_IN) {
    140a:	4b0d      	ldr	r3, [pc, #52]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    140c:	681b      	ldr	r3, [r3, #0]
    140e:	681b      	ldr	r3, [r3, #0]
    1410:	687a      	ldr	r2, [r7, #4]
    1412:	3208      	adds	r2, #8
    1414:	0152      	lsls	r2, r2, #5
    1416:	5cd3      	ldrb	r3, [r2, r3]
    1418:	079b      	lsls	r3, r3, #30
    141a:	0f9b      	lsrs	r3, r3, #30
    141c:	b2db      	uxtb	r3, r3
				if (_usb_instances->hw->HOST.HostPipe[pipe_int].PCFG.bit.PTYPE != USB_HOST_PIPE_TYPE_BULK ||
    141e:	2b01      	cmp	r3, #1
    1420:	d114      	bne.n	144c <_usb_host_interrupt_handler+0x4d0>
				_usb_instances->hw->HOST.HostPipe[pipe_int].PSTATUSCLR.reg = USB_HOST_PSTATUS_PFREEZE;
    1422:	4b07      	ldr	r3, [pc, #28]	; (1440 <_usb_host_interrupt_handler+0x4c4>)
    1424:	681b      	ldr	r3, [r3, #0]
    1426:	681a      	ldr	r2, [r3, #0]
    1428:	687b      	ldr	r3, [r7, #4]
    142a:	3308      	adds	r3, #8
    142c:	015b      	lsls	r3, r3, #5
    142e:	18d3      	adds	r3, r2, r3
    1430:	3304      	adds	r3, #4
    1432:	2210      	movs	r2, #16
    1434:	701a      	strb	r2, [r3, #0]
    1436:	e00a      	b.n	144e <_usb_host_interrupt_handler+0x4d2>
					continue;
    1438:	46c0      	nop			; (mov r8, r8)
    143a:	e008      	b.n	144e <_usb_host_interrupt_handler+0x4d2>
    143c:	200001dc 	.word	0x200001dc
    1440:	2000011c 	.word	0x2000011c
    1444:	20000134 	.word	0x20000134
    1448:	20000120 	.word	0x20000120
					continue;
    144c:	46c0      	nop			; (mov r8, r8)
			for (pipe_int = 1; pipe_int < USB_PIPE_NUM; pipe_int ++) {
    144e:	687b      	ldr	r3, [r7, #4]
    1450:	3301      	adds	r3, #1
    1452:	607b      	str	r3, [r7, #4]
    1454:	687b      	ldr	r3, [r7, #4]
    1456:	2b07      	cmp	r3, #7
    1458:	d9c2      	bls.n	13e0 <_usb_host_interrupt_handler+0x464>
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_SOF)) {
    145a:	4b65      	ldr	r3, [pc, #404]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    145c:	681b      	ldr	r3, [r3, #0]
    145e:	22a5      	movs	r2, #165	; 0xa5
    1460:	5c9b      	ldrb	r3, [r3, r2]
    1462:	001a      	movs	r2, r3
    1464:	2301      	movs	r3, #1
    1466:	4013      	ands	r3, r2
    1468:	d006      	beq.n	1478 <_usb_host_interrupt_handler+0x4fc>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_SOF])(_usb_instances);
    146a:	4b61      	ldr	r3, [pc, #388]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    146c:	681b      	ldr	r3, [r3, #0]
    146e:	685a      	ldr	r2, [r3, #4]
    1470:	4b5f      	ldr	r3, [pc, #380]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1472:	681b      	ldr	r3, [r3, #0]
    1474:	0018      	movs	r0, r3
    1476:	4790      	blx	r2
		if (flags & USB_HOST_INTFLAG_RST) {
    1478:	683b      	ldr	r3, [r7, #0]
    147a:	2208      	movs	r2, #8
    147c:	4013      	ands	r3, r2
    147e:	d016      	beq.n	14ae <_usb_host_interrupt_handler+0x532>
			host_pipe_job_busy_status = 0;
    1480:	4b5c      	ldr	r3, [pc, #368]	; (15f4 <_usb_host_interrupt_handler+0x678>)
    1482:	2200      	movs	r2, #0
    1484:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_RST;
    1486:	4b5a      	ldr	r3, [pc, #360]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1488:	681b      	ldr	r3, [r3, #0]
    148a:	681b      	ldr	r3, [r3, #0]
    148c:	2208      	movs	r2, #8
    148e:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_RESET)) {
    1490:	4b57      	ldr	r3, [pc, #348]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1492:	681b      	ldr	r3, [r3, #0]
    1494:	22a5      	movs	r2, #165	; 0xa5
    1496:	5c9b      	ldrb	r3, [r3, r2]
    1498:	001a      	movs	r2, r3
    149a:	2302      	movs	r3, #2
    149c:	4013      	ands	r3, r2
    149e:	d006      	beq.n	14ae <_usb_host_interrupt_handler+0x532>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_RESET])(_usb_instances);
    14a0:	4b53      	ldr	r3, [pc, #332]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14a2:	681b      	ldr	r3, [r3, #0]
    14a4:	689a      	ldr	r2, [r3, #8]
    14a6:	4b52      	ldr	r3, [pc, #328]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14a8:	681b      	ldr	r3, [r3, #0]
    14aa:	0018      	movs	r0, r3
    14ac:	4790      	blx	r2
		if (flags & USB_HOST_INTFLAG_UPRSM) {
    14ae:	683b      	ldr	r3, [r7, #0]
    14b0:	2240      	movs	r2, #64	; 0x40
    14b2:	4013      	ands	r3, r2
    14b4:	d013      	beq.n	14de <_usb_host_interrupt_handler+0x562>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_UPRSM;
    14b6:	4b4e      	ldr	r3, [pc, #312]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14b8:	681b      	ldr	r3, [r3, #0]
    14ba:	681b      	ldr	r3, [r3, #0]
    14bc:	2240      	movs	r2, #64	; 0x40
    14be:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_UPRSM)) {
    14c0:	4b4b      	ldr	r3, [pc, #300]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14c2:	681b      	ldr	r3, [r3, #0]
    14c4:	22a5      	movs	r2, #165	; 0xa5
    14c6:	5c9b      	ldrb	r3, [r3, r2]
    14c8:	001a      	movs	r2, r3
    14ca:	2310      	movs	r3, #16
    14cc:	4013      	ands	r3, r2
    14ce:	d006      	beq.n	14de <_usb_host_interrupt_handler+0x562>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_UPRSM])(_usb_instances);
    14d0:	4b47      	ldr	r3, [pc, #284]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14d2:	681b      	ldr	r3, [r3, #0]
    14d4:	695a      	ldr	r2, [r3, #20]
    14d6:	4b46      	ldr	r3, [pc, #280]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14d8:	681b      	ldr	r3, [r3, #0]
    14da:	0018      	movs	r0, r3
    14dc:	4790      	blx	r2
		if (flags & USB_HOST_INTFLAG_DNRSM) {
    14de:	683b      	ldr	r3, [r7, #0]
    14e0:	2220      	movs	r2, #32
    14e2:	4013      	ands	r3, r2
    14e4:	d013      	beq.n	150e <_usb_host_interrupt_handler+0x592>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DNRSM;
    14e6:	4b42      	ldr	r3, [pc, #264]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14e8:	681b      	ldr	r3, [r3, #0]
    14ea:	681b      	ldr	r3, [r3, #0]
    14ec:	2220      	movs	r2, #32
    14ee:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_DNRSM)) {
    14f0:	4b3f      	ldr	r3, [pc, #252]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    14f2:	681b      	ldr	r3, [r3, #0]
    14f4:	22a5      	movs	r2, #165	; 0xa5
    14f6:	5c9b      	ldrb	r3, [r3, r2]
    14f8:	001a      	movs	r2, r3
    14fa:	2308      	movs	r3, #8
    14fc:	4013      	ands	r3, r2
    14fe:	d006      	beq.n	150e <_usb_host_interrupt_handler+0x592>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DNRSM])(_usb_instances);
    1500:	4b3b      	ldr	r3, [pc, #236]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1502:	681b      	ldr	r3, [r3, #0]
    1504:	691a      	ldr	r2, [r3, #16]
    1506:	4b3a      	ldr	r3, [pc, #232]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1508:	681b      	ldr	r3, [r3, #0]
    150a:	0018      	movs	r0, r3
    150c:	4790      	blx	r2
		if (flags & USB_HOST_INTFLAG_WAKEUP) {
    150e:	683b      	ldr	r3, [r7, #0]
    1510:	2210      	movs	r2, #16
    1512:	4013      	ands	r3, r2
    1514:	d013      	beq.n	153e <_usb_host_interrupt_handler+0x5c2>
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_WAKEUP;
    1516:	4b36      	ldr	r3, [pc, #216]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1518:	681b      	ldr	r3, [r3, #0]
    151a:	681b      	ldr	r3, [r3, #0]
    151c:	2210      	movs	r2, #16
    151e:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_WAKEUP)) {
    1520:	4b33      	ldr	r3, [pc, #204]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1522:	681b      	ldr	r3, [r3, #0]
    1524:	22a5      	movs	r2, #165	; 0xa5
    1526:	5c9b      	ldrb	r3, [r3, r2]
    1528:	001a      	movs	r2, r3
    152a:	2304      	movs	r3, #4
    152c:	4013      	ands	r3, r2
    152e:	d006      	beq.n	153e <_usb_host_interrupt_handler+0x5c2>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_WAKEUP])(_usb_instances);
    1530:	4b2f      	ldr	r3, [pc, #188]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1532:	681b      	ldr	r3, [r3, #0]
    1534:	68da      	ldr	r2, [r3, #12]
    1536:	4b2e      	ldr	r3, [pc, #184]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1538:	681b      	ldr	r3, [r3, #0]
    153a:	0018      	movs	r0, r3
    153c:	4790      	blx	r2
		if (flags & USB_HOST_INTFLAG_RAMACER) {
    153e:	683b      	ldr	r3, [r7, #0]
    1540:	2280      	movs	r2, #128	; 0x80
    1542:	4013      	ands	r3, r2
    1544:	d016      	beq.n	1574 <_usb_host_interrupt_handler+0x5f8>
			host_pipe_job_busy_status = 0;
    1546:	4b2b      	ldr	r3, [pc, #172]	; (15f4 <_usb_host_interrupt_handler+0x678>)
    1548:	2200      	movs	r2, #0
    154a:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_RAMACER;
    154c:	4b28      	ldr	r3, [pc, #160]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    154e:	681b      	ldr	r3, [r3, #0]
    1550:	681b      	ldr	r3, [r3, #0]
    1552:	2280      	movs	r2, #128	; 0x80
    1554:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_RAMACER)) {
    1556:	4b26      	ldr	r3, [pc, #152]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1558:	681b      	ldr	r3, [r3, #0]
    155a:	22a5      	movs	r2, #165	; 0xa5
    155c:	5c9b      	ldrb	r3, [r3, r2]
    155e:	001a      	movs	r2, r3
    1560:	2320      	movs	r3, #32
    1562:	4013      	ands	r3, r2
    1564:	d006      	beq.n	1574 <_usb_host_interrupt_handler+0x5f8>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_RAMACER])(_usb_instances);
    1566:	4b22      	ldr	r3, [pc, #136]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1568:	681b      	ldr	r3, [r3, #0]
    156a:	699a      	ldr	r2, [r3, #24]
    156c:	4b20      	ldr	r3, [pc, #128]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    156e:	681b      	ldr	r3, [r3, #0]
    1570:	0018      	movs	r0, r3
    1572:	4790      	blx	r2
		if (flags & USB_HOST_INTFLAG_DCONN) {
    1574:	683a      	ldr	r2, [r7, #0]
    1576:	2380      	movs	r3, #128	; 0x80
    1578:	005b      	lsls	r3, r3, #1
    157a:	4013      	ands	r3, r2
    157c:	d017      	beq.n	15ae <_usb_host_interrupt_handler+0x632>
			host_pipe_job_busy_status = 0;
    157e:	4b1d      	ldr	r3, [pc, #116]	; (15f4 <_usb_host_interrupt_handler+0x678>)
    1580:	2200      	movs	r2, #0
    1582:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DCONN;
    1584:	4b1a      	ldr	r3, [pc, #104]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1586:	681b      	ldr	r3, [r3, #0]
    1588:	681b      	ldr	r3, [r3, #0]
    158a:	2280      	movs	r2, #128	; 0x80
    158c:	0052      	lsls	r2, r2, #1
    158e:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_CONNECT)) {
    1590:	4b17      	ldr	r3, [pc, #92]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    1592:	681b      	ldr	r3, [r3, #0]
    1594:	22a5      	movs	r2, #165	; 0xa5
    1596:	5c9b      	ldrb	r3, [r3, r2]
    1598:	001a      	movs	r2, r3
    159a:	2340      	movs	r3, #64	; 0x40
    159c:	4013      	ands	r3, r2
    159e:	d006      	beq.n	15ae <_usb_host_interrupt_handler+0x632>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_CONNECT])(_usb_instances);
    15a0:	4b13      	ldr	r3, [pc, #76]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    15a2:	681b      	ldr	r3, [r3, #0]
    15a4:	69da      	ldr	r2, [r3, #28]
    15a6:	4b12      	ldr	r3, [pc, #72]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    15a8:	681b      	ldr	r3, [r3, #0]
    15aa:	0018      	movs	r0, r3
    15ac:	4790      	blx	r2
		if (flags & USB_HOST_INTFLAG_DDISC) {
    15ae:	683a      	ldr	r2, [r7, #0]
    15b0:	2380      	movs	r3, #128	; 0x80
    15b2:	009b      	lsls	r3, r3, #2
    15b4:	4013      	ands	r3, r2
    15b6:	d016      	beq.n	15e6 <_usb_host_interrupt_handler+0x66a>
			host_pipe_job_busy_status = 0;
    15b8:	4b0e      	ldr	r3, [pc, #56]	; (15f4 <_usb_host_interrupt_handler+0x678>)
    15ba:	2200      	movs	r2, #0
    15bc:	601a      	str	r2, [r3, #0]
			_usb_instances->hw->HOST.INTFLAG.reg = USB_HOST_INTFLAG_DDISC;
    15be:	4b0c      	ldr	r3, [pc, #48]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    15c0:	681b      	ldr	r3, [r3, #0]
    15c2:	681b      	ldr	r3, [r3, #0]
    15c4:	2280      	movs	r2, #128	; 0x80
    15c6:	0092      	lsls	r2, r2, #2
    15c8:	839a      	strh	r2, [r3, #28]
			if(_usb_instances->host_enabled_callback_mask & (1 << USB_HOST_CALLBACK_DISCONNECT)) {
    15ca:	4b09      	ldr	r3, [pc, #36]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    15cc:	681b      	ldr	r3, [r3, #0]
    15ce:	22a5      	movs	r2, #165	; 0xa5
    15d0:	5c9b      	ldrb	r3, [r3, r2]
    15d2:	b25b      	sxtb	r3, r3
    15d4:	2b00      	cmp	r3, #0
    15d6:	da06      	bge.n	15e6 <_usb_host_interrupt_handler+0x66a>
				(_usb_instances->host_callback[USB_HOST_CALLBACK_DISCONNECT])(_usb_instances);
    15d8:	4b05      	ldr	r3, [pc, #20]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    15da:	681b      	ldr	r3, [r3, #0]
    15dc:	6a1a      	ldr	r2, [r3, #32]
    15de:	4b04      	ldr	r3, [pc, #16]	; (15f0 <_usb_host_interrupt_handler+0x674>)
    15e0:	681b      	ldr	r3, [r3, #0]
    15e2:	0018      	movs	r0, r3
    15e4:	4790      	blx	r2
}
    15e6:	46c0      	nop			; (mov r8, r8)
    15e8:	46bd      	mov	sp, r7
    15ea:	b002      	add	sp, #8
    15ec:	bd80      	pop	{r7, pc}
    15ee:	46c0      	nop			; (mov r8, r8)
    15f0:	2000011c 	.word	0x2000011c
    15f4:	20000134 	.word	0x20000134

000015f8 <_usb_device_interrupt_handler>:

	return STATUS_OK;
}

static void _usb_device_interrupt_handler(void)
{
    15f8:	b580      	push	{r7, lr}
    15fa:	b084      	sub	sp, #16
    15fc:	af00      	add	r7, sp, #0
	uint16_t ep_inst;
	uint16_t flags, flags_run;
	ep_inst = _usb_instances->hw->DEVICE.EPINTSMRY.reg;
    15fe:	4bbd      	ldr	r3, [pc, #756]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1600:	681b      	ldr	r3, [r3, #0]
    1602:	681a      	ldr	r2, [r3, #0]
    1604:	2308      	movs	r3, #8
    1606:	18fb      	adds	r3, r7, r3
    1608:	8c12      	ldrh	r2, [r2, #32]
    160a:	801a      	strh	r2, [r3, #0]

	/* device interrupt */
	if (0 == ep_inst) {
    160c:	2308      	movs	r3, #8
    160e:	18fb      	adds	r3, r7, r3
    1610:	881b      	ldrh	r3, [r3, #0]
    1612:	2b00      	cmp	r3, #0
    1614:	d155      	bne.n	16c2 <_usb_device_interrupt_handler+0xca>
		int i;

		/* get interrupt flags */
		flags = _usb_instances->hw->DEVICE.INTFLAG.reg;
    1616:	4bb7      	ldr	r3, [pc, #732]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1618:	681b      	ldr	r3, [r3, #0]
    161a:	681a      	ldr	r2, [r3, #0]
    161c:	1dbb      	adds	r3, r7, #6
    161e:	8b92      	ldrh	r2, [r2, #28]
    1620:	801a      	strh	r2, [r3, #0]
		flags_run = flags &
				_usb_instances->device_enabled_callback_mask &
    1622:	4bb4      	ldr	r3, [pc, #720]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1624:	681a      	ldr	r2, [r3, #0]
    1626:	23ab      	movs	r3, #171	; 0xab
    1628:	005b      	lsls	r3, r3, #1
    162a:	5ad3      	ldrh	r3, [r2, r3]
		flags_run = flags &
    162c:	1dba      	adds	r2, r7, #6
    162e:	8812      	ldrh	r2, [r2, #0]
    1630:	4013      	ands	r3, r2
    1632:	b29a      	uxth	r2, r3
				_usb_instances->device_registered_callback_mask;
    1634:	4baf      	ldr	r3, [pc, #700]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1636:	6819      	ldr	r1, [r3, #0]
    1638:	23aa      	movs	r3, #170	; 0xaa
    163a:	005b      	lsls	r3, r3, #1
    163c:	5ac9      	ldrh	r1, [r1, r3]
		flags_run = flags &
    163e:	1d3b      	adds	r3, r7, #4
    1640:	400a      	ands	r2, r1
    1642:	801a      	strh	r2, [r3, #0]

		for (i = 0; i < USB_DEVICE_CALLBACK_N; i ++) {
    1644:	2300      	movs	r3, #0
    1646:	60fb      	str	r3, [r7, #12]
    1648:	e037      	b.n	16ba <_usb_device_interrupt_handler+0xc2>
			if (flags & _usb_device_irq_bits[i]) {
    164a:	4bab      	ldr	r3, [pc, #684]	; (18f8 <_usb_device_interrupt_handler+0x300>)
    164c:	68fa      	ldr	r2, [r7, #12]
    164e:	0052      	lsls	r2, r2, #1
    1650:	5ad3      	ldrh	r3, [r2, r3]
    1652:	1dba      	adds	r2, r7, #6
    1654:	8812      	ldrh	r2, [r2, #0]
    1656:	4013      	ands	r3, r2
    1658:	b29b      	uxth	r3, r3
    165a:	2b00      	cmp	r3, #0
    165c:	d007      	beq.n	166e <_usb_device_interrupt_handler+0x76>
				_usb_instances->hw->DEVICE.INTFLAG.reg =
    165e:	4ba5      	ldr	r3, [pc, #660]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1660:	681b      	ldr	r3, [r3, #0]
    1662:	681b      	ldr	r3, [r3, #0]
						_usb_device_irq_bits[i];
    1664:	4aa4      	ldr	r2, [pc, #656]	; (18f8 <_usb_device_interrupt_handler+0x300>)
    1666:	68f9      	ldr	r1, [r7, #12]
    1668:	0049      	lsls	r1, r1, #1
    166a:	5a8a      	ldrh	r2, [r1, r2]
				_usb_instances->hw->DEVICE.INTFLAG.reg =
    166c:	839a      	strh	r2, [r3, #28]
			}
			if (flags_run & _usb_device_irq_bits[i]) {
    166e:	4ba2      	ldr	r3, [pc, #648]	; (18f8 <_usb_device_interrupt_handler+0x300>)
    1670:	68fa      	ldr	r2, [r7, #12]
    1672:	0052      	lsls	r2, r2, #1
    1674:	5ad3      	ldrh	r3, [r2, r3]
    1676:	1d3a      	adds	r2, r7, #4
    1678:	8812      	ldrh	r2, [r2, #0]
    167a:	4013      	ands	r3, r2
    167c:	b29b      	uxth	r3, r3
    167e:	2b00      	cmp	r3, #0
    1680:	d018      	beq.n	16b4 <_usb_device_interrupt_handler+0xbc>
				if (i == USB_DEVICE_CALLBACK_LPMSUSP) {
    1682:	68fb      	ldr	r3, [r7, #12]
    1684:	2b06      	cmp	r3, #6
    1686:	d10a      	bne.n	169e <_usb_device_interrupt_handler+0xa6>
					device_callback_lpm_wakeup_enable =
							usb_descriptor_table.usb_endpoint_table[0].DeviceDescBank[0].EXTREG.bit.VARIABLE
    1688:	4b9c      	ldr	r3, [pc, #624]	; (18fc <_usb_device_interrupt_handler+0x304>)
    168a:	891b      	ldrh	r3, [r3, #8]
    168c:	045b      	lsls	r3, r3, #17
    168e:	0d5b      	lsrs	r3, r3, #21
    1690:	b29b      	uxth	r3, r3
							& USB_LPM_ATTRIBUT_REMOTEWAKE_MASK;
    1692:	001a      	movs	r2, r3
    1694:	2380      	movs	r3, #128	; 0x80
    1696:	005b      	lsls	r3, r3, #1
    1698:	401a      	ands	r2, r3
					device_callback_lpm_wakeup_enable =
    169a:	4b99      	ldr	r3, [pc, #612]	; (1900 <_usb_device_interrupt_handler+0x308>)
    169c:	601a      	str	r2, [r3, #0]
				}
				(_usb_instances->device_callback[i])(_usb_instances, &device_callback_lpm_wakeup_enable);
    169e:	4b95      	ldr	r3, [pc, #596]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    16a0:	681b      	ldr	r3, [r3, #0]
    16a2:	68fa      	ldr	r2, [r7, #12]
    16a4:	322e      	adds	r2, #46	; 0x2e
    16a6:	0092      	lsls	r2, r2, #2
    16a8:	58d2      	ldr	r2, [r2, r3]
    16aa:	4b92      	ldr	r3, [pc, #584]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    16ac:	681b      	ldr	r3, [r3, #0]
    16ae:	4994      	ldr	r1, [pc, #592]	; (1900 <_usb_device_interrupt_handler+0x308>)
    16b0:	0018      	movs	r0, r3
    16b2:	4790      	blx	r2
		for (i = 0; i < USB_DEVICE_CALLBACK_N; i ++) {
    16b4:	68fb      	ldr	r3, [r7, #12]
    16b6:	3301      	adds	r3, #1
    16b8:	60fb      	str	r3, [r7, #12]
    16ba:	68fb      	ldr	r3, [r7, #12]
    16bc:	2b06      	cmp	r3, #6
    16be:	ddc4      	ble.n	164a <_usb_device_interrupt_handler+0x52>
    16c0:	e250      	b.n	1b64 <_usb_device_interrupt_handler+0x56c>
		}

	} else {
		/* endpoint interrupt */

		for (uint8_t i = 0; i < USB_EPT_NUM; i++) {
    16c2:	230b      	movs	r3, #11
    16c4:	18fb      	adds	r3, r7, r3
    16c6:	2200      	movs	r2, #0
    16c8:	701a      	strb	r2, [r3, #0]
    16ca:	e23b      	b.n	1b44 <_usb_device_interrupt_handler+0x54c>

			if (ep_inst & (1 << i)) {
    16cc:	2308      	movs	r3, #8
    16ce:	18fb      	adds	r3, r7, r3
    16d0:	881a      	ldrh	r2, [r3, #0]
    16d2:	230b      	movs	r3, #11
    16d4:	18fb      	adds	r3, r7, r3
    16d6:	781b      	ldrb	r3, [r3, #0]
    16d8:	411a      	asrs	r2, r3
    16da:	0013      	movs	r3, r2
    16dc:	2201      	movs	r2, #1
    16de:	4013      	ands	r3, r2
    16e0:	d100      	bne.n	16e4 <_usb_device_interrupt_handler+0xec>
    16e2:	e228      	b.n	1b36 <_usb_device_interrupt_handler+0x53e>
				flags = _usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg;
    16e4:	4b83      	ldr	r3, [pc, #524]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    16e6:	681b      	ldr	r3, [r3, #0]
    16e8:	681a      	ldr	r2, [r3, #0]
    16ea:	230b      	movs	r3, #11
    16ec:	18fb      	adds	r3, r7, r3
    16ee:	781b      	ldrb	r3, [r3, #0]
    16f0:	3308      	adds	r3, #8
    16f2:	015b      	lsls	r3, r3, #5
    16f4:	18d3      	adds	r3, r2, r3
    16f6:	3307      	adds	r3, #7
    16f8:	781b      	ldrb	r3, [r3, #0]
    16fa:	b2da      	uxtb	r2, r3
    16fc:	1dbb      	adds	r3, r7, #6
    16fe:	801a      	strh	r2, [r3, #0]
				flags_run = flags &
						_usb_instances->device_endpoint_enabled_callback_mask[i] &
    1700:	4b7c      	ldr	r3, [pc, #496]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1702:	6819      	ldr	r1, [r3, #0]
    1704:	230b      	movs	r3, #11
    1706:	18fb      	adds	r3, r7, r3
    1708:	781a      	ldrb	r2, [r3, #0]
    170a:	23b0      	movs	r3, #176	; 0xb0
    170c:	005b      	lsls	r3, r3, #1
    170e:	188a      	adds	r2, r1, r2
    1710:	18d3      	adds	r3, r2, r3
    1712:	781b      	ldrb	r3, [r3, #0]
    1714:	b29b      	uxth	r3, r3
				flags_run = flags &
    1716:	1dba      	adds	r2, r7, #6
    1718:	8812      	ldrh	r2, [r2, #0]
    171a:	4013      	ands	r3, r2
    171c:	b29b      	uxth	r3, r3
    171e:	b21a      	sxth	r2, r3
						_usb_instances->device_endpoint_registered_callback_mask[i];
    1720:	4b74      	ldr	r3, [pc, #464]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1722:	6818      	ldr	r0, [r3, #0]
    1724:	230b      	movs	r3, #11
    1726:	18fb      	adds	r3, r7, r3
    1728:	7819      	ldrb	r1, [r3, #0]
    172a:	23ac      	movs	r3, #172	; 0xac
    172c:	005b      	lsls	r3, r3, #1
    172e:	1841      	adds	r1, r0, r1
    1730:	18cb      	adds	r3, r1, r3
    1732:	781b      	ldrb	r3, [r3, #0]
    1734:	b21b      	sxth	r3, r3
						_usb_instances->device_endpoint_enabled_callback_mask[i] &
    1736:	4013      	ands	r3, r2
    1738:	b21a      	sxth	r2, r3
				flags_run = flags &
    173a:	1d3b      	adds	r3, r7, #4
    173c:	801a      	strh	r2, [r3, #0]

				// endpoint transfer stall interrupt
				if (flags & USB_DEVICE_EPINTFLAG_STALL_Msk) {
    173e:	1dbb      	adds	r3, r7, #6
    1740:	881b      	ldrh	r3, [r3, #0]
    1742:	2260      	movs	r2, #96	; 0x60
    1744:	4013      	ands	r3, r2
    1746:	d05c      	beq.n	1802 <_usb_device_interrupt_handler+0x20a>
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL1) {
    1748:	4b6a      	ldr	r3, [pc, #424]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    174a:	681b      	ldr	r3, [r3, #0]
    174c:	681a      	ldr	r2, [r3, #0]
    174e:	230b      	movs	r3, #11
    1750:	18fb      	adds	r3, r7, r3
    1752:	781b      	ldrb	r3, [r3, #0]
    1754:	3308      	adds	r3, #8
    1756:	015b      	lsls	r3, r3, #5
    1758:	18d3      	adds	r3, r2, r3
    175a:	3307      	adds	r3, #7
    175c:	781b      	ldrb	r3, [r3, #0]
    175e:	b2db      	uxtb	r3, r3
    1760:	001a      	movs	r2, r3
    1762:	2340      	movs	r3, #64	; 0x40
    1764:	4013      	ands	r3, r2
    1766:	d015      	beq.n	1794 <_usb_device_interrupt_handler+0x19c>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL1;
    1768:	4b62      	ldr	r3, [pc, #392]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    176a:	681b      	ldr	r3, [r3, #0]
    176c:	681a      	ldr	r2, [r3, #0]
    176e:	230b      	movs	r3, #11
    1770:	18fb      	adds	r3, r7, r3
    1772:	781b      	ldrb	r3, [r3, #0]
    1774:	3308      	adds	r3, #8
    1776:	015b      	lsls	r3, r3, #5
    1778:	18d3      	adds	r3, r2, r3
    177a:	3307      	adds	r3, #7
    177c:	2240      	movs	r2, #64	; 0x40
    177e:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
    1780:	230b      	movs	r3, #11
    1782:	18fb      	adds	r3, r7, r3
    1784:	781b      	ldrb	r3, [r3, #0]
    1786:	2280      	movs	r2, #128	; 0x80
    1788:	4252      	negs	r2, r2
    178a:	4313      	orrs	r3, r2
    178c:	b2da      	uxtb	r2, r3
    178e:	4b5d      	ldr	r3, [pc, #372]	; (1904 <_usb_device_interrupt_handler+0x30c>)
    1790:	719a      	strb	r2, [r3, #6]
    1792:	e020      	b.n	17d6 <_usb_device_interrupt_handler+0x1de>
					} else if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_STALL0) {
    1794:	4b57      	ldr	r3, [pc, #348]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1796:	681b      	ldr	r3, [r3, #0]
    1798:	681a      	ldr	r2, [r3, #0]
    179a:	230b      	movs	r3, #11
    179c:	18fb      	adds	r3, r7, r3
    179e:	781b      	ldrb	r3, [r3, #0]
    17a0:	3308      	adds	r3, #8
    17a2:	015b      	lsls	r3, r3, #5
    17a4:	18d3      	adds	r3, r2, r3
    17a6:	3307      	adds	r3, #7
    17a8:	781b      	ldrb	r3, [r3, #0]
    17aa:	b2db      	uxtb	r3, r3
    17ac:	001a      	movs	r2, r3
    17ae:	2320      	movs	r3, #32
    17b0:	4013      	ands	r3, r2
    17b2:	d010      	beq.n	17d6 <_usb_device_interrupt_handler+0x1de>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL0;
    17b4:	4b4f      	ldr	r3, [pc, #316]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    17b6:	681b      	ldr	r3, [r3, #0]
    17b8:	681a      	ldr	r2, [r3, #0]
    17ba:	230b      	movs	r3, #11
    17bc:	18fb      	adds	r3, r7, r3
    17be:	781b      	ldrb	r3, [r3, #0]
    17c0:	3308      	adds	r3, #8
    17c2:	015b      	lsls	r3, r3, #5
    17c4:	18d3      	adds	r3, r2, r3
    17c6:	3307      	adds	r3, #7
    17c8:	2220      	movs	r2, #32
    17ca:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
    17cc:	4b4d      	ldr	r3, [pc, #308]	; (1904 <_usb_device_interrupt_handler+0x30c>)
    17ce:	220b      	movs	r2, #11
    17d0:	18ba      	adds	r2, r7, r2
    17d2:	7812      	ldrb	r2, [r2, #0]
    17d4:	719a      	strb	r2, [r3, #6]
					}

					if (flags_run & USB_DEVICE_EPINTFLAG_STALL_Msk) {
    17d6:	1d3b      	adds	r3, r7, #4
    17d8:	881b      	ldrh	r3, [r3, #0]
    17da:	2260      	movs	r2, #96	; 0x60
    17dc:	4013      	ands	r3, r2
    17de:	d100      	bne.n	17e2 <_usb_device_interrupt_handler+0x1ea>
    17e0:	e1b7      	b.n	1b52 <_usb_device_interrupt_handler+0x55a>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_STALL])(_usb_instances,&ep_callback_para);
    17e2:	4b44      	ldr	r3, [pc, #272]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    17e4:	681a      	ldr	r2, [r3, #0]
    17e6:	230b      	movs	r3, #11
    17e8:	18fb      	adds	r3, r7, r3
    17ea:	781b      	ldrb	r3, [r3, #0]
    17ec:	21e0      	movs	r1, #224	; 0xe0
    17ee:	011b      	lsls	r3, r3, #4
    17f0:	18d3      	adds	r3, r2, r3
    17f2:	185b      	adds	r3, r3, r1
    17f4:	681a      	ldr	r2, [r3, #0]
    17f6:	4b3f      	ldr	r3, [pc, #252]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    17f8:	681b      	ldr	r3, [r3, #0]
    17fa:	4942      	ldr	r1, [pc, #264]	; (1904 <_usb_device_interrupt_handler+0x30c>)
    17fc:	0018      	movs	r0, r3
    17fe:	4790      	blx	r2
					}
					return;
    1800:	e1a7      	b.n	1b52 <_usb_device_interrupt_handler+0x55a>
				}

				// endpoint received setup interrupt
				if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    1802:	1dbb      	adds	r3, r7, #6
    1804:	881b      	ldrh	r3, [r3, #0]
    1806:	2210      	movs	r2, #16
    1808:	4013      	ands	r3, r2
    180a:	d038      	beq.n	187e <_usb_device_interrupt_handler+0x286>
					_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP;
    180c:	4b39      	ldr	r3, [pc, #228]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    180e:	681b      	ldr	r3, [r3, #0]
    1810:	681a      	ldr	r2, [r3, #0]
    1812:	230b      	movs	r3, #11
    1814:	18fb      	adds	r3, r7, r3
    1816:	781b      	ldrb	r3, [r3, #0]
    1818:	3308      	adds	r3, #8
    181a:	015b      	lsls	r3, r3, #5
    181c:	18d3      	adds	r3, r2, r3
    181e:	3307      	adds	r3, #7
    1820:	2210      	movs	r2, #16
    1822:	701a      	strb	r2, [r3, #0]
					if(_usb_instances->device_endpoint_enabled_callback_mask[i] & _usb_endpoint_irq_bits[USB_DEVICE_ENDPOINT_CALLBACK_RXSTP]) {
    1824:	4b33      	ldr	r3, [pc, #204]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1826:	6819      	ldr	r1, [r3, #0]
    1828:	230b      	movs	r3, #11
    182a:	18fb      	adds	r3, r7, r3
    182c:	781a      	ldrb	r2, [r3, #0]
    182e:	23b0      	movs	r3, #176	; 0xb0
    1830:	005b      	lsls	r3, r3, #1
    1832:	188a      	adds	r2, r1, r2
    1834:	18d3      	adds	r3, r2, r3
    1836:	781b      	ldrb	r3, [r3, #0]
    1838:	2210      	movs	r2, #16
    183a:	4013      	ands	r3, r2
    183c:	b2db      	uxtb	r3, r3
    183e:	2b00      	cmp	r3, #0
    1840:	d100      	bne.n	1844 <_usb_device_interrupt_handler+0x24c>
    1842:	e188      	b.n	1b56 <_usb_device_interrupt_handler+0x55e>
						ep_callback_para.received_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT);
    1844:	230b      	movs	r3, #11
    1846:	18fb      	adds	r3, r7, r3
    1848:	781b      	ldrb	r3, [r3, #0]
    184a:	4a2c      	ldr	r2, [pc, #176]	; (18fc <_usb_device_interrupt_handler+0x304>)
    184c:	015b      	lsls	r3, r3, #5
    184e:	18d3      	adds	r3, r2, r3
    1850:	685b      	ldr	r3, [r3, #4]
    1852:	049b      	lsls	r3, r3, #18
    1854:	0c9b      	lsrs	r3, r3, #18
    1856:	b29b      	uxth	r3, r3
    1858:	001a      	movs	r2, r3
    185a:	4b2a      	ldr	r3, [pc, #168]	; (1904 <_usb_device_interrupt_handler+0x30c>)
    185c:	801a      	strh	r2, [r3, #0]
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_RXSTP])(_usb_instances,&ep_callback_para);
    185e:	4b25      	ldr	r3, [pc, #148]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1860:	681a      	ldr	r2, [r3, #0]
    1862:	230b      	movs	r3, #11
    1864:	18fb      	adds	r3, r7, r3
    1866:	781b      	ldrb	r3, [r3, #0]
    1868:	21dc      	movs	r1, #220	; 0xdc
    186a:	011b      	lsls	r3, r3, #4
    186c:	18d3      	adds	r3, r2, r3
    186e:	185b      	adds	r3, r3, r1
    1870:	681a      	ldr	r2, [r3, #0]
    1872:	4b20      	ldr	r3, [pc, #128]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    1874:	681b      	ldr	r3, [r3, #0]
    1876:	4923      	ldr	r1, [pc, #140]	; (1904 <_usb_device_interrupt_handler+0x30c>)
    1878:	0018      	movs	r0, r3
    187a:	4790      	blx	r2
					}
					return;
    187c:	e16b      	b.n	1b56 <_usb_device_interrupt_handler+0x55e>
				}

				// endpoint transfer complete interrupt
				if (flags & USB_DEVICE_EPINTFLAG_TRCPT_Msk) {
    187e:	1dbb      	adds	r3, r7, #6
    1880:	881b      	ldrh	r3, [r3, #0]
    1882:	2203      	movs	r2, #3
    1884:	4013      	ands	r3, r2
    1886:	d100      	bne.n	188a <_usb_device_interrupt_handler+0x292>
    1888:	e08f      	b.n	19aa <_usb_device_interrupt_handler+0x3b2>
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT1) {
    188a:	4b1a      	ldr	r3, [pc, #104]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    188c:	681b      	ldr	r3, [r3, #0]
    188e:	681a      	ldr	r2, [r3, #0]
    1890:	230b      	movs	r3, #11
    1892:	18fb      	adds	r3, r7, r3
    1894:	781b      	ldrb	r3, [r3, #0]
    1896:	3308      	adds	r3, #8
    1898:	015b      	lsls	r3, r3, #5
    189a:	18d3      	adds	r3, r2, r3
    189c:	3307      	adds	r3, #7
    189e:	781b      	ldrb	r3, [r3, #0]
    18a0:	b2db      	uxtb	r3, r3
    18a2:	001a      	movs	r2, r3
    18a4:	2302      	movs	r3, #2
    18a6:	4013      	ands	r3, r2
    18a8:	d02e      	beq.n	1908 <_usb_device_interrupt_handler+0x310>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT1;
    18aa:	4b12      	ldr	r3, [pc, #72]	; (18f4 <_usb_device_interrupt_handler+0x2fc>)
    18ac:	681b      	ldr	r3, [r3, #0]
    18ae:	681a      	ldr	r2, [r3, #0]
    18b0:	230b      	movs	r3, #11
    18b2:	18fb      	adds	r3, r7, r3
    18b4:	781b      	ldrb	r3, [r3, #0]
    18b6:	3308      	adds	r3, #8
    18b8:	015b      	lsls	r3, r3, #5
    18ba:	18d3      	adds	r3, r2, r3
    18bc:	3307      	adds	r3, #7
    18be:	2202      	movs	r2, #2
    18c0:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
    18c2:	230b      	movs	r3, #11
    18c4:	18fb      	adds	r3, r7, r3
    18c6:	781b      	ldrb	r3, [r3, #0]
    18c8:	2280      	movs	r2, #128	; 0x80
    18ca:	4252      	negs	r2, r2
    18cc:	4313      	orrs	r3, r2
    18ce:	b2da      	uxtb	r2, r3
    18d0:	4b0c      	ldr	r3, [pc, #48]	; (1904 <_usb_device_interrupt_handler+0x30c>)
    18d2:	719a      	strb	r2, [r3, #6]
						ep_callback_para.sent_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT);
    18d4:	230b      	movs	r3, #11
    18d6:	18fb      	adds	r3, r7, r3
    18d8:	781b      	ldrb	r3, [r3, #0]
    18da:	4a08      	ldr	r2, [pc, #32]	; (18fc <_usb_device_interrupt_handler+0x304>)
    18dc:	015b      	lsls	r3, r3, #5
    18de:	18d3      	adds	r3, r2, r3
    18e0:	3310      	adds	r3, #16
    18e2:	685b      	ldr	r3, [r3, #4]
    18e4:	049b      	lsls	r3, r3, #18
    18e6:	0c9b      	lsrs	r3, r3, #18
    18e8:	b29b      	uxth	r3, r3
    18ea:	001a      	movs	r2, r3
    18ec:	4b05      	ldr	r3, [pc, #20]	; (1904 <_usb_device_interrupt_handler+0x30c>)
    18ee:	805a      	strh	r2, [r3, #2]
    18f0:	e045      	b.n	197e <_usb_device_interrupt_handler+0x386>
    18f2:	46c0      	nop			; (mov r8, r8)
    18f4:	2000011c 	.word	0x2000011c
    18f8:	0000463c 	.word	0x0000463c
    18fc:	200001dc 	.word	0x200001dc
    1900:	20000128 	.word	0x20000128
    1904:	2000012c 	.word	0x2000012c

					} else if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT0) {
    1908:	4b98      	ldr	r3, [pc, #608]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    190a:	681b      	ldr	r3, [r3, #0]
    190c:	681a      	ldr	r2, [r3, #0]
    190e:	230b      	movs	r3, #11
    1910:	18fb      	adds	r3, r7, r3
    1912:	781b      	ldrb	r3, [r3, #0]
    1914:	3308      	adds	r3, #8
    1916:	015b      	lsls	r3, r3, #5
    1918:	18d3      	adds	r3, r2, r3
    191a:	3307      	adds	r3, #7
    191c:	781b      	ldrb	r3, [r3, #0]
    191e:	b2db      	uxtb	r3, r3
    1920:	001a      	movs	r2, r3
    1922:	2301      	movs	r3, #1
    1924:	4013      	ands	r3, r2
    1926:	d02a      	beq.n	197e <_usb_device_interrupt_handler+0x386>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT0;
    1928:	4b90      	ldr	r3, [pc, #576]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    192a:	681b      	ldr	r3, [r3, #0]
    192c:	681a      	ldr	r2, [r3, #0]
    192e:	230b      	movs	r3, #11
    1930:	18fb      	adds	r3, r7, r3
    1932:	781b      	ldrb	r3, [r3, #0]
    1934:	3308      	adds	r3, #8
    1936:	015b      	lsls	r3, r3, #5
    1938:	18d3      	adds	r3, r2, r3
    193a:	3307      	adds	r3, #7
    193c:	2201      	movs	r2, #1
    193e:	701a      	strb	r2, [r3, #0]
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
    1940:	4b8b      	ldr	r3, [pc, #556]	; (1b70 <_usb_device_interrupt_handler+0x578>)
    1942:	220b      	movs	r2, #11
    1944:	18ba      	adds	r2, r7, r2
    1946:	7812      	ldrb	r2, [r2, #0]
    1948:	719a      	strb	r2, [r3, #6]
						ep_callback_para.received_bytes = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT);
    194a:	230b      	movs	r3, #11
    194c:	18fb      	adds	r3, r7, r3
    194e:	781b      	ldrb	r3, [r3, #0]
    1950:	4a88      	ldr	r2, [pc, #544]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    1952:	015b      	lsls	r3, r3, #5
    1954:	18d3      	adds	r3, r2, r3
    1956:	685b      	ldr	r3, [r3, #4]
    1958:	049b      	lsls	r3, r3, #18
    195a:	0c9b      	lsrs	r3, r3, #18
    195c:	b29b      	uxth	r3, r3
    195e:	001a      	movs	r2, r3
    1960:	4b83      	ldr	r3, [pc, #524]	; (1b70 <_usb_device_interrupt_handler+0x578>)
    1962:	801a      	strh	r2, [r3, #0]
						ep_callback_para.out_buffer_size = (uint16_t)(usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE);
    1964:	230b      	movs	r3, #11
    1966:	18fb      	adds	r3, r7, r3
    1968:	781b      	ldrb	r3, [r3, #0]
    196a:	4a82      	ldr	r2, [pc, #520]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    196c:	015b      	lsls	r3, r3, #5
    196e:	18d3      	adds	r3, r2, r3
    1970:	685b      	ldr	r3, [r3, #4]
    1972:	011b      	lsls	r3, r3, #4
    1974:	0c9b      	lsrs	r3, r3, #18
    1976:	b29b      	uxth	r3, r3
    1978:	001a      	movs	r2, r3
    197a:	4b7d      	ldr	r3, [pc, #500]	; (1b70 <_usb_device_interrupt_handler+0x578>)
    197c:	809a      	strh	r2, [r3, #4]
					}
					if(flags_run & USB_DEVICE_EPINTFLAG_TRCPT_Msk) {
    197e:	1d3b      	adds	r3, r7, #4
    1980:	881b      	ldrh	r3, [r3, #0]
    1982:	2203      	movs	r2, #3
    1984:	4013      	ands	r3, r2
    1986:	d100      	bne.n	198a <_usb_device_interrupt_handler+0x392>
    1988:	e0e7      	b.n	1b5a <_usb_device_interrupt_handler+0x562>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRCPT])(_usb_instances,&ep_callback_para);
    198a:	4b78      	ldr	r3, [pc, #480]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    198c:	681a      	ldr	r2, [r3, #0]
    198e:	230b      	movs	r3, #11
    1990:	18fb      	adds	r3, r7, r3
    1992:	781b      	ldrb	r3, [r3, #0]
    1994:	330d      	adds	r3, #13
    1996:	011b      	lsls	r3, r3, #4
    1998:	18d3      	adds	r3, r2, r3
    199a:	3304      	adds	r3, #4
    199c:	681a      	ldr	r2, [r3, #0]
    199e:	4b73      	ldr	r3, [pc, #460]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    19a0:	681b      	ldr	r3, [r3, #0]
    19a2:	4973      	ldr	r1, [pc, #460]	; (1b70 <_usb_device_interrupt_handler+0x578>)
    19a4:	0018      	movs	r0, r3
    19a6:	4790      	blx	r2
					}
					return;
    19a8:	e0d7      	b.n	1b5a <_usb_device_interrupt_handler+0x562>
				}

				// endpoint transfer fail interrupt
				if (flags & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
    19aa:	1dbb      	adds	r3, r7, #6
    19ac:	881b      	ldrh	r3, [r3, #0]
    19ae:	220c      	movs	r2, #12
    19b0:	4013      	ands	r3, r2
    19b2:	d100      	bne.n	19b6 <_usb_device_interrupt_handler+0x3be>
    19b4:	e0bf      	b.n	1b36 <_usb_device_interrupt_handler+0x53e>
					if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    19b6:	4b6d      	ldr	r3, [pc, #436]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    19b8:	681b      	ldr	r3, [r3, #0]
    19ba:	681a      	ldr	r2, [r3, #0]
    19bc:	230b      	movs	r3, #11
    19be:	18fb      	adds	r3, r7, r3
    19c0:	781b      	ldrb	r3, [r3, #0]
    19c2:	3308      	adds	r3, #8
    19c4:	015b      	lsls	r3, r3, #5
    19c6:	18d3      	adds	r3, r2, r3
    19c8:	3307      	adds	r3, #7
    19ca:	781b      	ldrb	r3, [r3, #0]
    19cc:	b2db      	uxtb	r3, r3
    19ce:	001a      	movs	r2, r3
    19d0:	2308      	movs	r3, #8
    19d2:	4013      	ands	r3, r2
    19d4:	d047      	beq.n	1a66 <_usb_device_interrupt_handler+0x46e>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRFAIL1;
    19d6:	4b65      	ldr	r3, [pc, #404]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    19d8:	681b      	ldr	r3, [r3, #0]
    19da:	681a      	ldr	r2, [r3, #0]
    19dc:	230b      	movs	r3, #11
    19de:	18fb      	adds	r3, r7, r3
    19e0:	781b      	ldrb	r3, [r3, #0]
    19e2:	3308      	adds	r3, #8
    19e4:	015b      	lsls	r3, r3, #5
    19e6:	18d3      	adds	r3, r2, r3
    19e8:	3307      	adds	r3, #7
    19ea:	2208      	movs	r2, #8
    19ec:	701a      	strb	r2, [r3, #0]
						if (usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].STATUS_BK.reg & USB_DEVICE_STATUS_BK_ERRORFLOW) {
    19ee:	230b      	movs	r3, #11
    19f0:	18fb      	adds	r3, r7, r3
    19f2:	781b      	ldrb	r3, [r3, #0]
    19f4:	4a5f      	ldr	r2, [pc, #380]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    19f6:	015b      	lsls	r3, r3, #5
    19f8:	18d3      	adds	r3, r2, r3
    19fa:	331a      	adds	r3, #26
    19fc:	781b      	ldrb	r3, [r3, #0]
    19fe:	b2db      	uxtb	r3, r3
    1a00:	001a      	movs	r2, r3
    1a02:	2302      	movs	r3, #2
    1a04:	4013      	ands	r3, r2
    1a06:	d014      	beq.n	1a32 <_usb_device_interrupt_handler+0x43a>
							usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[1].STATUS_BK.reg &= ~USB_DEVICE_STATUS_BK_ERRORFLOW;
    1a08:	230b      	movs	r3, #11
    1a0a:	18fb      	adds	r3, r7, r3
    1a0c:	781b      	ldrb	r3, [r3, #0]
    1a0e:	220b      	movs	r2, #11
    1a10:	18ba      	adds	r2, r7, r2
    1a12:	7812      	ldrb	r2, [r2, #0]
    1a14:	4957      	ldr	r1, [pc, #348]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    1a16:	0152      	lsls	r2, r2, #5
    1a18:	188a      	adds	r2, r1, r2
    1a1a:	321a      	adds	r2, #26
    1a1c:	7812      	ldrb	r2, [r2, #0]
    1a1e:	b2d2      	uxtb	r2, r2
    1a20:	2102      	movs	r1, #2
    1a22:	438a      	bics	r2, r1
    1a24:	b2d1      	uxtb	r1, r2
    1a26:	4a53      	ldr	r2, [pc, #332]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    1a28:	015b      	lsls	r3, r3, #5
    1a2a:	18d3      	adds	r3, r2, r3
    1a2c:	331a      	adds	r3, #26
    1a2e:	1c0a      	adds	r2, r1, #0
    1a30:	701a      	strb	r2, [r3, #0]
						}
						ep_callback_para.endpoint_address = USB_EP_DIR_IN | i;
    1a32:	230b      	movs	r3, #11
    1a34:	18fb      	adds	r3, r7, r3
    1a36:	781b      	ldrb	r3, [r3, #0]
    1a38:	2280      	movs	r2, #128	; 0x80
    1a3a:	4252      	negs	r2, r2
    1a3c:	4313      	orrs	r3, r2
    1a3e:	b2da      	uxtb	r2, r3
    1a40:	4b4b      	ldr	r3, [pc, #300]	; (1b70 <_usb_device_interrupt_handler+0x578>)
    1a42:	719a      	strb	r2, [r3, #6]
						if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT1) {
    1a44:	4b49      	ldr	r3, [pc, #292]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    1a46:	681b      	ldr	r3, [r3, #0]
    1a48:	681a      	ldr	r2, [r3, #0]
    1a4a:	230b      	movs	r3, #11
    1a4c:	18fb      	adds	r3, r7, r3
    1a4e:	781b      	ldrb	r3, [r3, #0]
    1a50:	3308      	adds	r3, #8
    1a52:	015b      	lsls	r3, r3, #5
    1a54:	18d3      	adds	r3, r2, r3
    1a56:	3307      	adds	r3, #7
    1a58:	781b      	ldrb	r3, [r3, #0]
    1a5a:	b2db      	uxtb	r3, r3
    1a5c:	001a      	movs	r2, r3
    1a5e:	2302      	movs	r3, #2
    1a60:	4013      	ands	r3, r2
    1a62:	d053      	beq.n	1b0c <_usb_device_interrupt_handler+0x514>
							return;
    1a64:	e07e      	b.n	1b64 <_usb_device_interrupt_handler+0x56c>
						}
					} else if(_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    1a66:	4b41      	ldr	r3, [pc, #260]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    1a68:	681b      	ldr	r3, [r3, #0]
    1a6a:	681a      	ldr	r2, [r3, #0]
    1a6c:	230b      	movs	r3, #11
    1a6e:	18fb      	adds	r3, r7, r3
    1a70:	781b      	ldrb	r3, [r3, #0]
    1a72:	3308      	adds	r3, #8
    1a74:	015b      	lsls	r3, r3, #5
    1a76:	18d3      	adds	r3, r2, r3
    1a78:	3307      	adds	r3, #7
    1a7a:	781b      	ldrb	r3, [r3, #0]
    1a7c:	b2db      	uxtb	r3, r3
    1a7e:	001a      	movs	r2, r3
    1a80:	2304      	movs	r3, #4
    1a82:	4013      	ands	r3, r2
    1a84:	d042      	beq.n	1b0c <_usb_device_interrupt_handler+0x514>
						_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRFAIL0;
    1a86:	4b39      	ldr	r3, [pc, #228]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    1a88:	681b      	ldr	r3, [r3, #0]
    1a8a:	681a      	ldr	r2, [r3, #0]
    1a8c:	230b      	movs	r3, #11
    1a8e:	18fb      	adds	r3, r7, r3
    1a90:	781b      	ldrb	r3, [r3, #0]
    1a92:	3308      	adds	r3, #8
    1a94:	015b      	lsls	r3, r3, #5
    1a96:	18d3      	adds	r3, r2, r3
    1a98:	3307      	adds	r3, #7
    1a9a:	2204      	movs	r2, #4
    1a9c:	701a      	strb	r2, [r3, #0]
						if (usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg & USB_DEVICE_STATUS_BK_ERRORFLOW) {
    1a9e:	230b      	movs	r3, #11
    1aa0:	18fb      	adds	r3, r7, r3
    1aa2:	781b      	ldrb	r3, [r3, #0]
    1aa4:	4a33      	ldr	r2, [pc, #204]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    1aa6:	015b      	lsls	r3, r3, #5
    1aa8:	18d3      	adds	r3, r2, r3
    1aaa:	330a      	adds	r3, #10
    1aac:	781b      	ldrb	r3, [r3, #0]
    1aae:	b2db      	uxtb	r3, r3
    1ab0:	001a      	movs	r2, r3
    1ab2:	2302      	movs	r3, #2
    1ab4:	4013      	ands	r3, r2
    1ab6:	d014      	beq.n	1ae2 <_usb_device_interrupt_handler+0x4ea>
							usb_descriptor_table.usb_endpoint_table[i].DeviceDescBank[0].STATUS_BK.reg &= ~USB_DEVICE_STATUS_BK_ERRORFLOW;
    1ab8:	230b      	movs	r3, #11
    1aba:	18fb      	adds	r3, r7, r3
    1abc:	781b      	ldrb	r3, [r3, #0]
    1abe:	220b      	movs	r2, #11
    1ac0:	18ba      	adds	r2, r7, r2
    1ac2:	7812      	ldrb	r2, [r2, #0]
    1ac4:	492b      	ldr	r1, [pc, #172]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    1ac6:	0152      	lsls	r2, r2, #5
    1ac8:	188a      	adds	r2, r1, r2
    1aca:	320a      	adds	r2, #10
    1acc:	7812      	ldrb	r2, [r2, #0]
    1ace:	b2d2      	uxtb	r2, r2
    1ad0:	2102      	movs	r1, #2
    1ad2:	438a      	bics	r2, r1
    1ad4:	b2d1      	uxtb	r1, r2
    1ad6:	4a27      	ldr	r2, [pc, #156]	; (1b74 <_usb_device_interrupt_handler+0x57c>)
    1ad8:	015b      	lsls	r3, r3, #5
    1ada:	18d3      	adds	r3, r2, r3
    1adc:	330a      	adds	r3, #10
    1ade:	1c0a      	adds	r2, r1, #0
    1ae0:	701a      	strb	r2, [r3, #0]
						}
						ep_callback_para.endpoint_address = USB_EP_DIR_OUT | i;
    1ae2:	4b23      	ldr	r3, [pc, #140]	; (1b70 <_usb_device_interrupt_handler+0x578>)
    1ae4:	220b      	movs	r2, #11
    1ae6:	18ba      	adds	r2, r7, r2
    1ae8:	7812      	ldrb	r2, [r2, #0]
    1aea:	719a      	strb	r2, [r3, #6]
						if (_usb_instances->hw->DEVICE.DeviceEndpoint[i].EPINTFLAG.reg & USB_DEVICE_EPINTFLAG_TRCPT0) {
    1aec:	4b1f      	ldr	r3, [pc, #124]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    1aee:	681b      	ldr	r3, [r3, #0]
    1af0:	681a      	ldr	r2, [r3, #0]
    1af2:	230b      	movs	r3, #11
    1af4:	18fb      	adds	r3, r7, r3
    1af6:	781b      	ldrb	r3, [r3, #0]
    1af8:	3308      	adds	r3, #8
    1afa:	015b      	lsls	r3, r3, #5
    1afc:	18d3      	adds	r3, r2, r3
    1afe:	3307      	adds	r3, #7
    1b00:	781b      	ldrb	r3, [r3, #0]
    1b02:	b2db      	uxtb	r3, r3
    1b04:	001a      	movs	r2, r3
    1b06:	2301      	movs	r3, #1
    1b08:	4013      	ands	r3, r2
    1b0a:	d128      	bne.n	1b5e <_usb_device_interrupt_handler+0x566>
							return;
						}
					}

					if(flags_run & USB_DEVICE_EPINTFLAG_TRFAIL_Msk) {
    1b0c:	1d3b      	adds	r3, r7, #4
    1b0e:	881b      	ldrh	r3, [r3, #0]
    1b10:	220c      	movs	r2, #12
    1b12:	4013      	ands	r3, r2
    1b14:	d025      	beq.n	1b62 <_usb_device_interrupt_handler+0x56a>
						(_usb_instances->device_endpoint_callback[i][USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL])(_usb_instances,&ep_callback_para);
    1b16:	4b15      	ldr	r3, [pc, #84]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    1b18:	681a      	ldr	r2, [r3, #0]
    1b1a:	230b      	movs	r3, #11
    1b1c:	18fb      	adds	r3, r7, r3
    1b1e:	781b      	ldrb	r3, [r3, #0]
    1b20:	21d8      	movs	r1, #216	; 0xd8
    1b22:	011b      	lsls	r3, r3, #4
    1b24:	18d3      	adds	r3, r2, r3
    1b26:	185b      	adds	r3, r3, r1
    1b28:	681a      	ldr	r2, [r3, #0]
    1b2a:	4b10      	ldr	r3, [pc, #64]	; (1b6c <_usb_device_interrupt_handler+0x574>)
    1b2c:	681b      	ldr	r3, [r3, #0]
    1b2e:	4910      	ldr	r1, [pc, #64]	; (1b70 <_usb_device_interrupt_handler+0x578>)
    1b30:	0018      	movs	r0, r3
    1b32:	4790      	blx	r2
					}
					return;
    1b34:	e015      	b.n	1b62 <_usb_device_interrupt_handler+0x56a>
		for (uint8_t i = 0; i < USB_EPT_NUM; i++) {
    1b36:	230b      	movs	r3, #11
    1b38:	18fb      	adds	r3, r7, r3
    1b3a:	781a      	ldrb	r2, [r3, #0]
    1b3c:	230b      	movs	r3, #11
    1b3e:	18fb      	adds	r3, r7, r3
    1b40:	3201      	adds	r2, #1
    1b42:	701a      	strb	r2, [r3, #0]
    1b44:	230b      	movs	r3, #11
    1b46:	18fb      	adds	r3, r7, r3
    1b48:	781b      	ldrb	r3, [r3, #0]
    1b4a:	2b07      	cmp	r3, #7
    1b4c:	d800      	bhi.n	1b50 <_usb_device_interrupt_handler+0x558>
    1b4e:	e5bd      	b.n	16cc <_usb_device_interrupt_handler+0xd4>
    1b50:	e008      	b.n	1b64 <_usb_device_interrupt_handler+0x56c>
					return;
    1b52:	46c0      	nop			; (mov r8, r8)
    1b54:	e006      	b.n	1b64 <_usb_device_interrupt_handler+0x56c>
					return;
    1b56:	46c0      	nop			; (mov r8, r8)
    1b58:	e004      	b.n	1b64 <_usb_device_interrupt_handler+0x56c>
					return;
    1b5a:	46c0      	nop			; (mov r8, r8)
    1b5c:	e002      	b.n	1b64 <_usb_device_interrupt_handler+0x56c>
							return;
    1b5e:	46c0      	nop			; (mov r8, r8)
    1b60:	e000      	b.n	1b64 <_usb_device_interrupt_handler+0x56c>
					return;
    1b62:	46c0      	nop			; (mov r8, r8)
				}
			}
		}
	}
}
    1b64:	46bd      	mov	sp, r7
    1b66:	b004      	add	sp, #16
    1b68:	bd80      	pop	{r7, pc}
    1b6a:	46c0      	nop			; (mov r8, r8)
    1b6c:	2000011c 	.word	0x2000011c
    1b70:	2000012c 	.word	0x2000012c
    1b74:	200001dc 	.word	0x200001dc

00001b78 <USB_Handler>:

/**
 * \brief Interrupt handler for the USB module.
 */
void USB_Handler(void)
{
    1b78:	b580      	push	{r7, lr}
    1b7a:	af00      	add	r7, sp, #0
	if (_usb_instances->hw->DEVICE.CTRLA.bit.MODE) {
    1b7c:	4b08      	ldr	r3, [pc, #32]	; (1ba0 <USB_Handler+0x28>)
    1b7e:	681b      	ldr	r3, [r3, #0]
    1b80:	681b      	ldr	r3, [r3, #0]
    1b82:	781b      	ldrb	r3, [r3, #0]
    1b84:	061b      	lsls	r3, r3, #24
    1b86:	0fdb      	lsrs	r3, r3, #31
    1b88:	b2db      	uxtb	r3, r3
    1b8a:	2b00      	cmp	r3, #0
    1b8c:	d002      	beq.n	1b94 <USB_Handler+0x1c>
#if !SAMD11
		/*host mode ISR */
		_usb_host_interrupt_handler();
    1b8e:	4b05      	ldr	r3, [pc, #20]	; (1ba4 <USB_Handler+0x2c>)
    1b90:	4798      	blx	r3
#endif
	} else {
		/*device mode ISR */
		_usb_device_interrupt_handler();
	}
}
    1b92:	e001      	b.n	1b98 <USB_Handler+0x20>
		_usb_device_interrupt_handler();
    1b94:	4b04      	ldr	r3, [pc, #16]	; (1ba8 <USB_Handler+0x30>)
    1b96:	4798      	blx	r3
}
    1b98:	46c0      	nop			; (mov r8, r8)
    1b9a:	46bd      	mov	sp, r7
    1b9c:	bd80      	pop	{r7, pc}
    1b9e:	46c0      	nop			; (mov r8, r8)
    1ba0:	2000011c 	.word	0x2000011c
    1ba4:	00000f7d 	.word	0x00000f7d
    1ba8:	000015f9 	.word	0x000015f9

00001bac <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    1bac:	b580      	push	{r7, lr}
    1bae:	af00      	add	r7, sp, #0
    1bb0:	4b03      	ldr	r3, [pc, #12]	; (1bc0 <SERCOM0_Handler+0x14>)
    1bb2:	681b      	ldr	r3, [r3, #0]
    1bb4:	2000      	movs	r0, #0
    1bb6:	4798      	blx	r3
    1bb8:	46c0      	nop			; (mov r8, r8)
    1bba:	46bd      	mov	sp, r7
    1bbc:	bd80      	pop	{r7, pc}
    1bbe:	46c0      	nop			; (mov r8, r8)
    1bc0:	20000138 	.word	0x20000138

00001bc4 <SERCOM1_Handler>:
    1bc4:	b580      	push	{r7, lr}
    1bc6:	af00      	add	r7, sp, #0
    1bc8:	4b03      	ldr	r3, [pc, #12]	; (1bd8 <SERCOM1_Handler+0x14>)
    1bca:	685b      	ldr	r3, [r3, #4]
    1bcc:	2001      	movs	r0, #1
    1bce:	4798      	blx	r3
    1bd0:	46c0      	nop			; (mov r8, r8)
    1bd2:	46bd      	mov	sp, r7
    1bd4:	bd80      	pop	{r7, pc}
    1bd6:	46c0      	nop			; (mov r8, r8)
    1bd8:	20000138 	.word	0x20000138

00001bdc <SERCOM2_Handler>:
    1bdc:	b580      	push	{r7, lr}
    1bde:	af00      	add	r7, sp, #0
    1be0:	4b03      	ldr	r3, [pc, #12]	; (1bf0 <SERCOM2_Handler+0x14>)
    1be2:	689b      	ldr	r3, [r3, #8]
    1be4:	2002      	movs	r0, #2
    1be6:	4798      	blx	r3
    1be8:	46c0      	nop			; (mov r8, r8)
    1bea:	46bd      	mov	sp, r7
    1bec:	bd80      	pop	{r7, pc}
    1bee:	46c0      	nop			; (mov r8, r8)
    1bf0:	20000138 	.word	0x20000138

00001bf4 <SERCOM3_Handler>:
    1bf4:	b580      	push	{r7, lr}
    1bf6:	af00      	add	r7, sp, #0
    1bf8:	4b03      	ldr	r3, [pc, #12]	; (1c08 <SERCOM3_Handler+0x14>)
    1bfa:	68db      	ldr	r3, [r3, #12]
    1bfc:	2003      	movs	r0, #3
    1bfe:	4798      	blx	r3
    1c00:	46c0      	nop			; (mov r8, r8)
    1c02:	46bd      	mov	sp, r7
    1c04:	bd80      	pop	{r7, pc}
    1c06:	46c0      	nop			; (mov r8, r8)
    1c08:	20000138 	.word	0x20000138

00001c0c <SERCOM4_Handler>:
    1c0c:	b580      	push	{r7, lr}
    1c0e:	af00      	add	r7, sp, #0
    1c10:	4b03      	ldr	r3, [pc, #12]	; (1c20 <SERCOM4_Handler+0x14>)
    1c12:	691b      	ldr	r3, [r3, #16]
    1c14:	2004      	movs	r0, #4
    1c16:	4798      	blx	r3
    1c18:	46c0      	nop			; (mov r8, r8)
    1c1a:	46bd      	mov	sp, r7
    1c1c:	bd80      	pop	{r7, pc}
    1c1e:	46c0      	nop			; (mov r8, r8)
    1c20:	20000138 	.word	0x20000138

00001c24 <SERCOM5_Handler>:
    1c24:	b580      	push	{r7, lr}
    1c26:	af00      	add	r7, sp, #0
    1c28:	4b03      	ldr	r3, [pc, #12]	; (1c38 <SERCOM5_Handler+0x14>)
    1c2a:	695b      	ldr	r3, [r3, #20]
    1c2c:	2005      	movs	r0, #5
    1c2e:	4798      	blx	r3
    1c30:	46c0      	nop			; (mov r8, r8)
    1c32:	46bd      	mov	sp, r7
    1c34:	bd80      	pop	{r7, pc}
    1c36:	46c0      	nop			; (mov r8, r8)
    1c38:	20000138 	.word	0x20000138

00001c3c <_extint_get_eic_from_channel>:
 *
 * \return Base address of the associated EIC module.
 */
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
    1c3c:	b580      	push	{r7, lr}
    1c3e:	b084      	sub	sp, #16
    1c40:	af00      	add	r7, sp, #0
    1c42:	0002      	movs	r2, r0
    1c44:	1dfb      	adds	r3, r7, #7
    1c46:	701a      	strb	r2, [r3, #0]
	uint8_t eic_index = (channel / 32);
    1c48:	230f      	movs	r3, #15
    1c4a:	18fb      	adds	r3, r7, r3
    1c4c:	1dfa      	adds	r2, r7, #7
    1c4e:	7812      	ldrb	r2, [r2, #0]
    1c50:	0952      	lsrs	r2, r2, #5
    1c52:	701a      	strb	r2, [r3, #0]

	if (eic_index < EIC_INST_NUM) {
    1c54:	230f      	movs	r3, #15
    1c56:	18fb      	adds	r3, r7, r3
    1c58:	781b      	ldrb	r3, [r3, #0]
    1c5a:	2b00      	cmp	r3, #0
    1c5c:	d10c      	bne.n	1c78 <_extint_get_eic_from_channel+0x3c>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    1c5e:	4b09      	ldr	r3, [pc, #36]	; (1c84 <_extint_get_eic_from_channel+0x48>)
    1c60:	60bb      	str	r3, [r7, #8]

		return eics[eic_index];
    1c62:	230f      	movs	r3, #15
    1c64:	18fb      	adds	r3, r7, r3
    1c66:	781b      	ldrb	r3, [r3, #0]
    1c68:	009b      	lsls	r3, r3, #2
    1c6a:	2210      	movs	r2, #16
    1c6c:	4694      	mov	ip, r2
    1c6e:	44bc      	add	ip, r7
    1c70:	4463      	add	r3, ip
    1c72:	3b08      	subs	r3, #8
    1c74:	681b      	ldr	r3, [r3, #0]
    1c76:	e000      	b.n	1c7a <_extint_get_eic_from_channel+0x3e>
	} else {
		Assert(false);
		return NULL;
    1c78:	2300      	movs	r3, #0
	}
}
    1c7a:	0018      	movs	r0, r3
    1c7c:	46bd      	mov	sp, r7
    1c7e:	b004      	add	sp, #16
    1c80:	bd80      	pop	{r7, pc}
    1c82:	46c0      	nop			; (mov r8, r8)
    1c84:	40001800 	.word	0x40001800

00001c88 <extint_chan_is_detected>:
 *  \retval true   If the channel's edge/level detection criteria was met
 *  \retval false  If the channel has not detected its configured criteria
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
    1c88:	b580      	push	{r7, lr}
    1c8a:	b084      	sub	sp, #16
    1c8c:	af00      	add	r7, sp, #0
    1c8e:	0002      	movs	r2, r0
    1c90:	1dfb      	adds	r3, r7, #7
    1c92:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
    1c94:	1dfb      	adds	r3, r7, #7
    1c96:	781b      	ldrb	r3, [r3, #0]
    1c98:	0018      	movs	r0, r3
    1c9a:	4b0b      	ldr	r3, [pc, #44]	; (1cc8 <extint_chan_is_detected+0x40>)
    1c9c:	4798      	blx	r3
    1c9e:	0003      	movs	r3, r0
    1ca0:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
    1ca2:	1dfb      	adds	r3, r7, #7
    1ca4:	781b      	ldrb	r3, [r3, #0]
    1ca6:	221f      	movs	r2, #31
    1ca8:	4013      	ands	r3, r2
    1caa:	2201      	movs	r2, #1
    1cac:	409a      	lsls	r2, r3
    1cae:	0013      	movs	r3, r2
    1cb0:	60bb      	str	r3, [r7, #8]

	return (eic_module->INTFLAG.reg & eic_mask);
    1cb2:	68fb      	ldr	r3, [r7, #12]
    1cb4:	691b      	ldr	r3, [r3, #16]
    1cb6:	68ba      	ldr	r2, [r7, #8]
    1cb8:	4013      	ands	r3, r2
    1cba:	1e5a      	subs	r2, r3, #1
    1cbc:	4193      	sbcs	r3, r2
    1cbe:	b2db      	uxtb	r3, r3
}
    1cc0:	0018      	movs	r0, r3
    1cc2:	46bd      	mov	sp, r7
    1cc4:	b004      	add	sp, #16
    1cc6:	bd80      	pop	{r7, pc}
    1cc8:	00001c3d 	.word	0x00001c3d

00001ccc <extint_chan_clear_detected>:
 *
 *  \param[in] channel  External Interrupt channel index to check
 */
static inline void extint_chan_clear_detected(
		const uint8_t channel)
{
    1ccc:	b580      	push	{r7, lr}
    1cce:	b084      	sub	sp, #16
    1cd0:	af00      	add	r7, sp, #0
    1cd2:	0002      	movs	r2, r0
    1cd4:	1dfb      	adds	r3, r7, #7
    1cd6:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
    1cd8:	1dfb      	adds	r3, r7, #7
    1cda:	781b      	ldrb	r3, [r3, #0]
    1cdc:	0018      	movs	r0, r3
    1cde:	4b09      	ldr	r3, [pc, #36]	; (1d04 <extint_chan_clear_detected+0x38>)
    1ce0:	4798      	blx	r3
    1ce2:	0003      	movs	r3, r0
    1ce4:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
    1ce6:	1dfb      	adds	r3, r7, #7
    1ce8:	781b      	ldrb	r3, [r3, #0]
    1cea:	221f      	movs	r2, #31
    1cec:	4013      	ands	r3, r2
    1cee:	2201      	movs	r2, #1
    1cf0:	409a      	lsls	r2, r3
    1cf2:	0013      	movs	r3, r2
    1cf4:	60bb      	str	r3, [r7, #8]

	eic_module->INTFLAG.reg = eic_mask;
    1cf6:	68fb      	ldr	r3, [r7, #12]
    1cf8:	68ba      	ldr	r2, [r7, #8]
    1cfa:	611a      	str	r2, [r3, #16]
}
    1cfc:	46c0      	nop			; (mov r8, r8)
    1cfe:	46bd      	mov	sp, r7
    1d00:	b004      	add	sp, #16
    1d02:	bd80      	pop	{r7, pc}
    1d04:	00001c3d 	.word	0x00001c3d

00001d08 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    1d08:	b580      	push	{r7, lr}
    1d0a:	af00      	add	r7, sp, #0
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    1d0c:	4b15      	ldr	r3, [pc, #84]	; (1d64 <EIC_Handler+0x5c>)
    1d0e:	2200      	movs	r2, #0
    1d10:	701a      	strb	r2, [r3, #0]
    1d12:	e020      	b.n	1d56 <EIC_Handler+0x4e>
		if (extint_chan_is_detected(_current_channel)) {
    1d14:	4b13      	ldr	r3, [pc, #76]	; (1d64 <EIC_Handler+0x5c>)
    1d16:	781b      	ldrb	r3, [r3, #0]
    1d18:	0018      	movs	r0, r3
    1d1a:	4b13      	ldr	r3, [pc, #76]	; (1d68 <EIC_Handler+0x60>)
    1d1c:	4798      	blx	r3
    1d1e:	1e03      	subs	r3, r0, #0
    1d20:	d013      	beq.n	1d4a <EIC_Handler+0x42>
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
    1d22:	4b10      	ldr	r3, [pc, #64]	; (1d64 <EIC_Handler+0x5c>)
    1d24:	781b      	ldrb	r3, [r3, #0]
    1d26:	0018      	movs	r0, r3
    1d28:	4b10      	ldr	r3, [pc, #64]	; (1d6c <EIC_Handler+0x64>)
    1d2a:	4798      	blx	r3
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    1d2c:	4b0d      	ldr	r3, [pc, #52]	; (1d64 <EIC_Handler+0x5c>)
    1d2e:	781b      	ldrb	r3, [r3, #0]
    1d30:	001a      	movs	r2, r3
    1d32:	4b0f      	ldr	r3, [pc, #60]	; (1d70 <EIC_Handler+0x68>)
    1d34:	0092      	lsls	r2, r2, #2
    1d36:	58d3      	ldr	r3, [r2, r3]
    1d38:	2b00      	cmp	r3, #0
    1d3a:	d006      	beq.n	1d4a <EIC_Handler+0x42>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    1d3c:	4b09      	ldr	r3, [pc, #36]	; (1d64 <EIC_Handler+0x5c>)
    1d3e:	781b      	ldrb	r3, [r3, #0]
    1d40:	001a      	movs	r2, r3
    1d42:	4b0b      	ldr	r3, [pc, #44]	; (1d70 <EIC_Handler+0x68>)
    1d44:	0092      	lsls	r2, r2, #2
    1d46:	58d3      	ldr	r3, [r2, r3]
    1d48:	4798      	blx	r3
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    1d4a:	4b06      	ldr	r3, [pc, #24]	; (1d64 <EIC_Handler+0x5c>)
    1d4c:	781b      	ldrb	r3, [r3, #0]
    1d4e:	3301      	adds	r3, #1
    1d50:	b2da      	uxtb	r2, r3
    1d52:	4b04      	ldr	r3, [pc, #16]	; (1d64 <EIC_Handler+0x5c>)
    1d54:	701a      	strb	r2, [r3, #0]
    1d56:	4b03      	ldr	r3, [pc, #12]	; (1d64 <EIC_Handler+0x5c>)
    1d58:	781b      	ldrb	r3, [r3, #0]
    1d5a:	2b0f      	cmp	r3, #15
    1d5c:	d9da      	bls.n	1d14 <EIC_Handler+0xc>
			}
		}
	}
}
    1d5e:	46c0      	nop			; (mov r8, r8)
    1d60:	46bd      	mov	sp, r7
    1d62:	bd80      	pop	{r7, pc}
    1d64:	200002dc 	.word	0x200002dc
    1d68:	00001c89 	.word	0x00001c89
    1d6c:	00001ccd 	.word	0x00001ccd
    1d70:	20000198 	.word	0x20000198

00001d74 <delay_init>:
 * \brief Initialize the delay driver.
 *
 * Not used in cycle mode.
 */
void delay_init(void)
{
    1d74:	b580      	push	{r7, lr}
    1d76:	af00      	add	r7, sp, #0
}
    1d78:	46c0      	nop			; (mov r8, r8)
    1d7a:	46bd      	mov	sp, r7
    1d7c:	bd80      	pop	{r7, pc}
	...

00001d80 <nvm_is_ready>:
 * \retval true   If the hardware module is ready for a new command
 * \retval false  If the hardware module is busy executing a command
 *
 */
static inline bool nvm_is_ready(void)
{
    1d80:	b580      	push	{r7, lr}
    1d82:	b082      	sub	sp, #8
    1d84:	af00      	add	r7, sp, #0
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    1d86:	4b07      	ldr	r3, [pc, #28]	; (1da4 <nvm_is_ready+0x24>)
    1d88:	607b      	str	r3, [r7, #4]

	return nvm_module->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    1d8a:	687b      	ldr	r3, [r7, #4]
    1d8c:	7d1b      	ldrb	r3, [r3, #20]
    1d8e:	b2db      	uxtb	r3, r3
    1d90:	001a      	movs	r2, r3
    1d92:	2301      	movs	r3, #1
    1d94:	4013      	ands	r3, r2
    1d96:	1e5a      	subs	r2, r3, #1
    1d98:	4193      	sbcs	r3, r2
    1d9a:	b2db      	uxtb	r3, r3
}
    1d9c:	0018      	movs	r0, r3
    1d9e:	46bd      	mov	sp, r7
    1da0:	b002      	add	sp, #8
    1da2:	bd80      	pop	{r7, pc}
    1da4:	41004000 	.word	0x41004000

00001da8 <system_apb_clock_set_mask>:
{
    1da8:	b580      	push	{r7, lr}
    1daa:	b082      	sub	sp, #8
    1dac:	af00      	add	r7, sp, #0
    1dae:	0002      	movs	r2, r0
    1db0:	6039      	str	r1, [r7, #0]
    1db2:	1dfb      	adds	r3, r7, #7
    1db4:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    1db6:	1dfb      	adds	r3, r7, #7
    1db8:	781b      	ldrb	r3, [r3, #0]
    1dba:	2b01      	cmp	r3, #1
    1dbc:	d00a      	beq.n	1dd4 <system_apb_clock_set_mask+0x2c>
    1dbe:	2b02      	cmp	r3, #2
    1dc0:	d00f      	beq.n	1de2 <system_apb_clock_set_mask+0x3a>
    1dc2:	2b00      	cmp	r3, #0
    1dc4:	d114      	bne.n	1df0 <system_apb_clock_set_mask+0x48>
			PM->APBAMASK.reg |= mask;
    1dc6:	4b0e      	ldr	r3, [pc, #56]	; (1e00 <system_apb_clock_set_mask+0x58>)
    1dc8:	4a0d      	ldr	r2, [pc, #52]	; (1e00 <system_apb_clock_set_mask+0x58>)
    1dca:	6991      	ldr	r1, [r2, #24]
    1dcc:	683a      	ldr	r2, [r7, #0]
    1dce:	430a      	orrs	r2, r1
    1dd0:	619a      	str	r2, [r3, #24]
			break;
    1dd2:	e00f      	b.n	1df4 <system_apb_clock_set_mask+0x4c>
			PM->APBBMASK.reg |= mask;
    1dd4:	4b0a      	ldr	r3, [pc, #40]	; (1e00 <system_apb_clock_set_mask+0x58>)
    1dd6:	4a0a      	ldr	r2, [pc, #40]	; (1e00 <system_apb_clock_set_mask+0x58>)
    1dd8:	69d1      	ldr	r1, [r2, #28]
    1dda:	683a      	ldr	r2, [r7, #0]
    1ddc:	430a      	orrs	r2, r1
    1dde:	61da      	str	r2, [r3, #28]
			break;
    1de0:	e008      	b.n	1df4 <system_apb_clock_set_mask+0x4c>
			PM->APBCMASK.reg |= mask;
    1de2:	4b07      	ldr	r3, [pc, #28]	; (1e00 <system_apb_clock_set_mask+0x58>)
    1de4:	4a06      	ldr	r2, [pc, #24]	; (1e00 <system_apb_clock_set_mask+0x58>)
    1de6:	6a11      	ldr	r1, [r2, #32]
    1de8:	683a      	ldr	r2, [r7, #0]
    1dea:	430a      	orrs	r2, r1
    1dec:	621a      	str	r2, [r3, #32]
			break;
    1dee:	e001      	b.n	1df4 <system_apb_clock_set_mask+0x4c>
			return STATUS_ERR_INVALID_ARG;
    1df0:	2317      	movs	r3, #23
    1df2:	e000      	b.n	1df6 <system_apb_clock_set_mask+0x4e>
	return STATUS_OK;
    1df4:	2300      	movs	r3, #0
}
    1df6:	0018      	movs	r0, r3
    1df8:	46bd      	mov	sp, r7
    1dfa:	b002      	add	sp, #8
    1dfc:	bd80      	pop	{r7, pc}
    1dfe:	46c0      	nop			; (mov r8, r8)
    1e00:	40000400 	.word	0x40000400

00001e04 <nvm_set_config>:
 *                        EEPROM and/or auxiliary space configuration from being
 *                        altered
 */
enum status_code nvm_set_config(
		const struct nvm_config *const config)
{
    1e04:	b580      	push	{r7, lr}
    1e06:	b084      	sub	sp, #16
    1e08:	af00      	add	r7, sp, #0
    1e0a:	6078      	str	r0, [r7, #4]
	/* Sanity check argument */
	Assert(config);

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    1e0c:	4b2f      	ldr	r3, [pc, #188]	; (1ecc <nvm_set_config+0xc8>)
    1e0e:	60fb      	str	r3, [r7, #12]
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21) || (SAMR30) || (SAMR34) || (SAMR35)
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB, MCLK_APBBMASK_NVMCTRL);
#else
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB, PM_APBBMASK_NVMCTRL);
    1e10:	2104      	movs	r1, #4
    1e12:	2001      	movs	r0, #1
    1e14:	4b2e      	ldr	r3, [pc, #184]	; (1ed0 <nvm_set_config+0xcc>)
    1e16:	4798      	blx	r3
#endif

	/* Clear error flags */
	nvm_module->STATUS.reg = NVMCTRL_STATUS_MASK;
    1e18:	68fb      	ldr	r3, [r7, #12]
    1e1a:	2220      	movs	r2, #32
    1e1c:	32ff      	adds	r2, #255	; 0xff
    1e1e:	831a      	strh	r2, [r3, #24]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    1e20:	4b2c      	ldr	r3, [pc, #176]	; (1ed4 <nvm_set_config+0xd0>)
    1e22:	4798      	blx	r3
    1e24:	0003      	movs	r3, r0
    1e26:	001a      	movs	r2, r3
    1e28:	2301      	movs	r3, #1
    1e2a:	4053      	eors	r3, r2
    1e2c:	b2db      	uxtb	r3, r3
    1e2e:	2b00      	cmp	r3, #0
    1e30:	d001      	beq.n	1e36 <nvm_set_config+0x32>
		return STATUS_BUSY;
    1e32:	2305      	movs	r3, #5
    1e34:	e045      	b.n	1ec2 <nvm_set_config+0xbe>
	}

#if (!SAMC20) && (!SAMC21)
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
    1e36:	687b      	ldr	r3, [r7, #4]
    1e38:	781b      	ldrb	r3, [r3, #0]
    1e3a:	021b      	lsls	r3, r3, #8
    1e3c:	001a      	movs	r2, r3
    1e3e:	23c0      	movs	r3, #192	; 0xc0
    1e40:	009b      	lsls	r3, r3, #2
    1e42:	401a      	ands	r2, r3
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
    1e44:	687b      	ldr	r3, [r7, #4]
    1e46:	785b      	ldrb	r3, [r3, #1]
    1e48:	01db      	lsls	r3, r3, #7
    1e4a:	0019      	movs	r1, r3
    1e4c:	23ff      	movs	r3, #255	; 0xff
    1e4e:	400b      	ands	r3, r1
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
    1e50:	431a      	orrs	r2, r3
			NVMCTRL_CTRLB_RWS(config->wait_states) |
    1e52:	687b      	ldr	r3, [r7, #4]
    1e54:	789b      	ldrb	r3, [r3, #2]
    1e56:	005b      	lsls	r3, r3, #1
    1e58:	0019      	movs	r1, r3
    1e5a:	231e      	movs	r3, #30
    1e5c:	400b      	ands	r3, r1
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
    1e5e:	431a      	orrs	r2, r3
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
    1e60:	687b      	ldr	r3, [r7, #4]
    1e62:	78db      	ldrb	r3, [r3, #3]
    1e64:	049b      	lsls	r3, r3, #18
    1e66:	0019      	movs	r1, r3
    1e68:	2380      	movs	r3, #128	; 0x80
    1e6a:	02db      	lsls	r3, r3, #11
    1e6c:	400b      	ands	r3, r1
			NVMCTRL_CTRLB_RWS(config->wait_states) |
    1e6e:	431a      	orrs	r2, r3
			NVMCTRL_CTRLB_READMODE(config->cache_readmode);
    1e70:	687b      	ldr	r3, [r7, #4]
    1e72:	791b      	ldrb	r3, [r3, #4]
    1e74:	041b      	lsls	r3, r3, #16
    1e76:	0019      	movs	r1, r3
    1e78:	23c0      	movs	r3, #192	; 0xc0
    1e7a:	029b      	lsls	r3, r3, #10
    1e7c:	400b      	ands	r3, r1
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
    1e7e:	431a      	orrs	r2, r3
	nvm_module->CTRLB.reg =
    1e80:	68fb      	ldr	r3, [r7, #12]
    1e82:	605a      	str	r2, [r3, #4]
			(cache_disable_value << NVMCTRL_CTRLB_CACHEDIS_Pos) |
			NVMCTRL_CTRLB_READMODE(config->cache_readmode);
#endif

	/* Initialize the internal device struct */
	_nvm_dev.page_size         = (8 << nvm_module->PARAM.bit.PSZ);
    1e84:	68fb      	ldr	r3, [r7, #12]
    1e86:	689b      	ldr	r3, [r3, #8]
    1e88:	035b      	lsls	r3, r3, #13
    1e8a:	0f5b      	lsrs	r3, r3, #29
    1e8c:	b2db      	uxtb	r3, r3
    1e8e:	001a      	movs	r2, r3
    1e90:	2308      	movs	r3, #8
    1e92:	4093      	lsls	r3, r2
    1e94:	b29a      	uxth	r2, r3
    1e96:	4b10      	ldr	r3, [pc, #64]	; (1ed8 <nvm_set_config+0xd4>)
    1e98:	801a      	strh	r2, [r3, #0]
	_nvm_dev.number_of_pages   = nvm_module->PARAM.bit.NVMP;
    1e9a:	68fb      	ldr	r3, [r7, #12]
    1e9c:	689b      	ldr	r3, [r3, #8]
    1e9e:	b29a      	uxth	r2, r3
    1ea0:	4b0d      	ldr	r3, [pc, #52]	; (1ed8 <nvm_set_config+0xd4>)
    1ea2:	805a      	strh	r2, [r3, #2]
	_nvm_dev.manual_page_write = config->manual_page_write;
    1ea4:	687b      	ldr	r3, [r7, #4]
    1ea6:	785a      	ldrb	r2, [r3, #1]
    1ea8:	4b0b      	ldr	r3, [pc, #44]	; (1ed8 <nvm_set_config+0xd4>)
    1eaa:	711a      	strb	r2, [r3, #4]

	/* If the security bit is set, the auxiliary space cannot be written */
	if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
    1eac:	68fb      	ldr	r3, [r7, #12]
    1eae:	8b1b      	ldrh	r3, [r3, #24]
    1eb0:	b29b      	uxth	r3, r3
    1eb2:	001a      	movs	r2, r3
    1eb4:	2380      	movs	r3, #128	; 0x80
    1eb6:	005b      	lsls	r3, r3, #1
    1eb8:	4013      	ands	r3, r2
    1eba:	d001      	beq.n	1ec0 <nvm_set_config+0xbc>
		return STATUS_ERR_IO;
    1ebc:	2310      	movs	r3, #16
    1ebe:	e000      	b.n	1ec2 <nvm_set_config+0xbe>
	}

	return STATUS_OK;
    1ec0:	2300      	movs	r3, #0
}
    1ec2:	0018      	movs	r0, r3
    1ec4:	46bd      	mov	sp, r7
    1ec6:	b004      	add	sp, #16
    1ec8:	bd80      	pop	{r7, pc}
    1eca:	46c0      	nop			; (mov r8, r8)
    1ecc:	41004000 	.word	0x41004000
    1ed0:	00001da9 	.word	0x00001da9
    1ed4:	00001d81 	.word	0x00001d81
    1ed8:	20000150 	.word	0x20000150

00001edc <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    1edc:	b580      	push	{r7, lr}
    1ede:	b082      	sub	sp, #8
    1ee0:	af00      	add	r7, sp, #0
    1ee2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    1ee4:	687b      	ldr	r3, [r7, #4]
    1ee6:	2280      	movs	r2, #128	; 0x80
    1ee8:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    1eea:	687b      	ldr	r3, [r7, #4]
    1eec:	2200      	movs	r2, #0
    1eee:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    1ef0:	687b      	ldr	r3, [r7, #4]
    1ef2:	2201      	movs	r2, #1
    1ef4:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    1ef6:	687b      	ldr	r3, [r7, #4]
    1ef8:	2200      	movs	r2, #0
    1efa:	70da      	strb	r2, [r3, #3]
}
    1efc:	46c0      	nop			; (mov r8, r8)
    1efe:	46bd      	mov	sp, r7
    1f00:	b002      	add	sp, #8
    1f02:	bd80      	pop	{r7, pc}

00001f04 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    1f04:	b580      	push	{r7, lr}
    1f06:	b084      	sub	sp, #16
    1f08:	af00      	add	r7, sp, #0
    1f0a:	0002      	movs	r2, r0
    1f0c:	6039      	str	r1, [r7, #0]
    1f0e:	1dfb      	adds	r3, r7, #7
    1f10:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
    1f12:	230c      	movs	r3, #12
    1f14:	18fb      	adds	r3, r7, r3
    1f16:	0018      	movs	r0, r3
    1f18:	4b10      	ldr	r3, [pc, #64]	; (1f5c <port_pin_set_config+0x58>)
    1f1a:	4798      	blx	r3

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
    1f1c:	230c      	movs	r3, #12
    1f1e:	18fb      	adds	r3, r7, r3
    1f20:	2280      	movs	r2, #128	; 0x80
    1f22:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    1f24:	683b      	ldr	r3, [r7, #0]
    1f26:	781a      	ldrb	r2, [r3, #0]
    1f28:	230c      	movs	r3, #12
    1f2a:	18fb      	adds	r3, r7, r3
    1f2c:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    1f2e:	683b      	ldr	r3, [r7, #0]
    1f30:	785a      	ldrb	r2, [r3, #1]
    1f32:	230c      	movs	r3, #12
    1f34:	18fb      	adds	r3, r7, r3
    1f36:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    1f38:	683b      	ldr	r3, [r7, #0]
    1f3a:	789a      	ldrb	r2, [r3, #2]
    1f3c:	230c      	movs	r3, #12
    1f3e:	18fb      	adds	r3, r7, r3
    1f40:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    1f42:	230c      	movs	r3, #12
    1f44:	18fa      	adds	r2, r7, r3
    1f46:	1dfb      	adds	r3, r7, #7
    1f48:	781b      	ldrb	r3, [r3, #0]
    1f4a:	0011      	movs	r1, r2
    1f4c:	0018      	movs	r0, r3
    1f4e:	4b04      	ldr	r3, [pc, #16]	; (1f60 <port_pin_set_config+0x5c>)
    1f50:	4798      	blx	r3
}
    1f52:	46c0      	nop			; (mov r8, r8)
    1f54:	46bd      	mov	sp, r7
    1f56:	b004      	add	sp, #16
    1f58:	bd80      	pop	{r7, pc}
    1f5a:	46c0      	nop			; (mov r8, r8)
    1f5c:	00001edd 	.word	0x00001edd
    1f60:	00003015 	.word	0x00003015

00001f64 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    1f64:	b580      	push	{r7, lr}
    1f66:	af00      	add	r7, sp, #0
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
    1f68:	46c0      	nop			; (mov r8, r8)
    1f6a:	46bd      	mov	sp, r7
    1f6c:	bd80      	pop	{r7, pc}
	...

00001f70 <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
    1f70:	b580      	push	{r7, lr}
    1f72:	b082      	sub	sp, #8
    1f74:	af00      	add	r7, sp, #0
	if (cpu_irq_critical_section_counter == 0) {
    1f76:	4b10      	ldr	r3, [pc, #64]	; (1fb8 <cpu_irq_enter_critical+0x48>)
    1f78:	681b      	ldr	r3, [r3, #0]
    1f7a:	2b00      	cmp	r3, #0
    1f7c:	d112      	bne.n	1fa4 <cpu_irq_enter_critical+0x34>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    1f7e:	f3ef 8310 	mrs	r3, PRIMASK
    1f82:	607b      	str	r3, [r7, #4]
  return(result);
    1f84:	687b      	ldr	r3, [r7, #4]
		if (cpu_irq_is_enabled()) {
    1f86:	2b00      	cmp	r3, #0
    1f88:	d109      	bne.n	1f9e <cpu_irq_enter_critical+0x2e>
  __ASM volatile ("cpsid i" : : : "memory");
    1f8a:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    1f8c:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    1f90:	4b0a      	ldr	r3, [pc, #40]	; (1fbc <cpu_irq_enter_critical+0x4c>)
    1f92:	2200      	movs	r2, #0
    1f94:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    1f96:	4b0a      	ldr	r3, [pc, #40]	; (1fc0 <cpu_irq_enter_critical+0x50>)
    1f98:	2201      	movs	r2, #1
    1f9a:	701a      	strb	r2, [r3, #0]
    1f9c:	e002      	b.n	1fa4 <cpu_irq_enter_critical+0x34>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    1f9e:	4b08      	ldr	r3, [pc, #32]	; (1fc0 <cpu_irq_enter_critical+0x50>)
    1fa0:	2200      	movs	r2, #0
    1fa2:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    1fa4:	4b04      	ldr	r3, [pc, #16]	; (1fb8 <cpu_irq_enter_critical+0x48>)
    1fa6:	681b      	ldr	r3, [r3, #0]
    1fa8:	1c5a      	adds	r2, r3, #1
    1faa:	4b03      	ldr	r3, [pc, #12]	; (1fb8 <cpu_irq_enter_critical+0x48>)
    1fac:	601a      	str	r2, [r3, #0]
}
    1fae:	46c0      	nop			; (mov r8, r8)
    1fb0:	46bd      	mov	sp, r7
    1fb2:	b002      	add	sp, #8
    1fb4:	bd80      	pop	{r7, pc}
    1fb6:	46c0      	nop			; (mov r8, r8)
    1fb8:	20000158 	.word	0x20000158
    1fbc:	2000000c 	.word	0x2000000c
    1fc0:	2000015c 	.word	0x2000015c

00001fc4 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
    1fc4:	b580      	push	{r7, lr}
    1fc6:	af00      	add	r7, sp, #0
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    1fc8:	4b0b      	ldr	r3, [pc, #44]	; (1ff8 <cpu_irq_leave_critical+0x34>)
    1fca:	681b      	ldr	r3, [r3, #0]
    1fcc:	1e5a      	subs	r2, r3, #1
    1fce:	4b0a      	ldr	r3, [pc, #40]	; (1ff8 <cpu_irq_leave_critical+0x34>)
    1fd0:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    1fd2:	4b09      	ldr	r3, [pc, #36]	; (1ff8 <cpu_irq_leave_critical+0x34>)
    1fd4:	681b      	ldr	r3, [r3, #0]
    1fd6:	2b00      	cmp	r3, #0
    1fd8:	d10a      	bne.n	1ff0 <cpu_irq_leave_critical+0x2c>
    1fda:	4b08      	ldr	r3, [pc, #32]	; (1ffc <cpu_irq_leave_critical+0x38>)
    1fdc:	781b      	ldrb	r3, [r3, #0]
    1fde:	b2db      	uxtb	r3, r3
    1fe0:	2b00      	cmp	r3, #0
    1fe2:	d005      	beq.n	1ff0 <cpu_irq_leave_critical+0x2c>
		cpu_irq_enable();
    1fe4:	4b06      	ldr	r3, [pc, #24]	; (2000 <STACK_SIZE>)
    1fe6:	2201      	movs	r2, #1
    1fe8:	701a      	strb	r2, [r3, #0]
    1fea:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
    1fee:	b662      	cpsie	i
	}
}
    1ff0:	46c0      	nop			; (mov r8, r8)
    1ff2:	46bd      	mov	sp, r7
    1ff4:	bd80      	pop	{r7, pc}
    1ff6:	46c0      	nop			; (mov r8, r8)
    1ff8:	20000158 	.word	0x20000158
    1ffc:	2000015c 	.word	0x2000015c
    2000:	2000000c 	.word	0x2000000c

00002004 <system_gclk_gen_get_config_defaults>:
{
    2004:	b580      	push	{r7, lr}
    2006:	b082      	sub	sp, #8
    2008:	af00      	add	r7, sp, #0
    200a:	6078      	str	r0, [r7, #4]
	config->division_factor    = 1;
    200c:	687b      	ldr	r3, [r7, #4]
    200e:	2201      	movs	r2, #1
    2010:	605a      	str	r2, [r3, #4]
	config->high_when_disabled = false;
    2012:	687b      	ldr	r3, [r7, #4]
    2014:	2200      	movs	r2, #0
    2016:	705a      	strb	r2, [r3, #1]
	config->source_clock       = GCLK_SOURCE_OSC8M;
    2018:	687b      	ldr	r3, [r7, #4]
    201a:	2206      	movs	r2, #6
    201c:	701a      	strb	r2, [r3, #0]
	config->run_in_standby     = false;
    201e:	687b      	ldr	r3, [r7, #4]
    2020:	2200      	movs	r2, #0
    2022:	721a      	strb	r2, [r3, #8]
	config->output_enable      = false;
    2024:	687b      	ldr	r3, [r7, #4]
    2026:	2200      	movs	r2, #0
    2028:	725a      	strb	r2, [r3, #9]
}
    202a:	46c0      	nop			; (mov r8, r8)
    202c:	46bd      	mov	sp, r7
    202e:	b002      	add	sp, #8
    2030:	bd80      	pop	{r7, pc}

00002032 <system_gclk_chan_get_config_defaults>:
{
    2032:	b580      	push	{r7, lr}
    2034:	b082      	sub	sp, #8
    2036:	af00      	add	r7, sp, #0
    2038:	6078      	str	r0, [r7, #4]
	config->source_generator = GCLK_GENERATOR_0;
    203a:	687b      	ldr	r3, [r7, #4]
    203c:	2200      	movs	r2, #0
    203e:	701a      	strb	r2, [r3, #0]
}
    2040:	46c0      	nop			; (mov r8, r8)
    2042:	46bd      	mov	sp, r7
    2044:	b002      	add	sp, #8
    2046:	bd80      	pop	{r7, pc}

00002048 <system_clock_source_xosc32k_get_config_defaults>:
{
    2048:	b580      	push	{r7, lr}
    204a:	b082      	sub	sp, #8
    204c:	af00      	add	r7, sp, #0
    204e:	6078      	str	r0, [r7, #4]
	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    2050:	687b      	ldr	r3, [r7, #4]
    2052:	2200      	movs	r2, #0
    2054:	701a      	strb	r2, [r3, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
    2056:	687b      	ldr	r3, [r7, #4]
    2058:	2204      	movs	r2, #4
    205a:	705a      	strb	r2, [r3, #1]
	config->auto_gain_control   = false;
    205c:	687b      	ldr	r3, [r7, #4]
    205e:	2200      	movs	r2, #0
    2060:	709a      	strb	r2, [r3, #2]
	config->frequency           = 32768UL;
    2062:	687b      	ldr	r3, [r7, #4]
    2064:	2280      	movs	r2, #128	; 0x80
    2066:	0212      	lsls	r2, r2, #8
    2068:	609a      	str	r2, [r3, #8]
	config->enable_1khz_output  = false;
    206a:	687b      	ldr	r3, [r7, #4]
    206c:	2200      	movs	r2, #0
    206e:	70da      	strb	r2, [r3, #3]
	config->enable_32khz_output = true;
    2070:	687b      	ldr	r3, [r7, #4]
    2072:	2201      	movs	r2, #1
    2074:	711a      	strb	r2, [r3, #4]
	config->run_in_standby      = false;
    2076:	687b      	ldr	r3, [r7, #4]
    2078:	2200      	movs	r2, #0
    207a:	731a      	strb	r2, [r3, #12]
	config->on_demand           = true;
    207c:	687b      	ldr	r3, [r7, #4]
    207e:	2201      	movs	r2, #1
    2080:	735a      	strb	r2, [r3, #13]
	config->write_once          = false;
    2082:	687b      	ldr	r3, [r7, #4]
    2084:	2200      	movs	r2, #0
    2086:	739a      	strb	r2, [r3, #14]
}
    2088:	46c0      	nop			; (mov r8, r8)
    208a:	46bd      	mov	sp, r7
    208c:	b002      	add	sp, #8
    208e:	bd80      	pop	{r7, pc}

00002090 <system_clock_source_osc8m_get_config_defaults>:
{
    2090:	b580      	push	{r7, lr}
    2092:	b082      	sub	sp, #8
    2094:	af00      	add	r7, sp, #0
    2096:	6078      	str	r0, [r7, #4]
	config->prescaler       = SYSTEM_OSC8M_DIV_8;
    2098:	687b      	ldr	r3, [r7, #4]
    209a:	2203      	movs	r2, #3
    209c:	701a      	strb	r2, [r3, #0]
	config->run_in_standby  = false;
    209e:	687b      	ldr	r3, [r7, #4]
    20a0:	2200      	movs	r2, #0
    20a2:	705a      	strb	r2, [r3, #1]
	config->on_demand       = true;
    20a4:	687b      	ldr	r3, [r7, #4]
    20a6:	2201      	movs	r2, #1
    20a8:	709a      	strb	r2, [r3, #2]
}
    20aa:	46c0      	nop			; (mov r8, r8)
    20ac:	46bd      	mov	sp, r7
    20ae:	b002      	add	sp, #8
    20b0:	bd80      	pop	{r7, pc}

000020b2 <system_clock_source_dfll_get_config_defaults>:
{
    20b2:	b580      	push	{r7, lr}
    20b4:	b082      	sub	sp, #8
    20b6:	af00      	add	r7, sp, #0
    20b8:	6078      	str	r0, [r7, #4]
	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
    20ba:	687b      	ldr	r3, [r7, #4]
    20bc:	2200      	movs	r2, #0
    20be:	701a      	strb	r2, [r3, #0]
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    20c0:	687b      	ldr	r3, [r7, #4]
    20c2:	2200      	movs	r2, #0
    20c4:	805a      	strh	r2, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    20c6:	687b      	ldr	r3, [r7, #4]
    20c8:	2200      	movs	r2, #0
    20ca:	809a      	strh	r2, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    20cc:	687b      	ldr	r3, [r7, #4]
    20ce:	2200      	movs	r2, #0
    20d0:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    20d2:	687b      	ldr	r3, [r7, #4]
    20d4:	2200      	movs	r2, #0
    20d6:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;
    20d8:	687b      	ldr	r3, [r7, #4]
    20da:	2201      	movs	r2, #1
    20dc:	705a      	strb	r2, [r3, #1]
	config->coarse_value    = 0x1f / 4; /* Midpoint */
    20de:	687b      	ldr	r3, [r7, #4]
    20e0:	2207      	movs	r2, #7
    20e2:	721a      	strb	r2, [r3, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
    20e4:	687b      	ldr	r3, [r7, #4]
    20e6:	223f      	movs	r2, #63	; 0x3f
    20e8:	815a      	strh	r2, [r3, #10]
	config->coarse_max_step = 1;
    20ea:	687b      	ldr	r3, [r7, #4]
    20ec:	2201      	movs	r2, #1
    20ee:	731a      	strb	r2, [r3, #12]
	config->fine_max_step   = 1;
    20f0:	687b      	ldr	r3, [r7, #4]
    20f2:	2201      	movs	r2, #1
    20f4:	81da      	strh	r2, [r3, #14]
	config->multiply_factor = 6; /* Multiply 8MHz by 6 to get 48MHz */
    20f6:	687b      	ldr	r3, [r7, #4]
    20f8:	2206      	movs	r2, #6
    20fa:	821a      	strh	r2, [r3, #16]
}
    20fc:	46c0      	nop			; (mov r8, r8)
    20fe:	46bd      	mov	sp, r7
    2100:	b002      	add	sp, #8
    2102:	bd80      	pop	{r7, pc}

00002104 <system_cpu_clock_set_divider>:
{
    2104:	b580      	push	{r7, lr}
    2106:	b082      	sub	sp, #8
    2108:	af00      	add	r7, sp, #0
    210a:	0002      	movs	r2, r0
    210c:	1dfb      	adds	r3, r7, #7
    210e:	701a      	strb	r2, [r3, #0]
	PM->CPUSEL.reg = (uint32_t)divider;
    2110:	4a03      	ldr	r2, [pc, #12]	; (2120 <system_cpu_clock_set_divider+0x1c>)
    2112:	1dfb      	adds	r3, r7, #7
    2114:	781b      	ldrb	r3, [r3, #0]
    2116:	7213      	strb	r3, [r2, #8]
}
    2118:	46c0      	nop			; (mov r8, r8)
    211a:	46bd      	mov	sp, r7
    211c:	b002      	add	sp, #8
    211e:	bd80      	pop	{r7, pc}
    2120:	40000400 	.word	0x40000400

00002124 <system_apb_clock_set_divider>:
{
    2124:	b580      	push	{r7, lr}
    2126:	b082      	sub	sp, #8
    2128:	af00      	add	r7, sp, #0
    212a:	0002      	movs	r2, r0
    212c:	1dfb      	adds	r3, r7, #7
    212e:	701a      	strb	r2, [r3, #0]
    2130:	1dbb      	adds	r3, r7, #6
    2132:	1c0a      	adds	r2, r1, #0
    2134:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    2136:	1dfb      	adds	r3, r7, #7
    2138:	781b      	ldrb	r3, [r3, #0]
    213a:	2b01      	cmp	r3, #1
    213c:	d008      	beq.n	2150 <system_apb_clock_set_divider+0x2c>
    213e:	2b02      	cmp	r3, #2
    2140:	d00b      	beq.n	215a <system_apb_clock_set_divider+0x36>
    2142:	2b00      	cmp	r3, #0
    2144:	d10e      	bne.n	2164 <system_apb_clock_set_divider+0x40>
			PM->APBASEL.reg = (uint32_t)divider;
    2146:	4a0b      	ldr	r2, [pc, #44]	; (2174 <system_apb_clock_set_divider+0x50>)
    2148:	1dbb      	adds	r3, r7, #6
    214a:	781b      	ldrb	r3, [r3, #0]
    214c:	7253      	strb	r3, [r2, #9]
			break;
    214e:	e00b      	b.n	2168 <system_apb_clock_set_divider+0x44>
			PM->APBBSEL.reg = (uint32_t)divider;
    2150:	4a08      	ldr	r2, [pc, #32]	; (2174 <system_apb_clock_set_divider+0x50>)
    2152:	1dbb      	adds	r3, r7, #6
    2154:	781b      	ldrb	r3, [r3, #0]
    2156:	7293      	strb	r3, [r2, #10]
			break;
    2158:	e006      	b.n	2168 <system_apb_clock_set_divider+0x44>
			PM->APBCSEL.reg = (uint32_t)divider;
    215a:	4a06      	ldr	r2, [pc, #24]	; (2174 <system_apb_clock_set_divider+0x50>)
    215c:	1dbb      	adds	r3, r7, #6
    215e:	781b      	ldrb	r3, [r3, #0]
    2160:	72d3      	strb	r3, [r2, #11]
			break;
    2162:	e001      	b.n	2168 <system_apb_clock_set_divider+0x44>
			return STATUS_ERR_INVALID_ARG;
    2164:	2317      	movs	r3, #23
    2166:	e000      	b.n	216a <system_apb_clock_set_divider+0x46>
	return STATUS_OK;
    2168:	2300      	movs	r3, #0
}
    216a:	0018      	movs	r0, r3
    216c:	46bd      	mov	sp, r7
    216e:	b002      	add	sp, #8
    2170:	bd80      	pop	{r7, pc}
    2172:	46c0      	nop			; (mov r8, r8)
    2174:	40000400 	.word	0x40000400

00002178 <system_flash_set_waitstates>:
 * can be found in the electrical characteristics of the device.
 *
 * \param[in] wait_states Number of wait states to use for internal flash
 */
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
    2178:	b580      	push	{r7, lr}
    217a:	b082      	sub	sp, #8
    217c:	af00      	add	r7, sp, #0
    217e:	0002      	movs	r2, r0
    2180:	1dfb      	adds	r3, r7, #7
    2182:	701a      	strb	r2, [r3, #0]
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    2184:	4a08      	ldr	r2, [pc, #32]	; (21a8 <system_flash_set_waitstates+0x30>)
    2186:	1dfb      	adds	r3, r7, #7
    2188:	781b      	ldrb	r3, [r3, #0]
    218a:	210f      	movs	r1, #15
    218c:	400b      	ands	r3, r1
    218e:	b2d9      	uxtb	r1, r3
    2190:	6853      	ldr	r3, [r2, #4]
    2192:	200f      	movs	r0, #15
    2194:	4001      	ands	r1, r0
    2196:	0049      	lsls	r1, r1, #1
    2198:	201e      	movs	r0, #30
    219a:	4383      	bics	r3, r0
    219c:	430b      	orrs	r3, r1
    219e:	6053      	str	r3, [r2, #4]
}
    21a0:	46c0      	nop			; (mov r8, r8)
    21a2:	46bd      	mov	sp, r7
    21a4:	b002      	add	sp, #8
    21a6:	bd80      	pop	{r7, pc}
    21a8:	41004000 	.word	0x41004000

000021ac <_system_dfll_wait_for_sync>:
/**
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
    21ac:	b580      	push	{r7, lr}
    21ae:	af00      	add	r7, sp, #0
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    21b0:	46c0      	nop			; (mov r8, r8)
    21b2:	4b04      	ldr	r3, [pc, #16]	; (21c4 <_system_dfll_wait_for_sync+0x18>)
    21b4:	68db      	ldr	r3, [r3, #12]
    21b6:	2210      	movs	r2, #16
    21b8:	4013      	ands	r3, r2
    21ba:	d0fa      	beq.n	21b2 <_system_dfll_wait_for_sync+0x6>
		/* Wait for DFLL sync */
	}
}
    21bc:	46c0      	nop			; (mov r8, r8)
    21be:	46bd      	mov	sp, r7
    21c0:	bd80      	pop	{r7, pc}
    21c2:	46c0      	nop			; (mov r8, r8)
    21c4:	40000800 	.word	0x40000800

000021c8 <_system_clock_source_dfll_set_config_errata_9905>:
		/* Wait for OSC32K sync */
	}
}

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{
    21c8:	b580      	push	{r7, lr}
    21ca:	af00      	add	r7, sp, #0

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    21cc:	4b0c      	ldr	r3, [pc, #48]	; (2200 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    21ce:	2202      	movs	r2, #2
    21d0:	849a      	strh	r2, [r3, #36]	; 0x24
	_system_dfll_wait_for_sync();
    21d2:	4b0c      	ldr	r3, [pc, #48]	; (2204 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    21d4:	4798      	blx	r3

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    21d6:	4a0a      	ldr	r2, [pc, #40]	; (2200 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    21d8:	4b0b      	ldr	r3, [pc, #44]	; (2208 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
    21da:	689b      	ldr	r3, [r3, #8]
    21dc:	62d3      	str	r3, [r2, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    21de:	4a08      	ldr	r2, [pc, #32]	; (2200 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    21e0:	4b09      	ldr	r3, [pc, #36]	; (2208 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
    21e2:	685b      	ldr	r3, [r3, #4]
    21e4:	6293      	str	r3, [r2, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
    21e6:	4b06      	ldr	r3, [pc, #24]	; (2200 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    21e8:	2200      	movs	r2, #0
    21ea:	849a      	strh	r2, [r3, #36]	; 0x24
	_system_dfll_wait_for_sync();
    21ec:	4b05      	ldr	r3, [pc, #20]	; (2204 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    21ee:	4798      	blx	r3
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    21f0:	4a03      	ldr	r2, [pc, #12]	; (2200 <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    21f2:	4b05      	ldr	r3, [pc, #20]	; (2208 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
    21f4:	681b      	ldr	r3, [r3, #0]
    21f6:	b29b      	uxth	r3, r3
    21f8:	8493      	strh	r3, [r2, #36]	; 0x24
}
    21fa:	46c0      	nop			; (mov r8, r8)
    21fc:	46bd      	mov	sp, r7
    21fe:	bd80      	pop	{r7, pc}
    2200:	40000800 	.word	0x40000800
    2204:	000021ad 	.word	0x000021ad
    2208:	20000160 	.word	0x20000160

0000220c <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    220c:	b580      	push	{r7, lr}
    220e:	b082      	sub	sp, #8
    2210:	af00      	add	r7, sp, #0
    2212:	0002      	movs	r2, r0
    2214:	1dfb      	adds	r3, r7, #7
    2216:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
    2218:	1dfb      	adds	r3, r7, #7
    221a:	781b      	ldrb	r3, [r3, #0]
    221c:	2b08      	cmp	r3, #8
    221e:	d841      	bhi.n	22a4 <system_clock_source_get_hz+0x98>
    2220:	009a      	lsls	r2, r3, #2
    2222:	4b23      	ldr	r3, [pc, #140]	; (22b0 <system_clock_source_get_hz+0xa4>)
    2224:	18d3      	adds	r3, r2, r3
    2226:	681b      	ldr	r3, [r3, #0]
    2228:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    222a:	4b22      	ldr	r3, [pc, #136]	; (22b4 <system_clock_source_get_hz+0xa8>)
    222c:	691b      	ldr	r3, [r3, #16]
    222e:	e03a      	b.n	22a6 <system_clock_source_get_hz+0x9a>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    2230:	4b21      	ldr	r3, [pc, #132]	; (22b8 <system_clock_source_get_hz+0xac>)
    2232:	6a1b      	ldr	r3, [r3, #32]
    2234:	059b      	lsls	r3, r3, #22
    2236:	0f9b      	lsrs	r3, r3, #30
    2238:	b2db      	uxtb	r3, r3
    223a:	001a      	movs	r2, r3
    223c:	4b1f      	ldr	r3, [pc, #124]	; (22bc <system_clock_source_get_hz+0xb0>)
    223e:	40d3      	lsrs	r3, r2
    2240:	e031      	b.n	22a6 <system_clock_source_get_hz+0x9a>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    2242:	2380      	movs	r3, #128	; 0x80
    2244:	021b      	lsls	r3, r3, #8
    2246:	e02e      	b.n	22a6 <system_clock_source_get_hz+0x9a>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;
    2248:	2380      	movs	r3, #128	; 0x80
    224a:	021b      	lsls	r3, r3, #8
    224c:	e02b      	b.n	22a6 <system_clock_source_get_hz+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    224e:	4b19      	ldr	r3, [pc, #100]	; (22b4 <system_clock_source_get_hz+0xa8>)
    2250:	695b      	ldr	r3, [r3, #20]
    2252:	e028      	b.n	22a6 <system_clock_source_get_hz+0x9a>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    2254:	4b17      	ldr	r3, [pc, #92]	; (22b4 <system_clock_source_get_hz+0xa8>)
    2256:	681b      	ldr	r3, [r3, #0]
    2258:	2202      	movs	r2, #2
    225a:	4013      	ands	r3, r2
    225c:	d101      	bne.n	2262 <system_clock_source_get_hz+0x56>
			return 0;
    225e:	2300      	movs	r3, #0
    2260:	e021      	b.n	22a6 <system_clock_source_get_hz+0x9a>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();
    2262:	4b17      	ldr	r3, [pc, #92]	; (22c0 <system_clock_source_get_hz+0xb4>)
    2264:	4798      	blx	r3

		/* Check if operating in closed loop (USB) mode */
		switch(_system_clock_inst.dfll.control &
    2266:	4b13      	ldr	r3, [pc, #76]	; (22b4 <system_clock_source_get_hz+0xa8>)
    2268:	681b      	ldr	r3, [r3, #0]
    226a:	2224      	movs	r2, #36	; 0x24
    226c:	4013      	ands	r3, r2
    226e:	2b04      	cmp	r3, #4
    2270:	d109      	bne.n	2286 <system_clock_source_get_hz+0x7a>
				(SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_USBCRM)) {
		case SYSCTRL_DFLLCTRL_MODE:
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    2272:	2000      	movs	r0, #0
    2274:	4b13      	ldr	r3, [pc, #76]	; (22c4 <system_clock_source_get_hz+0xb8>)
    2276:	4798      	blx	r3
    2278:	0002      	movs	r2, r0
					(_system_clock_inst.dfll.mul & 0xffff);
    227a:	4b0e      	ldr	r3, [pc, #56]	; (22b4 <system_clock_source_get_hz+0xa8>)
    227c:	689b      	ldr	r3, [r3, #8]
    227e:	041b      	lsls	r3, r3, #16
    2280:	0c1b      	lsrs	r3, r3, #16
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    2282:	4353      	muls	r3, r2
    2284:	e00f      	b.n	22a6 <system_clock_source_get_hz+0x9a>
		default:
			return 48000000UL;
    2286:	4b10      	ldr	r3, [pc, #64]	; (22c8 <system_clock_source_get_hz+0xbc>)
    2288:	e00d      	b.n	22a6 <system_clock_source_get_hz+0x9a>
		}

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    228a:	4a0b      	ldr	r2, [pc, #44]	; (22b8 <system_clock_source_get_hz+0xac>)
    228c:	2350      	movs	r3, #80	; 0x50
    228e:	5cd3      	ldrb	r3, [r2, r3]
    2290:	b2db      	uxtb	r3, r3
    2292:	001a      	movs	r2, r3
    2294:	2304      	movs	r3, #4
    2296:	4013      	ands	r3, r2
    2298:	d101      	bne.n	229e <system_clock_source_get_hz+0x92>
			return 0;
    229a:	2300      	movs	r3, #0
    229c:	e003      	b.n	22a6 <system_clock_source_get_hz+0x9a>
		}

		return _system_clock_inst.dpll.frequency;
    229e:	4b05      	ldr	r3, [pc, #20]	; (22b4 <system_clock_source_get_hz+0xa8>)
    22a0:	68db      	ldr	r3, [r3, #12]
    22a2:	e000      	b.n	22a6 <system_clock_source_get_hz+0x9a>
#endif

	default:
		return 0;
    22a4:	2300      	movs	r3, #0
	}
}
    22a6:	0018      	movs	r0, r3
    22a8:	46bd      	mov	sp, r7
    22aa:	b002      	add	sp, #8
    22ac:	bd80      	pop	{r7, pc}
    22ae:	46c0      	nop			; (mov r8, r8)
    22b0:	0000464c 	.word	0x0000464c
    22b4:	20000160 	.word	0x20000160
    22b8:	40000800 	.word	0x40000800
    22bc:	007a1200 	.word	0x007a1200
    22c0:	000021ad 	.word	0x000021ad
    22c4:	00002e4d 	.word	0x00002e4d
    22c8:	02dc6c00 	.word	0x02dc6c00

000022cc <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    22cc:	b580      	push	{r7, lr}
    22ce:	b084      	sub	sp, #16
    22d0:	af00      	add	r7, sp, #0
    22d2:	6078      	str	r0, [r7, #4]
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    22d4:	4b1a      	ldr	r3, [pc, #104]	; (2340 <system_clock_source_osc8m_set_config+0x74>)
    22d6:	6a1b      	ldr	r3, [r3, #32]
    22d8:	60fb      	str	r3, [r7, #12]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    22da:	687b      	ldr	r3, [r7, #4]
    22dc:	781b      	ldrb	r3, [r3, #0]
    22de:	1c1a      	adds	r2, r3, #0
    22e0:	2303      	movs	r3, #3
    22e2:	4013      	ands	r3, r2
    22e4:	b2da      	uxtb	r2, r3
    22e6:	230d      	movs	r3, #13
    22e8:	18fb      	adds	r3, r7, r3
    22ea:	2103      	movs	r1, #3
    22ec:	400a      	ands	r2, r1
    22ee:	0010      	movs	r0, r2
    22f0:	781a      	ldrb	r2, [r3, #0]
    22f2:	2103      	movs	r1, #3
    22f4:	438a      	bics	r2, r1
    22f6:	1c11      	adds	r1, r2, #0
    22f8:	1c02      	adds	r2, r0, #0
    22fa:	430a      	orrs	r2, r1
    22fc:	701a      	strb	r2, [r3, #0]
	temp.bit.ONDEMAND = config->on_demand;
    22fe:	687b      	ldr	r3, [r7, #4]
    2300:	789a      	ldrb	r2, [r3, #2]
    2302:	230c      	movs	r3, #12
    2304:	18fb      	adds	r3, r7, r3
    2306:	01d0      	lsls	r0, r2, #7
    2308:	781a      	ldrb	r2, [r3, #0]
    230a:	217f      	movs	r1, #127	; 0x7f
    230c:	400a      	ands	r2, r1
    230e:	1c11      	adds	r1, r2, #0
    2310:	1c02      	adds	r2, r0, #0
    2312:	430a      	orrs	r2, r1
    2314:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
    2316:	687b      	ldr	r3, [r7, #4]
    2318:	785a      	ldrb	r2, [r3, #1]
    231a:	230c      	movs	r3, #12
    231c:	18fb      	adds	r3, r7, r3
    231e:	2101      	movs	r1, #1
    2320:	400a      	ands	r2, r1
    2322:	0190      	lsls	r0, r2, #6
    2324:	781a      	ldrb	r2, [r3, #0]
    2326:	2140      	movs	r1, #64	; 0x40
    2328:	438a      	bics	r2, r1
    232a:	1c11      	adds	r1, r2, #0
    232c:	1c02      	adds	r2, r0, #0
    232e:	430a      	orrs	r2, r1
    2330:	701a      	strb	r2, [r3, #0]

	SYSCTRL->OSC8M = temp;
    2332:	4b03      	ldr	r3, [pc, #12]	; (2340 <system_clock_source_osc8m_set_config+0x74>)
    2334:	68fa      	ldr	r2, [r7, #12]
    2336:	621a      	str	r2, [r3, #32]
}
    2338:	46c0      	nop			; (mov r8, r8)
    233a:	46bd      	mov	sp, r7
    233c:	b004      	add	sp, #16
    233e:	bd80      	pop	{r7, pc}
    2340:	40000800 	.word	0x40000800

00002344 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    2344:	b580      	push	{r7, lr}
    2346:	b084      	sub	sp, #16
    2348:	af00      	add	r7, sp, #0
    234a:	6078      	str	r0, [r7, #4]
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    234c:	4a43      	ldr	r2, [pc, #268]	; (245c <system_clock_source_xosc32k_set_config+0x118>)
    234e:	230c      	movs	r3, #12
    2350:	18fb      	adds	r3, r7, r3
    2352:	8a92      	ldrh	r2, [r2, #20]
    2354:	801a      	strh	r2, [r3, #0]

	temp.bit.STARTUP = config->startup_time;
    2356:	687b      	ldr	r3, [r7, #4]
    2358:	785b      	ldrb	r3, [r3, #1]
    235a:	1c1a      	adds	r2, r3, #0
    235c:	2307      	movs	r3, #7
    235e:	4013      	ands	r3, r2
    2360:	b2da      	uxtb	r2, r3
    2362:	230c      	movs	r3, #12
    2364:	18fb      	adds	r3, r7, r3
    2366:	2107      	movs	r1, #7
    2368:	400a      	ands	r2, r1
    236a:	0010      	movs	r0, r2
    236c:	785a      	ldrb	r2, [r3, #1]
    236e:	2107      	movs	r1, #7
    2370:	438a      	bics	r2, r1
    2372:	1c11      	adds	r1, r2, #0
    2374:	1c02      	adds	r2, r0, #0
    2376:	430a      	orrs	r2, r1
    2378:	705a      	strb	r2, [r3, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    237a:	687b      	ldr	r3, [r7, #4]
    237c:	781b      	ldrb	r3, [r3, #0]
    237e:	2b00      	cmp	r3, #0
    2380:	d106      	bne.n	2390 <system_clock_source_xosc32k_set_config+0x4c>
		temp.bit.XTALEN = 1;
    2382:	230c      	movs	r3, #12
    2384:	18fb      	adds	r3, r7, r3
    2386:	781a      	ldrb	r2, [r3, #0]
    2388:	2104      	movs	r1, #4
    238a:	430a      	orrs	r2, r1
    238c:	701a      	strb	r2, [r3, #0]
    238e:	e005      	b.n	239c <system_clock_source_xosc32k_set_config+0x58>
	} else {
		temp.bit.XTALEN = 0;
    2390:	230c      	movs	r3, #12
    2392:	18fb      	adds	r3, r7, r3
    2394:	781a      	ldrb	r2, [r3, #0]
    2396:	2104      	movs	r1, #4
    2398:	438a      	bics	r2, r1
    239a:	701a      	strb	r2, [r3, #0]
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    239c:	687b      	ldr	r3, [r7, #4]
    239e:	789a      	ldrb	r2, [r3, #2]
    23a0:	230c      	movs	r3, #12
    23a2:	18fb      	adds	r3, r7, r3
    23a4:	2101      	movs	r1, #1
    23a6:	400a      	ands	r2, r1
    23a8:	0150      	lsls	r0, r2, #5
    23aa:	781a      	ldrb	r2, [r3, #0]
    23ac:	2120      	movs	r1, #32
    23ae:	438a      	bics	r2, r1
    23b0:	1c11      	adds	r1, r2, #0
    23b2:	1c02      	adds	r2, r0, #0
    23b4:	430a      	orrs	r2, r1
    23b6:	701a      	strb	r2, [r3, #0]
	temp.bit.EN1K = config->enable_1khz_output;
    23b8:	687b      	ldr	r3, [r7, #4]
    23ba:	78da      	ldrb	r2, [r3, #3]
    23bc:	230c      	movs	r3, #12
    23be:	18fb      	adds	r3, r7, r3
    23c0:	2101      	movs	r1, #1
    23c2:	400a      	ands	r2, r1
    23c4:	0110      	lsls	r0, r2, #4
    23c6:	781a      	ldrb	r2, [r3, #0]
    23c8:	2110      	movs	r1, #16
    23ca:	438a      	bics	r2, r1
    23cc:	1c11      	adds	r1, r2, #0
    23ce:	1c02      	adds	r2, r0, #0
    23d0:	430a      	orrs	r2, r1
    23d2:	701a      	strb	r2, [r3, #0]
	temp.bit.EN32K = config->enable_32khz_output;
    23d4:	687b      	ldr	r3, [r7, #4]
    23d6:	791a      	ldrb	r2, [r3, #4]
    23d8:	230c      	movs	r3, #12
    23da:	18fb      	adds	r3, r7, r3
    23dc:	2101      	movs	r1, #1
    23de:	400a      	ands	r2, r1
    23e0:	00d0      	lsls	r0, r2, #3
    23e2:	781a      	ldrb	r2, [r3, #0]
    23e4:	2108      	movs	r1, #8
    23e6:	438a      	bics	r2, r1
    23e8:	1c11      	adds	r1, r2, #0
    23ea:	1c02      	adds	r2, r0, #0
    23ec:	430a      	orrs	r2, r1
    23ee:	701a      	strb	r2, [r3, #0]

	temp.bit.ONDEMAND = config->on_demand;
    23f0:	687b      	ldr	r3, [r7, #4]
    23f2:	7b5a      	ldrb	r2, [r3, #13]
    23f4:	230c      	movs	r3, #12
    23f6:	18fb      	adds	r3, r7, r3
    23f8:	01d0      	lsls	r0, r2, #7
    23fa:	781a      	ldrb	r2, [r3, #0]
    23fc:	217f      	movs	r1, #127	; 0x7f
    23fe:	400a      	ands	r2, r1
    2400:	1c11      	adds	r1, r2, #0
    2402:	1c02      	adds	r2, r0, #0
    2404:	430a      	orrs	r2, r1
    2406:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
    2408:	687b      	ldr	r3, [r7, #4]
    240a:	7b1a      	ldrb	r2, [r3, #12]
    240c:	230c      	movs	r3, #12
    240e:	18fb      	adds	r3, r7, r3
    2410:	2101      	movs	r1, #1
    2412:	400a      	ands	r2, r1
    2414:	0190      	lsls	r0, r2, #6
    2416:	781a      	ldrb	r2, [r3, #0]
    2418:	2140      	movs	r1, #64	; 0x40
    241a:	438a      	bics	r2, r1
    241c:	1c11      	adds	r1, r2, #0
    241e:	1c02      	adds	r2, r0, #0
    2420:	430a      	orrs	r2, r1
    2422:	701a      	strb	r2, [r3, #0]
	temp.bit.WRTLOCK  = config->write_once;
    2424:	687b      	ldr	r3, [r7, #4]
    2426:	7b9a      	ldrb	r2, [r3, #14]
    2428:	230c      	movs	r3, #12
    242a:	18fb      	adds	r3, r7, r3
    242c:	2101      	movs	r1, #1
    242e:	400a      	ands	r2, r1
    2430:	0110      	lsls	r0, r2, #4
    2432:	785a      	ldrb	r2, [r3, #1]
    2434:	2110      	movs	r1, #16
    2436:	438a      	bics	r2, r1
    2438:	1c11      	adds	r1, r2, #0
    243a:	1c02      	adds	r2, r0, #0
    243c:	430a      	orrs	r2, r1
    243e:	705a      	strb	r2, [r3, #1]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    2440:	687b      	ldr	r3, [r7, #4]
    2442:	689a      	ldr	r2, [r3, #8]
    2444:	4b06      	ldr	r3, [pc, #24]	; (2460 <system_clock_source_xosc32k_set_config+0x11c>)
    2446:	615a      	str	r2, [r3, #20]

	SYSCTRL->XOSC32K = temp;
    2448:	4a04      	ldr	r2, [pc, #16]	; (245c <system_clock_source_xosc32k_set_config+0x118>)
    244a:	230c      	movs	r3, #12
    244c:	18fb      	adds	r3, r7, r3
    244e:	881b      	ldrh	r3, [r3, #0]
    2450:	8293      	strh	r3, [r2, #20]
}
    2452:	46c0      	nop			; (mov r8, r8)
    2454:	46bd      	mov	sp, r7
    2456:	b004      	add	sp, #16
    2458:	bd80      	pop	{r7, pc}
    245a:	46c0      	nop			; (mov r8, r8)
    245c:	40000800 	.word	0x40000800
    2460:	20000160 	.word	0x20000160

00002464 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    2464:	b580      	push	{r7, lr}
    2466:	b082      	sub	sp, #8
    2468:	af00      	add	r7, sp, #0
    246a:	6078      	str	r0, [r7, #4]
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    246c:	687b      	ldr	r3, [r7, #4]
    246e:	7a1b      	ldrb	r3, [r3, #8]
    2470:	029b      	lsls	r3, r3, #10
    2472:	041b      	lsls	r3, r3, #16
    2474:	0c1a      	lsrs	r2, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
    2476:	687b      	ldr	r3, [r7, #4]
    2478:	895b      	ldrh	r3, [r3, #10]
    247a:	059b      	lsls	r3, r3, #22
    247c:	0d9b      	lsrs	r3, r3, #22
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    247e:	431a      	orrs	r2, r3
	_system_clock_inst.dfll.val =
    2480:	4b2a      	ldr	r3, [pc, #168]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    2482:	605a      	str	r2, [r3, #4]

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    2484:	687b      	ldr	r3, [r7, #4]
    2486:	799a      	ldrb	r2, [r3, #6]
			(uint32_t)config->stable_tracking |
    2488:	687b      	ldr	r3, [r7, #4]
    248a:	79db      	ldrb	r3, [r3, #7]
			(uint32_t)config->wakeup_lock     |
    248c:	4313      	orrs	r3, r2
    248e:	b2db      	uxtb	r3, r3
    2490:	001a      	movs	r2, r3
			(uint32_t)config->quick_lock      |
    2492:	687b      	ldr	r3, [r7, #4]
    2494:	885b      	ldrh	r3, [r3, #2]
			(uint32_t)config->stable_tracking |
    2496:	4313      	orrs	r3, r2
			(uint32_t)config->chill_cycle     |
    2498:	687a      	ldr	r2, [r7, #4]
    249a:	8892      	ldrh	r2, [r2, #4]
			(uint32_t)config->quick_lock      |
    249c:	431a      	orrs	r2, r3
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    249e:	687b      	ldr	r3, [r7, #4]
    24a0:	785b      	ldrb	r3, [r3, #1]
    24a2:	01db      	lsls	r3, r3, #7
			(uint32_t)config->chill_cycle     |
    24a4:	431a      	orrs	r2, r3
	_system_clock_inst.dfll.control =
    24a6:	4b21      	ldr	r3, [pc, #132]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    24a8:	601a      	str	r2, [r3, #0]

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    24aa:	687b      	ldr	r3, [r7, #4]
    24ac:	781b      	ldrb	r3, [r3, #0]
    24ae:	2b04      	cmp	r3, #4
    24b0:	d116      	bne.n	24e0 <system_clock_source_dfll_set_config+0x7c>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    24b2:	687b      	ldr	r3, [r7, #4]
    24b4:	7b1b      	ldrb	r3, [r3, #12]
    24b6:	069b      	lsls	r3, r3, #26
    24b8:	001a      	movs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    24ba:	687b      	ldr	r3, [r7, #4]
    24bc:	89db      	ldrh	r3, [r3, #14]
    24be:	041b      	lsls	r3, r3, #16
    24c0:	0019      	movs	r1, r3
    24c2:	4b1b      	ldr	r3, [pc, #108]	; (2530 <system_clock_source_dfll_set_config+0xcc>)
    24c4:	400b      	ands	r3, r1
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    24c6:	4313      	orrs	r3, r2
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    24c8:	687a      	ldr	r2, [r7, #4]
    24ca:	8a12      	ldrh	r2, [r2, #16]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    24cc:	431a      	orrs	r2, r3
		_system_clock_inst.dfll.mul =
    24ce:	4b17      	ldr	r3, [pc, #92]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    24d0:	609a      	str	r2, [r3, #8]

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    24d2:	4b16      	ldr	r3, [pc, #88]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    24d4:	681b      	ldr	r3, [r3, #0]
    24d6:	687a      	ldr	r2, [r7, #4]
    24d8:	7812      	ldrb	r2, [r2, #0]
    24da:	431a      	orrs	r2, r3
    24dc:	4b13      	ldr	r3, [pc, #76]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    24de:	601a      	str	r2, [r3, #0]
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    24e0:	687b      	ldr	r3, [r7, #4]
    24e2:	781b      	ldrb	r3, [r3, #0]
    24e4:	2b20      	cmp	r3, #32
    24e6:	d11c      	bne.n	2522 <system_clock_source_dfll_set_config+0xbe>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    24e8:	687b      	ldr	r3, [r7, #4]
    24ea:	7b1b      	ldrb	r3, [r3, #12]
    24ec:	069b      	lsls	r3, r3, #26
    24ee:	001a      	movs	r2, r3
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    24f0:	687b      	ldr	r3, [r7, #4]
    24f2:	89db      	ldrh	r3, [r3, #14]
    24f4:	041b      	lsls	r3, r3, #16
    24f6:	0019      	movs	r1, r3
    24f8:	4b0d      	ldr	r3, [pc, #52]	; (2530 <system_clock_source_dfll_set_config+0xcc>)
    24fa:	400b      	ands	r3, r1
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    24fc:	4313      	orrs	r3, r2
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    24fe:	687a      	ldr	r2, [r7, #4]
    2500:	8a12      	ldrh	r2, [r2, #16]
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    2502:	431a      	orrs	r2, r3
		_system_clock_inst.dfll.mul =
    2504:	4b09      	ldr	r3, [pc, #36]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    2506:	609a      	str	r2, [r3, #8]

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    2508:	4b08      	ldr	r3, [pc, #32]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    250a:	681b      	ldr	r3, [r3, #0]
    250c:	687a      	ldr	r2, [r7, #4]
    250e:	7812      	ldrb	r2, [r2, #0]
    2510:	2104      	movs	r1, #4
    2512:	430a      	orrs	r2, r1
    2514:	b2d2      	uxtb	r2, r2
    2516:	4313      	orrs	r3, r2
    2518:	2280      	movs	r2, #128	; 0x80
    251a:	00d2      	lsls	r2, r2, #3
    251c:	431a      	orrs	r2, r3
    251e:	4b03      	ldr	r3, [pc, #12]	; (252c <system_clock_source_dfll_set_config+0xc8>)
    2520:	601a      	str	r2, [r3, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    2522:	46c0      	nop			; (mov r8, r8)
    2524:	46bd      	mov	sp, r7
    2526:	b002      	add	sp, #8
    2528:	bd80      	pop	{r7, pc}
    252a:	46c0      	nop			; (mov r8, r8)
    252c:	20000160 	.word	0x20000160
    2530:	03ff0000 	.word	0x03ff0000

00002534 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
    2534:	b580      	push	{r7, lr}
    2536:	b082      	sub	sp, #8
    2538:	af00      	add	r7, sp, #0
    253a:	0002      	movs	r2, r0
    253c:	1dfb      	adds	r3, r7, #7
    253e:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
    2540:	1dfb      	adds	r3, r7, #7
    2542:	781b      	ldrb	r3, [r3, #0]
    2544:	2b08      	cmp	r3, #8
    2546:	d83b      	bhi.n	25c0 <system_clock_source_enable+0x8c>
    2548:	009a      	lsls	r2, r3, #2
    254a:	4b21      	ldr	r3, [pc, #132]	; (25d0 <system_clock_source_enable+0x9c>)
    254c:	18d3      	adds	r3, r2, r3
    254e:	681b      	ldr	r3, [r3, #0]
    2550:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    2552:	4b20      	ldr	r3, [pc, #128]	; (25d4 <system_clock_source_enable+0xa0>)
    2554:	4a1f      	ldr	r2, [pc, #124]	; (25d4 <system_clock_source_enable+0xa0>)
    2556:	6a12      	ldr	r2, [r2, #32]
    2558:	2102      	movs	r1, #2
    255a:	430a      	orrs	r2, r1
    255c:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
    255e:	2300      	movs	r3, #0
    2560:	e031      	b.n	25c6 <system_clock_source_enable+0x92>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    2562:	4b1c      	ldr	r3, [pc, #112]	; (25d4 <system_clock_source_enable+0xa0>)
    2564:	4a1b      	ldr	r2, [pc, #108]	; (25d4 <system_clock_source_enable+0xa0>)
    2566:	6992      	ldr	r2, [r2, #24]
    2568:	2102      	movs	r1, #2
    256a:	430a      	orrs	r2, r1
    256c:	619a      	str	r2, [r3, #24]
		break;
    256e:	e029      	b.n	25c4 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    2570:	4a18      	ldr	r2, [pc, #96]	; (25d4 <system_clock_source_enable+0xa0>)
    2572:	4b18      	ldr	r3, [pc, #96]	; (25d4 <system_clock_source_enable+0xa0>)
    2574:	8a1b      	ldrh	r3, [r3, #16]
    2576:	b29b      	uxth	r3, r3
    2578:	2102      	movs	r1, #2
    257a:	430b      	orrs	r3, r1
    257c:	b29b      	uxth	r3, r3
    257e:	8213      	strh	r3, [r2, #16]
		break;
    2580:	e020      	b.n	25c4 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    2582:	4a14      	ldr	r2, [pc, #80]	; (25d4 <system_clock_source_enable+0xa0>)
    2584:	4b13      	ldr	r3, [pc, #76]	; (25d4 <system_clock_source_enable+0xa0>)
    2586:	8a9b      	ldrh	r3, [r3, #20]
    2588:	b29b      	uxth	r3, r3
    258a:	2102      	movs	r1, #2
    258c:	430b      	orrs	r3, r1
    258e:	b29b      	uxth	r3, r3
    2590:	8293      	strh	r3, [r2, #20]
		break;
    2592:	e017      	b.n	25c4 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    2594:	4b10      	ldr	r3, [pc, #64]	; (25d8 <system_clock_source_enable+0xa4>)
    2596:	681b      	ldr	r3, [r3, #0]
    2598:	2202      	movs	r2, #2
    259a:	431a      	orrs	r2, r3
    259c:	4b0e      	ldr	r3, [pc, #56]	; (25d8 <system_clock_source_enable+0xa4>)
    259e:	601a      	str	r2, [r3, #0]
		_system_clock_source_dfll_set_config_errata_9905();
    25a0:	4b0e      	ldr	r3, [pc, #56]	; (25dc <system_clock_source_enable+0xa8>)
    25a2:	4798      	blx	r3
		break;
    25a4:	e00e      	b.n	25c4 <system_clock_source_enable+0x90>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    25a6:	4a0b      	ldr	r2, [pc, #44]	; (25d4 <system_clock_source_enable+0xa0>)
    25a8:	490a      	ldr	r1, [pc, #40]	; (25d4 <system_clock_source_enable+0xa0>)
    25aa:	2344      	movs	r3, #68	; 0x44
    25ac:	5ccb      	ldrb	r3, [r1, r3]
    25ae:	b2db      	uxtb	r3, r3
    25b0:	2102      	movs	r1, #2
    25b2:	430b      	orrs	r3, r1
    25b4:	b2d9      	uxtb	r1, r3
    25b6:	2344      	movs	r3, #68	; 0x44
    25b8:	54d1      	strb	r1, [r2, r3]
		break;
    25ba:	e003      	b.n	25c4 <system_clock_source_enable+0x90>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    25bc:	2300      	movs	r3, #0
    25be:	e002      	b.n	25c6 <system_clock_source_enable+0x92>

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    25c0:	2317      	movs	r3, #23
    25c2:	e000      	b.n	25c6 <system_clock_source_enable+0x92>
	}

	return STATUS_OK;
    25c4:	2300      	movs	r3, #0
}
    25c6:	0018      	movs	r0, r3
    25c8:	46bd      	mov	sp, r7
    25ca:	b002      	add	sp, #8
    25cc:	bd80      	pop	{r7, pc}
    25ce:	46c0      	nop			; (mov r8, r8)
    25d0:	00004670 	.word	0x00004670
    25d4:	40000800 	.word	0x40000800
    25d8:	20000160 	.word	0x20000160
    25dc:	000021c9 	.word	0x000021c9

000025e0 <system_clock_source_is_ready>:
 * \retval true   Clock source is enabled and ready
 * \retval false  Clock source is disabled or not yet ready
 */
bool system_clock_source_is_ready(
		const enum system_clock_source clock_source)
{
    25e0:	b580      	push	{r7, lr}
    25e2:	b084      	sub	sp, #16
    25e4:	af00      	add	r7, sp, #0
    25e6:	0002      	movs	r2, r0
    25e8:	1dfb      	adds	r3, r7, #7
    25ea:	701a      	strb	r2, [r3, #0]
	uint32_t mask = 0;
    25ec:	2300      	movs	r3, #0
    25ee:	60fb      	str	r3, [r7, #12]

	switch (clock_source) {
    25f0:	1dfb      	adds	r3, r7, #7
    25f2:	781b      	ldrb	r3, [r3, #0]
    25f4:	2b08      	cmp	r3, #8
    25f6:	d821      	bhi.n	263c <system_clock_source_is_ready+0x5c>
    25f8:	009a      	lsls	r2, r3, #2
    25fa:	4b18      	ldr	r3, [pc, #96]	; (265c <system_clock_source_is_ready+0x7c>)
    25fc:	18d3      	adds	r3, r2, r3
    25fe:	681b      	ldr	r3, [r3, #0]
    2600:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		mask = SYSCTRL_PCLKSR_OSC8MRDY;
    2602:	2308      	movs	r3, #8
    2604:	60fb      	str	r3, [r7, #12]
		break;
    2606:	e01b      	b.n	2640 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		mask = SYSCTRL_PCLKSR_OSC32KRDY;
    2608:	2304      	movs	r3, #4
    260a:	60fb      	str	r3, [r7, #12]
		break;
    260c:	e018      	b.n	2640 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		mask = SYSCTRL_PCLKSR_XOSCRDY;
    260e:	2301      	movs	r3, #1
    2610:	60fb      	str	r3, [r7, #12]
		break;
    2612:	e015      	b.n	2640 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = SYSCTRL_PCLKSR_XOSC32KRDY;
    2614:	2302      	movs	r3, #2
    2616:	60fb      	str	r3, [r7, #12]
		break;
    2618:	e012      	b.n	2640 <system_clock_source_is_ready+0x60>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
			mask = (SYSCTRL_PCLKSR_DFLLRDY |
    261a:	23d0      	movs	r3, #208	; 0xd0
    261c:	60fb      	str	r3, [r7, #12]
			        SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC);
		} else {
			mask = SYSCTRL_PCLKSR_DFLLRDY;
		}
		break;
    261e:	e00f      	b.n	2640 <system_clock_source_is_ready+0x60>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		return ((SYSCTRL->DPLLSTATUS.reg &
    2620:	4a0f      	ldr	r2, [pc, #60]	; (2660 <system_clock_source_is_ready+0x80>)
    2622:	2350      	movs	r3, #80	; 0x50
    2624:	5cd3      	ldrb	r3, [r2, r3]
    2626:	b2db      	uxtb	r3, r3
    2628:	001a      	movs	r2, r3
    262a:	2303      	movs	r3, #3
    262c:	4013      	ands	r3, r2
				(SYSCTRL_DPLLSTATUS_CLKRDY | SYSCTRL_DPLLSTATUS_LOCK)) ==
    262e:	3b03      	subs	r3, #3
    2630:	425a      	negs	r2, r3
    2632:	4153      	adcs	r3, r2
    2634:	b2db      	uxtb	r3, r3
    2636:	e00c      	b.n	2652 <system_clock_source_is_ready+0x72>
				(SYSCTRL_DPLLSTATUS_CLKRDY | SYSCTRL_DPLLSTATUS_LOCK));
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Not possible to disable */
		return true;
    2638:	2301      	movs	r3, #1
    263a:	e00a      	b.n	2652 <system_clock_source_is_ready+0x72>

	default:
		return false;
    263c:	2300      	movs	r3, #0
    263e:	e008      	b.n	2652 <system_clock_source_is_ready+0x72>
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    2640:	4b07      	ldr	r3, [pc, #28]	; (2660 <system_clock_source_is_ready+0x80>)
    2642:	68db      	ldr	r3, [r3, #12]
    2644:	68fa      	ldr	r2, [r7, #12]
    2646:	401a      	ands	r2, r3
    2648:	68fb      	ldr	r3, [r7, #12]
    264a:	1ad3      	subs	r3, r2, r3
    264c:	425a      	negs	r2, r3
    264e:	4153      	adcs	r3, r2
    2650:	b2db      	uxtb	r3, r3
}
    2652:	0018      	movs	r0, r3
    2654:	46bd      	mov	sp, r7
    2656:	b004      	add	sp, #16
    2658:	bd80      	pop	{r7, pc}
    265a:	46c0      	nop			; (mov r8, r8)
    265c:	00004694 	.word	0x00004694
    2660:	40000800 	.word	0x40000800

00002664 <_switch_peripheral_gclk>:
 *
 * Switch all peripheral clock to a not enabled general clock
 * to save power.
 */
static void _switch_peripheral_gclk(void)
{
    2664:	b580      	push	{r7, lr}
    2666:	b082      	sub	sp, #8
    2668:	af00      	add	r7, sp, #0
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    266a:	003b      	movs	r3, r7
    266c:	2202      	movs	r2, #2
    266e:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    2670:	2300      	movs	r3, #0
    2672:	607b      	str	r3, [r7, #4]
    2674:	e009      	b.n	268a <_switch_peripheral_gclk+0x26>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    2676:	687b      	ldr	r3, [r7, #4]
    2678:	b2db      	uxtb	r3, r3
    267a:	003a      	movs	r2, r7
    267c:	0011      	movs	r1, r2
    267e:	0018      	movs	r0, r3
    2680:	4b05      	ldr	r3, [pc, #20]	; (2698 <_switch_peripheral_gclk+0x34>)
    2682:	4798      	blx	r3
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    2684:	687b      	ldr	r3, [r7, #4]
    2686:	3301      	adds	r3, #1
    2688:	607b      	str	r3, [r7, #4]
    268a:	687b      	ldr	r3, [r7, #4]
    268c:	2b24      	cmp	r3, #36	; 0x24
    268e:	d9f2      	bls.n	2676 <_switch_peripheral_gclk+0x12>
	}
}
    2690:	46c0      	nop			; (mov r8, r8)
    2692:	46bd      	mov	sp, r7
    2694:	b002      	add	sp, #8
    2696:	bd80      	pop	{r7, pc}
    2698:	00002d29 	.word	0x00002d29

0000269c <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    269c:	b580      	push	{r7, lr}
    269e:	b0aa      	sub	sp, #168	; 0xa8
    26a0:	af00      	add	r7, sp, #0
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    26a2:	4bc1      	ldr	r3, [pc, #772]	; (29a8 <system_clock_init+0x30c>)
    26a4:	22c2      	movs	r2, #194	; 0xc2
    26a6:	00d2      	lsls	r2, r2, #3
    26a8:	609a      	str	r2, [r3, #8]
			SYSCTRL_INTFLAG_DFLLRDY;

	system_flash_set_waitstates(CONF_CLOCK_FLASH_WAIT_STATES);
    26aa:	2002      	movs	r0, #2
    26ac:	4bbf      	ldr	r3, [pc, #764]	; (29ac <system_clock_init+0x310>)
    26ae:	4798      	blx	r3

	/* Switch all peripheral clock to a not enabled general clock to save power. */
	_switch_peripheral_gclk();
    26b0:	4bbf      	ldr	r3, [pc, #764]	; (29b0 <system_clock_init+0x314>)
    26b2:	4798      	blx	r3


	/* XOSC32K */
#if CONF_CLOCK_XOSC32K_ENABLE == true
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);
    26b4:	2394      	movs	r3, #148	; 0x94
    26b6:	18fb      	adds	r3, r7, r3
    26b8:	0018      	movs	r0, r3
    26ba:	4bbe      	ldr	r3, [pc, #760]	; (29b4 <system_clock_init+0x318>)
    26bc:	4798      	blx	r3

	xosc32k_conf.frequency           = 32768UL;
    26be:	2394      	movs	r3, #148	; 0x94
    26c0:	18fb      	adds	r3, r7, r3
    26c2:	2280      	movs	r2, #128	; 0x80
    26c4:	0212      	lsls	r2, r2, #8
    26c6:	609a      	str	r2, [r3, #8]
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
    26c8:	2394      	movs	r3, #148	; 0x94
    26ca:	18fb      	adds	r3, r7, r3
    26cc:	2200      	movs	r2, #0
    26ce:	701a      	strb	r2, [r3, #0]
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    26d0:	2394      	movs	r3, #148	; 0x94
    26d2:	18fb      	adds	r3, r7, r3
    26d4:	2206      	movs	r2, #6
    26d6:	705a      	strb	r2, [r3, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
    26d8:	2394      	movs	r3, #148	; 0x94
    26da:	18fb      	adds	r3, r7, r3
    26dc:	2200      	movs	r2, #0
    26de:	709a      	strb	r2, [r3, #2]
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
    26e0:	2394      	movs	r3, #148	; 0x94
    26e2:	18fb      	adds	r3, r7, r3
    26e4:	2200      	movs	r2, #0
    26e6:	70da      	strb	r2, [r3, #3]
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
    26e8:	2394      	movs	r3, #148	; 0x94
    26ea:	18fb      	adds	r3, r7, r3
    26ec:	2201      	movs	r2, #1
    26ee:	711a      	strb	r2, [r3, #4]
	xosc32k_conf.on_demand           = false;
    26f0:	2394      	movs	r3, #148	; 0x94
    26f2:	18fb      	adds	r3, r7, r3
    26f4:	2200      	movs	r2, #0
    26f6:	735a      	strb	r2, [r3, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;
    26f8:	2394      	movs	r3, #148	; 0x94
    26fa:	18fb      	adds	r3, r7, r3
    26fc:	2201      	movs	r2, #1
    26fe:	731a      	strb	r2, [r3, #12]

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    2700:	2394      	movs	r3, #148	; 0x94
    2702:	18fb      	adds	r3, r7, r3
    2704:	0018      	movs	r0, r3
    2706:	4bac      	ldr	r3, [pc, #688]	; (29b8 <system_clock_init+0x31c>)
    2708:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    270a:	2005      	movs	r0, #5
    270c:	4bab      	ldr	r3, [pc, #684]	; (29bc <system_clock_init+0x320>)
    270e:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    2710:	46c0      	nop			; (mov r8, r8)
    2712:	2005      	movs	r0, #5
    2714:	4baa      	ldr	r3, [pc, #680]	; (29c0 <system_clock_init+0x324>)
    2716:	4798      	blx	r3
    2718:	0003      	movs	r3, r0
    271a:	001a      	movs	r2, r3
    271c:	2301      	movs	r3, #1
    271e:	4053      	eors	r3, r2
    2720:	b2db      	uxtb	r3, r3
    2722:	2b00      	cmp	r3, #0
    2724:	d1f5      	bne.n	2712 <system_clock_init+0x76>


	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);
    2726:	2380      	movs	r3, #128	; 0x80
    2728:	18fb      	adds	r3, r7, r3
    272a:	0018      	movs	r0, r3
    272c:	4ba5      	ldr	r3, [pc, #660]	; (29c4 <system_clock_init+0x328>)
    272e:	4798      	blx	r3

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    2730:	2380      	movs	r3, #128	; 0x80
    2732:	18fb      	adds	r3, r7, r3
    2734:	2204      	movs	r2, #4
    2736:	701a      	strb	r2, [r3, #0]
	dfll_conf.on_demand      = false;
    2738:	2380      	movs	r3, #128	; 0x80
    273a:	18fb      	adds	r3, r7, r3
    273c:	2200      	movs	r2, #0
    273e:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
    2740:	4ba1      	ldr	r3, [pc, #644]	; (29c8 <system_clock_init+0x32c>)
    2742:	681b      	ldr	r3, [r3, #0]
    2744:	0e9b      	lsrs	r3, r3, #26
    2746:	22a4      	movs	r2, #164	; 0xa4
    2748:	18ba      	adds	r2, r7, r2
    274a:	6013      	str	r3, [r2, #0]
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
    274c:	23a4      	movs	r3, #164	; 0xa4
    274e:	18fb      	adds	r3, r7, r3
    2750:	681b      	ldr	r3, [r3, #0]
    2752:	2b3f      	cmp	r3, #63	; 0x3f
    2754:	d103      	bne.n	275e <system_clock_init+0xc2>
		coarse = 0x1f;
    2756:	231f      	movs	r3, #31
    2758:	22a4      	movs	r2, #164	; 0xa4
    275a:	18ba      	adds	r2, r7, r2
    275c:	6013      	str	r3, [r2, #0]
	}
	dfll_conf.coarse_value = coarse;
    275e:	23a4      	movs	r3, #164	; 0xa4
    2760:	18fb      	adds	r3, r7, r3
    2762:	681b      	ldr	r3, [r3, #0]
    2764:	b2da      	uxtb	r2, r3
    2766:	2380      	movs	r3, #128	; 0x80
    2768:	18fb      	adds	r3, r7, r3
    276a:	721a      	strb	r2, [r3, #8]
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN) {
		dfll_conf.fine_value   = CONF_CLOCK_DFLL_FINE_VALUE;
	}

#  if CONF_CLOCK_DFLL_QUICK_LOCK == true
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    276c:	2380      	movs	r3, #128	; 0x80
    276e:	18fb      	adds	r3, r7, r3
    2770:	2200      	movs	r2, #0
    2772:	805a      	strh	r2, [r3, #2]
#  else
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_DISABLE;
#  endif

#  if CONF_CLOCK_DFLL_TRACK_AFTER_FINE_LOCK == true
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    2774:	2380      	movs	r3, #128	; 0x80
    2776:	18fb      	adds	r3, r7, r3
    2778:	2200      	movs	r2, #0
    277a:	71da      	strb	r2, [r3, #7]
#  else
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_FIX_AFTER_LOCK;
#  endif

#  if CONF_CLOCK_DFLL_KEEP_LOCK_ON_WAKEUP == true
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    277c:	2380      	movs	r3, #128	; 0x80
    277e:	18fb      	adds	r3, r7, r3
    2780:	2200      	movs	r2, #0
    2782:	719a      	strb	r2, [r3, #6]
#  else
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_LOSE;
#  endif

#  if CONF_CLOCK_DFLL_ENABLE_CHILL_CYCLE == true
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    2784:	2380      	movs	r3, #128	; 0x80
    2786:	18fb      	adds	r3, r7, r3
    2788:	2200      	movs	r2, #0
    278a:	809a      	strh	r2, [r3, #4]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    278c:	2380      	movs	r3, #128	; 0x80
    278e:	18fb      	adds	r3, r7, r3
    2790:	22b7      	movs	r2, #183	; 0xb7
    2792:	00d2      	lsls	r2, r2, #3
    2794:	821a      	strh	r2, [r3, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    2796:	2380      	movs	r3, #128	; 0x80
    2798:	18fb      	adds	r3, r7, r3
    279a:	2203      	movs	r2, #3
    279c:	731a      	strb	r2, [r3, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    279e:	2380      	movs	r3, #128	; 0x80
    27a0:	18fb      	adds	r3, r7, r3
    27a2:	221f      	movs	r2, #31
    27a4:	81da      	strh	r2, [r3, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    27a6:	2380      	movs	r3, #128	; 0x80
    27a8:	18fb      	adds	r3, r7, r3
    27aa:	0018      	movs	r0, r3
    27ac:	4b87      	ldr	r3, [pc, #540]	; (29cc <system_clock_init+0x330>)
    27ae:	4798      	blx	r3
#endif


	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);
    27b0:	237c      	movs	r3, #124	; 0x7c
    27b2:	18fb      	adds	r3, r7, r3
    27b4:	0018      	movs	r0, r3
    27b6:	4b86      	ldr	r3, [pc, #536]	; (29d0 <system_clock_init+0x334>)
    27b8:	4798      	blx	r3

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    27ba:	237c      	movs	r3, #124	; 0x7c
    27bc:	18fb      	adds	r3, r7, r3
    27be:	2200      	movs	r2, #0
    27c0:	701a      	strb	r2, [r3, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
    27c2:	237c      	movs	r3, #124	; 0x7c
    27c4:	18fb      	adds	r3, r7, r3
    27c6:	2201      	movs	r2, #1
    27c8:	709a      	strb	r2, [r3, #2]
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;
    27ca:	237c      	movs	r3, #124	; 0x7c
    27cc:	18fb      	adds	r3, r7, r3
    27ce:	2201      	movs	r2, #1
    27d0:	705a      	strb	r2, [r3, #1]

	system_clock_source_osc8m_set_config(&osc8m_conf);
    27d2:	237c      	movs	r3, #124	; 0x7c
    27d4:	18fb      	adds	r3, r7, r3
    27d6:	0018      	movs	r0, r3
    27d8:	4b7e      	ldr	r3, [pc, #504]	; (29d4 <system_clock_init+0x338>)
    27da:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    27dc:	2006      	movs	r0, #6
    27de:	4b77      	ldr	r3, [pc, #476]	; (29bc <system_clock_init+0x320>)
    27e0:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    27e2:	4b7d      	ldr	r3, [pc, #500]	; (29d8 <system_clock_init+0x33c>)
    27e4:	4798      	blx	r3

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    27e6:	2364      	movs	r3, #100	; 0x64
    27e8:	18fb      	adds	r3, r7, r3
    27ea:	0018      	movs	r0, r3
    27ec:	4b7b      	ldr	r3, [pc, #492]	; (29dc <system_clock_init+0x340>)
    27ee:	4798      	blx	r3
    27f0:	2364      	movs	r3, #100	; 0x64
    27f2:	18fb      	adds	r3, r7, r3
    27f4:	2205      	movs	r2, #5
    27f6:	701a      	strb	r2, [r3, #0]
    27f8:	2364      	movs	r3, #100	; 0x64
    27fa:	18fb      	adds	r3, r7, r3
    27fc:	2201      	movs	r2, #1
    27fe:	605a      	str	r2, [r3, #4]
    2800:	2364      	movs	r3, #100	; 0x64
    2802:	18fb      	adds	r3, r7, r3
    2804:	2200      	movs	r2, #0
    2806:	721a      	strb	r2, [r3, #8]
    2808:	2364      	movs	r3, #100	; 0x64
    280a:	18fb      	adds	r3, r7, r3
    280c:	2200      	movs	r2, #0
    280e:	725a      	strb	r2, [r3, #9]
    2810:	2364      	movs	r3, #100	; 0x64
    2812:	18fb      	adds	r3, r7, r3
    2814:	0019      	movs	r1, r3
    2816:	2001      	movs	r0, #1
    2818:	4b71      	ldr	r3, [pc, #452]	; (29e0 <system_clock_init+0x344>)
    281a:	4798      	blx	r3
    281c:	2001      	movs	r0, #1
    281e:	4b71      	ldr	r3, [pc, #452]	; (29e4 <system_clock_init+0x348>)
    2820:	4798      	blx	r3
    2822:	234c      	movs	r3, #76	; 0x4c
    2824:	18fb      	adds	r3, r7, r3
    2826:	0018      	movs	r0, r3
    2828:	4b6c      	ldr	r3, [pc, #432]	; (29dc <system_clock_init+0x340>)
    282a:	4798      	blx	r3
    282c:	234c      	movs	r3, #76	; 0x4c
    282e:	18fb      	adds	r3, r7, r3
    2830:	2206      	movs	r2, #6
    2832:	701a      	strb	r2, [r3, #0]
    2834:	234c      	movs	r3, #76	; 0x4c
    2836:	18fb      	adds	r3, r7, r3
    2838:	2210      	movs	r2, #16
    283a:	605a      	str	r2, [r3, #4]
    283c:	234c      	movs	r3, #76	; 0x4c
    283e:	18fb      	adds	r3, r7, r3
    2840:	2200      	movs	r2, #0
    2842:	721a      	strb	r2, [r3, #8]
    2844:	234c      	movs	r3, #76	; 0x4c
    2846:	18fb      	adds	r3, r7, r3
    2848:	2200      	movs	r2, #0
    284a:	725a      	strb	r2, [r3, #9]
    284c:	234c      	movs	r3, #76	; 0x4c
    284e:	18fb      	adds	r3, r7, r3
    2850:	0019      	movs	r1, r3
    2852:	2003      	movs	r0, #3
    2854:	4b62      	ldr	r3, [pc, #392]	; (29e0 <system_clock_init+0x344>)
    2856:	4798      	blx	r3
    2858:	2003      	movs	r0, #3
    285a:	4b62      	ldr	r3, [pc, #392]	; (29e4 <system_clock_init+0x348>)
    285c:	4798      	blx	r3
    285e:	2340      	movs	r3, #64	; 0x40
    2860:	18fb      	adds	r3, r7, r3
    2862:	0018      	movs	r0, r3
    2864:	4b5d      	ldr	r3, [pc, #372]	; (29dc <system_clock_init+0x340>)
    2866:	4798      	blx	r3
    2868:	2340      	movs	r3, #64	; 0x40
    286a:	18fb      	adds	r3, r7, r3
    286c:	2203      	movs	r2, #3
    286e:	701a      	strb	r2, [r3, #0]
    2870:	2340      	movs	r3, #64	; 0x40
    2872:	18fb      	adds	r3, r7, r3
    2874:	2220      	movs	r2, #32
    2876:	605a      	str	r2, [r3, #4]
    2878:	2340      	movs	r3, #64	; 0x40
    287a:	18fb      	adds	r3, r7, r3
    287c:	2200      	movs	r2, #0
    287e:	721a      	strb	r2, [r3, #8]
    2880:	2340      	movs	r3, #64	; 0x40
    2882:	18fb      	adds	r3, r7, r3
    2884:	2200      	movs	r2, #0
    2886:	725a      	strb	r2, [r3, #9]
    2888:	2340      	movs	r3, #64	; 0x40
    288a:	18fb      	adds	r3, r7, r3
    288c:	0019      	movs	r1, r3
    288e:	2004      	movs	r0, #4
    2890:	4b53      	ldr	r3, [pc, #332]	; (29e0 <system_clock_init+0x344>)
    2892:	4798      	blx	r3
    2894:	2004      	movs	r0, #4
    2896:	4b53      	ldr	r3, [pc, #332]	; (29e4 <system_clock_init+0x348>)
    2898:	4798      	blx	r3
    289a:	2334      	movs	r3, #52	; 0x34
    289c:	18fb      	adds	r3, r7, r3
    289e:	0018      	movs	r0, r3
    28a0:	4b4e      	ldr	r3, [pc, #312]	; (29dc <system_clock_init+0x340>)
    28a2:	4798      	blx	r3
    28a4:	2334      	movs	r3, #52	; 0x34
    28a6:	18fb      	adds	r3, r7, r3
    28a8:	2207      	movs	r2, #7
    28aa:	701a      	strb	r2, [r3, #0]
    28ac:	2334      	movs	r3, #52	; 0x34
    28ae:	18fb      	adds	r3, r7, r3
    28b0:	2201      	movs	r2, #1
    28b2:	605a      	str	r2, [r3, #4]
    28b4:	2334      	movs	r3, #52	; 0x34
    28b6:	18fb      	adds	r3, r7, r3
    28b8:	2200      	movs	r2, #0
    28ba:	721a      	strb	r2, [r3, #8]
    28bc:	2334      	movs	r3, #52	; 0x34
    28be:	18fb      	adds	r3, r7, r3
    28c0:	2200      	movs	r2, #0
    28c2:	725a      	strb	r2, [r3, #9]
    28c4:	2334      	movs	r3, #52	; 0x34
    28c6:	18fb      	adds	r3, r7, r3
    28c8:	0019      	movs	r1, r3
    28ca:	2005      	movs	r0, #5
    28cc:	4b44      	ldr	r3, [pc, #272]	; (29e0 <system_clock_init+0x344>)
    28ce:	4798      	blx	r3
    28d0:	2005      	movs	r0, #5
    28d2:	4b44      	ldr	r3, [pc, #272]	; (29e4 <system_clock_init+0x348>)
    28d4:	4798      	blx	r3
    28d6:	2328      	movs	r3, #40	; 0x28
    28d8:	18fb      	adds	r3, r7, r3
    28da:	0018      	movs	r0, r3
    28dc:	4b3f      	ldr	r3, [pc, #252]	; (29dc <system_clock_init+0x340>)
    28de:	4798      	blx	r3
    28e0:	2328      	movs	r3, #40	; 0x28
    28e2:	18fb      	adds	r3, r7, r3
    28e4:	2206      	movs	r2, #6
    28e6:	701a      	strb	r2, [r3, #0]
    28e8:	2328      	movs	r3, #40	; 0x28
    28ea:	18fb      	adds	r3, r7, r3
    28ec:	2201      	movs	r2, #1
    28ee:	605a      	str	r2, [r3, #4]
    28f0:	2328      	movs	r3, #40	; 0x28
    28f2:	18fb      	adds	r3, r7, r3
    28f4:	2201      	movs	r2, #1
    28f6:	721a      	strb	r2, [r3, #8]
    28f8:	2328      	movs	r3, #40	; 0x28
    28fa:	18fb      	adds	r3, r7, r3
    28fc:	2200      	movs	r2, #0
    28fe:	725a      	strb	r2, [r3, #9]
    2900:	2328      	movs	r3, #40	; 0x28
    2902:	18fb      	adds	r3, r7, r3
    2904:	0019      	movs	r1, r3
    2906:	2006      	movs	r0, #6
    2908:	4b35      	ldr	r3, [pc, #212]	; (29e0 <system_clock_init+0x344>)
    290a:	4798      	blx	r3
    290c:	2006      	movs	r0, #6
    290e:	4b35      	ldr	r3, [pc, #212]	; (29e4 <system_clock_init+0x348>)
    2910:	4798      	blx	r3
#  if CONF_CLOCK_DFLL_ENABLE == true
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
    2912:	230c      	movs	r3, #12
    2914:	18fb      	adds	r3, r7, r3
    2916:	0018      	movs	r0, r3
    2918:	4b33      	ldr	r3, [pc, #204]	; (29e8 <system_clock_init+0x34c>)
    291a:	4798      	blx	r3
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    291c:	230c      	movs	r3, #12
    291e:	18fb      	adds	r3, r7, r3
    2920:	2201      	movs	r2, #1
    2922:	701a      	strb	r2, [r3, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    2924:	230c      	movs	r3, #12
    2926:	18fb      	adds	r3, r7, r3
    2928:	0019      	movs	r1, r3
    292a:	2000      	movs	r0, #0
    292c:	4b2f      	ldr	r3, [pc, #188]	; (29ec <system_clock_init+0x350>)
    292e:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    2930:	2000      	movs	r0, #0
    2932:	4b2f      	ldr	r3, [pc, #188]	; (29f0 <system_clock_init+0x354>)
    2934:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    2936:	2007      	movs	r0, #7
    2938:	4b20      	ldr	r3, [pc, #128]	; (29bc <system_clock_init+0x320>)
    293a:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    293c:	46c0      	nop			; (mov r8, r8)
    293e:	2007      	movs	r0, #7
    2940:	4b1f      	ldr	r3, [pc, #124]	; (29c0 <system_clock_init+0x324>)
    2942:	4798      	blx	r3
    2944:	0003      	movs	r3, r0
    2946:	001a      	movs	r2, r3
    2948:	2301      	movs	r3, #1
    294a:	4053      	eors	r3, r2
    294c:	b2db      	uxtb	r3, r3
    294e:	2b00      	cmp	r3, #0
    2950:	d1f5      	bne.n	293e <system_clock_init+0x2a2>

#  endif
#endif

	/* CPU and BUS clocks */
	system_cpu_clock_set_divider(CONF_CLOCK_CPU_DIVIDER);
    2952:	2000      	movs	r0, #0
    2954:	4b27      	ldr	r3, [pc, #156]	; (29f4 <system_clock_init+0x358>)
    2956:	4798      	blx	r3

	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBA, CONF_CLOCK_APBA_DIVIDER);
    2958:	2100      	movs	r1, #0
    295a:	2000      	movs	r0, #0
    295c:	4b26      	ldr	r3, [pc, #152]	; (29f8 <system_clock_init+0x35c>)
    295e:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);
    2960:	2100      	movs	r1, #0
    2962:	2001      	movs	r0, #1
    2964:	4b24      	ldr	r3, [pc, #144]	; (29f8 <system_clock_init+0x35c>)
    2966:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);
    2968:	2100      	movs	r1, #0
    296a:	2002      	movs	r0, #2
    296c:	4b22      	ldr	r3, [pc, #136]	; (29f8 <system_clock_init+0x35c>)
    296e:	4798      	blx	r3

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    2970:	003b      	movs	r3, r7
    2972:	0018      	movs	r0, r3
    2974:	4b19      	ldr	r3, [pc, #100]	; (29dc <system_clock_init+0x340>)
    2976:	4798      	blx	r3
    2978:	003b      	movs	r3, r7
    297a:	2207      	movs	r2, #7
    297c:	701a      	strb	r2, [r3, #0]
    297e:	003b      	movs	r3, r7
    2980:	2201      	movs	r2, #1
    2982:	605a      	str	r2, [r3, #4]
    2984:	003b      	movs	r3, r7
    2986:	2201      	movs	r2, #1
    2988:	721a      	strb	r2, [r3, #8]
    298a:	003b      	movs	r3, r7
    298c:	2200      	movs	r2, #0
    298e:	725a      	strb	r2, [r3, #9]
    2990:	003b      	movs	r3, r7
    2992:	0019      	movs	r1, r3
    2994:	2000      	movs	r0, #0
    2996:	4b12      	ldr	r3, [pc, #72]	; (29e0 <system_clock_init+0x344>)
    2998:	4798      	blx	r3
    299a:	2000      	movs	r0, #0
    299c:	4b11      	ldr	r3, [pc, #68]	; (29e4 <system_clock_init+0x348>)
    299e:	4798      	blx	r3
#endif
}
    29a0:	46c0      	nop			; (mov r8, r8)
    29a2:	46bd      	mov	sp, r7
    29a4:	b02a      	add	sp, #168	; 0xa8
    29a6:	bd80      	pop	{r7, pc}
    29a8:	40000800 	.word	0x40000800
    29ac:	00002179 	.word	0x00002179
    29b0:	00002665 	.word	0x00002665
    29b4:	00002049 	.word	0x00002049
    29b8:	00002345 	.word	0x00002345
    29bc:	00002535 	.word	0x00002535
    29c0:	000025e1 	.word	0x000025e1
    29c4:	000020b3 	.word	0x000020b3
    29c8:	00806024 	.word	0x00806024
    29cc:	00002465 	.word	0x00002465
    29d0:	00002091 	.word	0x00002091
    29d4:	000022cd 	.word	0x000022cd
    29d8:	00002aa1 	.word	0x00002aa1
    29dc:	00002005 	.word	0x00002005
    29e0:	00002ad1 	.word	0x00002ad1
    29e4:	00002bf5 	.word	0x00002bf5
    29e8:	00002033 	.word	0x00002033
    29ec:	00002d29 	.word	0x00002d29
    29f0:	00002d6d 	.word	0x00002d6d
    29f4:	00002105 	.word	0x00002105
    29f8:	00002125 	.word	0x00002125

000029fc <system_apb_clock_set_mask>:
{
    29fc:	b580      	push	{r7, lr}
    29fe:	b082      	sub	sp, #8
    2a00:	af00      	add	r7, sp, #0
    2a02:	0002      	movs	r2, r0
    2a04:	6039      	str	r1, [r7, #0]
    2a06:	1dfb      	adds	r3, r7, #7
    2a08:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    2a0a:	1dfb      	adds	r3, r7, #7
    2a0c:	781b      	ldrb	r3, [r3, #0]
    2a0e:	2b01      	cmp	r3, #1
    2a10:	d00a      	beq.n	2a28 <system_apb_clock_set_mask+0x2c>
    2a12:	2b02      	cmp	r3, #2
    2a14:	d00f      	beq.n	2a36 <system_apb_clock_set_mask+0x3a>
    2a16:	2b00      	cmp	r3, #0
    2a18:	d114      	bne.n	2a44 <system_apb_clock_set_mask+0x48>
			PM->APBAMASK.reg |= mask;
    2a1a:	4b0e      	ldr	r3, [pc, #56]	; (2a54 <system_apb_clock_set_mask+0x58>)
    2a1c:	4a0d      	ldr	r2, [pc, #52]	; (2a54 <system_apb_clock_set_mask+0x58>)
    2a1e:	6991      	ldr	r1, [r2, #24]
    2a20:	683a      	ldr	r2, [r7, #0]
    2a22:	430a      	orrs	r2, r1
    2a24:	619a      	str	r2, [r3, #24]
			break;
    2a26:	e00f      	b.n	2a48 <system_apb_clock_set_mask+0x4c>
			PM->APBBMASK.reg |= mask;
    2a28:	4b0a      	ldr	r3, [pc, #40]	; (2a54 <system_apb_clock_set_mask+0x58>)
    2a2a:	4a0a      	ldr	r2, [pc, #40]	; (2a54 <system_apb_clock_set_mask+0x58>)
    2a2c:	69d1      	ldr	r1, [r2, #28]
    2a2e:	683a      	ldr	r2, [r7, #0]
    2a30:	430a      	orrs	r2, r1
    2a32:	61da      	str	r2, [r3, #28]
			break;
    2a34:	e008      	b.n	2a48 <system_apb_clock_set_mask+0x4c>
			PM->APBCMASK.reg |= mask;
    2a36:	4b07      	ldr	r3, [pc, #28]	; (2a54 <system_apb_clock_set_mask+0x58>)
    2a38:	4a06      	ldr	r2, [pc, #24]	; (2a54 <system_apb_clock_set_mask+0x58>)
    2a3a:	6a11      	ldr	r1, [r2, #32]
    2a3c:	683a      	ldr	r2, [r7, #0]
    2a3e:	430a      	orrs	r2, r1
    2a40:	621a      	str	r2, [r3, #32]
			break;
    2a42:	e001      	b.n	2a48 <system_apb_clock_set_mask+0x4c>
			return STATUS_ERR_INVALID_ARG;
    2a44:	2317      	movs	r3, #23
    2a46:	e000      	b.n	2a4a <system_apb_clock_set_mask+0x4e>
	return STATUS_OK;
    2a48:	2300      	movs	r3, #0
}
    2a4a:	0018      	movs	r0, r3
    2a4c:	46bd      	mov	sp, r7
    2a4e:	b002      	add	sp, #8
    2a50:	bd80      	pop	{r7, pc}
    2a52:	46c0      	nop			; (mov r8, r8)
    2a54:	40000400 	.word	0x40000400

00002a58 <system_interrupt_enter_critical_section>:
{
    2a58:	b580      	push	{r7, lr}
    2a5a:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
    2a5c:	4b02      	ldr	r3, [pc, #8]	; (2a68 <system_interrupt_enter_critical_section+0x10>)
    2a5e:	4798      	blx	r3
}
    2a60:	46c0      	nop			; (mov r8, r8)
    2a62:	46bd      	mov	sp, r7
    2a64:	bd80      	pop	{r7, pc}
    2a66:	46c0      	nop			; (mov r8, r8)
    2a68:	00001f71 	.word	0x00001f71

00002a6c <system_interrupt_leave_critical_section>:
{
    2a6c:	b580      	push	{r7, lr}
    2a6e:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
    2a70:	4b02      	ldr	r3, [pc, #8]	; (2a7c <system_interrupt_leave_critical_section+0x10>)
    2a72:	4798      	blx	r3
}
    2a74:	46c0      	nop			; (mov r8, r8)
    2a76:	46bd      	mov	sp, r7
    2a78:	bd80      	pop	{r7, pc}
    2a7a:	46c0      	nop			; (mov r8, r8)
    2a7c:	00001fc5 	.word	0x00001fc5

00002a80 <system_gclk_is_syncing>:
 *
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
    2a80:	b580      	push	{r7, lr}
    2a82:	af00      	add	r7, sp, #0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    2a84:	4b05      	ldr	r3, [pc, #20]	; (2a9c <system_gclk_is_syncing+0x1c>)
    2a86:	785b      	ldrb	r3, [r3, #1]
    2a88:	b2db      	uxtb	r3, r3
    2a8a:	b25b      	sxtb	r3, r3
    2a8c:	2b00      	cmp	r3, #0
    2a8e:	da01      	bge.n	2a94 <system_gclk_is_syncing+0x14>
		return true;
    2a90:	2301      	movs	r3, #1
    2a92:	e000      	b.n	2a96 <system_gclk_is_syncing+0x16>
	}

	return false;
    2a94:	2300      	movs	r3, #0
}
    2a96:	0018      	movs	r0, r3
    2a98:	46bd      	mov	sp, r7
    2a9a:	bd80      	pop	{r7, pc}
    2a9c:	40000c00 	.word	0x40000c00

00002aa0 <system_gclk_init>:
 *
 * Initializes the Generic Clock module, disabling and resetting all active
 * Generic Clock Generators and Channels to their power-on default values.
 */
void system_gclk_init(void)
{
    2aa0:	b580      	push	{r7, lr}
    2aa2:	af00      	add	r7, sp, #0
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);
    2aa4:	2108      	movs	r1, #8
    2aa6:	2000      	movs	r0, #0
    2aa8:	4b07      	ldr	r3, [pc, #28]	; (2ac8 <system_gclk_init+0x28>)
    2aaa:	4798      	blx	r3

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    2aac:	4b07      	ldr	r3, [pc, #28]	; (2acc <system_gclk_init+0x2c>)
    2aae:	2201      	movs	r2, #1
    2ab0:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    2ab2:	46c0      	nop			; (mov r8, r8)
    2ab4:	4b05      	ldr	r3, [pc, #20]	; (2acc <system_gclk_init+0x2c>)
    2ab6:	781b      	ldrb	r3, [r3, #0]
    2ab8:	b2db      	uxtb	r3, r3
    2aba:	001a      	movs	r2, r3
    2abc:	2301      	movs	r3, #1
    2abe:	4013      	ands	r3, r2
    2ac0:	d1f8      	bne.n	2ab4 <system_gclk_init+0x14>
		/* Wait for reset to complete */
	}
}
    2ac2:	46c0      	nop			; (mov r8, r8)
    2ac4:	46bd      	mov	sp, r7
    2ac6:	bd80      	pop	{r7, pc}
    2ac8:	000029fd 	.word	0x000029fd
    2acc:	40000c00 	.word	0x40000c00

00002ad0 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    2ad0:	b580      	push	{r7, lr}
    2ad2:	b086      	sub	sp, #24
    2ad4:	af00      	add	r7, sp, #0
    2ad6:	0002      	movs	r2, r0
    2ad8:	6039      	str	r1, [r7, #0]
    2ada:	1dfb      	adds	r3, r7, #7
    2adc:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    2ade:	1dfb      	adds	r3, r7, #7
    2ae0:	781b      	ldrb	r3, [r3, #0]
    2ae2:	617b      	str	r3, [r7, #20]
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);
    2ae4:	1dfb      	adds	r3, r7, #7
    2ae6:	781b      	ldrb	r3, [r3, #0]
    2ae8:	613b      	str	r3, [r7, #16]

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    2aea:	683b      	ldr	r3, [r7, #0]
    2aec:	781b      	ldrb	r3, [r3, #0]
    2aee:	021b      	lsls	r3, r3, #8
    2af0:	001a      	movs	r2, r3
    2af2:	697b      	ldr	r3, [r7, #20]
    2af4:	4313      	orrs	r3, r2
    2af6:	617b      	str	r3, [r7, #20]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    2af8:	683b      	ldr	r3, [r7, #0]
    2afa:	785b      	ldrb	r3, [r3, #1]
    2afc:	2b00      	cmp	r3, #0
    2afe:	d004      	beq.n	2b0a <system_gclk_gen_set_config+0x3a>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    2b00:	697b      	ldr	r3, [r7, #20]
    2b02:	2280      	movs	r2, #128	; 0x80
    2b04:	02d2      	lsls	r2, r2, #11
    2b06:	4313      	orrs	r3, r2
    2b08:	617b      	str	r3, [r7, #20]
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    2b0a:	683b      	ldr	r3, [r7, #0]
    2b0c:	7a5b      	ldrb	r3, [r3, #9]
    2b0e:	2b00      	cmp	r3, #0
    2b10:	d004      	beq.n	2b1c <system_gclk_gen_set_config+0x4c>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    2b12:	697b      	ldr	r3, [r7, #20]
    2b14:	2280      	movs	r2, #128	; 0x80
    2b16:	0312      	lsls	r2, r2, #12
    2b18:	4313      	orrs	r3, r2
    2b1a:	617b      	str	r3, [r7, #20]
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    2b1c:	683b      	ldr	r3, [r7, #0]
    2b1e:	685b      	ldr	r3, [r3, #4]
    2b20:	2b01      	cmp	r3, #1
    2b22:	d92c      	bls.n	2b7e <system_gclk_gen_set_config+0xae>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    2b24:	683b      	ldr	r3, [r7, #0]
    2b26:	685a      	ldr	r2, [r3, #4]
    2b28:	683b      	ldr	r3, [r7, #0]
    2b2a:	685b      	ldr	r3, [r3, #4]
    2b2c:	3b01      	subs	r3, #1
    2b2e:	4013      	ands	r3, r2
    2b30:	d11a      	bne.n	2b68 <system_gclk_gen_set_config+0x98>
			/* Determine the index of the highest bit set to get the
			 * division factor that must be loaded into the division
			 * register */

			uint32_t div2_count = 0;
    2b32:	2300      	movs	r3, #0
    2b34:	60fb      	str	r3, [r7, #12]

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    2b36:	2302      	movs	r3, #2
    2b38:	60bb      	str	r3, [r7, #8]
    2b3a:	e005      	b.n	2b48 <system_gclk_gen_set_config+0x78>
						mask <<= 1) {
				div2_count++;
    2b3c:	68fb      	ldr	r3, [r7, #12]
    2b3e:	3301      	adds	r3, #1
    2b40:	60fb      	str	r3, [r7, #12]
						mask <<= 1) {
    2b42:	68bb      	ldr	r3, [r7, #8]
    2b44:	005b      	lsls	r3, r3, #1
    2b46:	60bb      	str	r3, [r7, #8]
			for (mask = (1UL << 1); mask < config->division_factor;
    2b48:	683b      	ldr	r3, [r7, #0]
    2b4a:	685a      	ldr	r2, [r3, #4]
    2b4c:	68bb      	ldr	r3, [r7, #8]
    2b4e:	429a      	cmp	r2, r3
    2b50:	d8f4      	bhi.n	2b3c <system_gclk_gen_set_config+0x6c>
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    2b52:	68fb      	ldr	r3, [r7, #12]
    2b54:	021b      	lsls	r3, r3, #8
    2b56:	693a      	ldr	r2, [r7, #16]
    2b58:	4313      	orrs	r3, r2
    2b5a:	613b      	str	r3, [r7, #16]
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    2b5c:	697b      	ldr	r3, [r7, #20]
    2b5e:	2280      	movs	r2, #128	; 0x80
    2b60:	0352      	lsls	r2, r2, #13
    2b62:	4313      	orrs	r3, r2
    2b64:	617b      	str	r3, [r7, #20]
    2b66:	e00a      	b.n	2b7e <system_gclk_gen_set_config+0xae>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    2b68:	683b      	ldr	r3, [r7, #0]
    2b6a:	685b      	ldr	r3, [r3, #4]
    2b6c:	021b      	lsls	r3, r3, #8
			new_gendiv_config  |=
    2b6e:	693a      	ldr	r2, [r7, #16]
    2b70:	4313      	orrs	r3, r2
    2b72:	613b      	str	r3, [r7, #16]

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    2b74:	697b      	ldr	r3, [r7, #20]
    2b76:	2280      	movs	r2, #128	; 0x80
    2b78:	0292      	lsls	r2, r2, #10
    2b7a:	4313      	orrs	r3, r2
    2b7c:	617b      	str	r3, [r7, #20]
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    2b7e:	683b      	ldr	r3, [r7, #0]
    2b80:	7a1b      	ldrb	r3, [r3, #8]
    2b82:	2b00      	cmp	r3, #0
    2b84:	d004      	beq.n	2b90 <system_gclk_gen_set_config+0xc0>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    2b86:	697b      	ldr	r3, [r7, #20]
    2b88:	2280      	movs	r2, #128	; 0x80
    2b8a:	0392      	lsls	r2, r2, #14
    2b8c:	4313      	orrs	r3, r2
    2b8e:	617b      	str	r3, [r7, #20]
	}

	while (system_gclk_is_syncing()) {
    2b90:	46c0      	nop			; (mov r8, r8)
    2b92:	4b13      	ldr	r3, [pc, #76]	; (2be0 <system_gclk_gen_set_config+0x110>)
    2b94:	4798      	blx	r3
    2b96:	1e03      	subs	r3, r0, #0
    2b98:	d1fb      	bne.n	2b92 <system_gclk_gen_set_config+0xc2>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    2b9a:	4b12      	ldr	r3, [pc, #72]	; (2be4 <system_gclk_gen_set_config+0x114>)
    2b9c:	4798      	blx	r3

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    2b9e:	4a12      	ldr	r2, [pc, #72]	; (2be8 <system_gclk_gen_set_config+0x118>)
    2ba0:	1dfb      	adds	r3, r7, #7
    2ba2:	781b      	ldrb	r3, [r3, #0]
    2ba4:	7013      	strb	r3, [r2, #0]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    2ba6:	46c0      	nop			; (mov r8, r8)
    2ba8:	4b0d      	ldr	r3, [pc, #52]	; (2be0 <system_gclk_gen_set_config+0x110>)
    2baa:	4798      	blx	r3
    2bac:	1e03      	subs	r3, r0, #0
    2bae:	d1fb      	bne.n	2ba8 <system_gclk_gen_set_config+0xd8>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    2bb0:	4b0e      	ldr	r3, [pc, #56]	; (2bec <system_gclk_gen_set_config+0x11c>)
    2bb2:	693a      	ldr	r2, [r7, #16]
    2bb4:	609a      	str	r2, [r3, #8]

	while (system_gclk_is_syncing()) {
    2bb6:	46c0      	nop			; (mov r8, r8)
    2bb8:	4b09      	ldr	r3, [pc, #36]	; (2be0 <system_gclk_gen_set_config+0x110>)
    2bba:	4798      	blx	r3
    2bbc:	1e03      	subs	r3, r0, #0
    2bbe:	d1fb      	bne.n	2bb8 <system_gclk_gen_set_config+0xe8>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    2bc0:	4b0a      	ldr	r3, [pc, #40]	; (2bec <system_gclk_gen_set_config+0x11c>)
    2bc2:	4a0a      	ldr	r2, [pc, #40]	; (2bec <system_gclk_gen_set_config+0x11c>)
    2bc4:	6851      	ldr	r1, [r2, #4]
    2bc6:	2280      	movs	r2, #128	; 0x80
    2bc8:	0252      	lsls	r2, r2, #9
    2bca:	4011      	ands	r1, r2
    2bcc:	697a      	ldr	r2, [r7, #20]
    2bce:	430a      	orrs	r2, r1
    2bd0:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
    2bd2:	4b07      	ldr	r3, [pc, #28]	; (2bf0 <system_gclk_gen_set_config+0x120>)
    2bd4:	4798      	blx	r3
}
    2bd6:	46c0      	nop			; (mov r8, r8)
    2bd8:	46bd      	mov	sp, r7
    2bda:	b006      	add	sp, #24
    2bdc:	bd80      	pop	{r7, pc}
    2bde:	46c0      	nop			; (mov r8, r8)
    2be0:	00002a81 	.word	0x00002a81
    2be4:	00002a59 	.word	0x00002a59
    2be8:	40000c08 	.word	0x40000c08
    2bec:	40000c00 	.word	0x40000c00
    2bf0:	00002a6d 	.word	0x00002a6d

00002bf4 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    2bf4:	b580      	push	{r7, lr}
    2bf6:	b082      	sub	sp, #8
    2bf8:	af00      	add	r7, sp, #0
    2bfa:	0002      	movs	r2, r0
    2bfc:	1dfb      	adds	r3, r7, #7
    2bfe:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
    2c00:	46c0      	nop			; (mov r8, r8)
    2c02:	4b0e      	ldr	r3, [pc, #56]	; (2c3c <system_gclk_gen_enable+0x48>)
    2c04:	4798      	blx	r3
    2c06:	1e03      	subs	r3, r0, #0
    2c08:	d1fb      	bne.n	2c02 <system_gclk_gen_enable+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    2c0a:	4b0d      	ldr	r3, [pc, #52]	; (2c40 <system_gclk_gen_enable+0x4c>)
    2c0c:	4798      	blx	r3

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    2c0e:	4a0d      	ldr	r2, [pc, #52]	; (2c44 <system_gclk_gen_enable+0x50>)
    2c10:	1dfb      	adds	r3, r7, #7
    2c12:	781b      	ldrb	r3, [r3, #0]
    2c14:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
    2c16:	46c0      	nop			; (mov r8, r8)
    2c18:	4b08      	ldr	r3, [pc, #32]	; (2c3c <system_gclk_gen_enable+0x48>)
    2c1a:	4798      	blx	r3
    2c1c:	1e03      	subs	r3, r0, #0
    2c1e:	d1fb      	bne.n	2c18 <system_gclk_gen_enable+0x24>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    2c20:	4b09      	ldr	r3, [pc, #36]	; (2c48 <system_gclk_gen_enable+0x54>)
    2c22:	4a09      	ldr	r2, [pc, #36]	; (2c48 <system_gclk_gen_enable+0x54>)
    2c24:	6852      	ldr	r2, [r2, #4]
    2c26:	2180      	movs	r1, #128	; 0x80
    2c28:	0249      	lsls	r1, r1, #9
    2c2a:	430a      	orrs	r2, r1
    2c2c:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
    2c2e:	4b07      	ldr	r3, [pc, #28]	; (2c4c <system_gclk_gen_enable+0x58>)
    2c30:	4798      	blx	r3
}
    2c32:	46c0      	nop			; (mov r8, r8)
    2c34:	46bd      	mov	sp, r7
    2c36:	b002      	add	sp, #8
    2c38:	bd80      	pop	{r7, pc}
    2c3a:	46c0      	nop			; (mov r8, r8)
    2c3c:	00002a81 	.word	0x00002a81
    2c40:	00002a59 	.word	0x00002a59
    2c44:	40000c04 	.word	0x40000c04
    2c48:	40000c00 	.word	0x40000c00
    2c4c:	00002a6d 	.word	0x00002a6d

00002c50 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    2c50:	b580      	push	{r7, lr}
    2c52:	b086      	sub	sp, #24
    2c54:	af00      	add	r7, sp, #0
    2c56:	0002      	movs	r2, r0
    2c58:	1dfb      	adds	r3, r7, #7
    2c5a:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
    2c5c:	46c0      	nop			; (mov r8, r8)
    2c5e:	4b2a      	ldr	r3, [pc, #168]	; (2d08 <system_gclk_gen_get_hz+0xb8>)
    2c60:	4798      	blx	r3
    2c62:	1e03      	subs	r3, r0, #0
    2c64:	d1fb      	bne.n	2c5e <system_gclk_gen_get_hz+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    2c66:	4b29      	ldr	r3, [pc, #164]	; (2d0c <system_gclk_gen_get_hz+0xbc>)
    2c68:	4798      	blx	r3

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    2c6a:	4a29      	ldr	r2, [pc, #164]	; (2d10 <system_gclk_gen_get_hz+0xc0>)
    2c6c:	1dfb      	adds	r3, r7, #7
    2c6e:	781b      	ldrb	r3, [r3, #0]
    2c70:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
    2c72:	46c0      	nop			; (mov r8, r8)
    2c74:	4b24      	ldr	r3, [pc, #144]	; (2d08 <system_gclk_gen_get_hz+0xb8>)
    2c76:	4798      	blx	r3
    2c78:	1e03      	subs	r3, r0, #0
    2c7a:	d1fb      	bne.n	2c74 <system_gclk_gen_get_hz+0x24>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    2c7c:	4b25      	ldr	r3, [pc, #148]	; (2d14 <system_gclk_gen_get_hz+0xc4>)
    2c7e:	685b      	ldr	r3, [r3, #4]
    2c80:	04db      	lsls	r3, r3, #19
    2c82:	0edb      	lsrs	r3, r3, #27
    2c84:	b2db      	uxtb	r3, r3
	uint32_t gen_input_hz = system_clock_source_get_hz(
    2c86:	0018      	movs	r0, r3
    2c88:	4b23      	ldr	r3, [pc, #140]	; (2d18 <system_gclk_gen_get_hz+0xc8>)
    2c8a:	4798      	blx	r3
    2c8c:	0003      	movs	r3, r0
    2c8e:	617b      	str	r3, [r7, #20]

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    2c90:	4a1f      	ldr	r2, [pc, #124]	; (2d10 <system_gclk_gen_get_hz+0xc0>)
    2c92:	1dfb      	adds	r3, r7, #7
    2c94:	781b      	ldrb	r3, [r3, #0]
    2c96:	7013      	strb	r3, [r2, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    2c98:	4b1e      	ldr	r3, [pc, #120]	; (2d14 <system_gclk_gen_get_hz+0xc4>)
    2c9a:	685b      	ldr	r3, [r3, #4]
    2c9c:	02db      	lsls	r3, r3, #11
    2c9e:	0fdb      	lsrs	r3, r3, #31
    2ca0:	b2da      	uxtb	r2, r3
    2ca2:	2313      	movs	r3, #19
    2ca4:	18fb      	adds	r3, r7, r3
    2ca6:	701a      	strb	r2, [r3, #0]

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    2ca8:	4a1c      	ldr	r2, [pc, #112]	; (2d1c <system_gclk_gen_get_hz+0xcc>)
    2caa:	1dfb      	adds	r3, r7, #7
    2cac:	781b      	ldrb	r3, [r3, #0]
    2cae:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
    2cb0:	46c0      	nop			; (mov r8, r8)
    2cb2:	4b15      	ldr	r3, [pc, #84]	; (2d08 <system_gclk_gen_get_hz+0xb8>)
    2cb4:	4798      	blx	r3
    2cb6:	1e03      	subs	r3, r0, #0
    2cb8:	d1fb      	bne.n	2cb2 <system_gclk_gen_get_hz+0x62>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    2cba:	4b16      	ldr	r3, [pc, #88]	; (2d14 <system_gclk_gen_get_hz+0xc4>)
    2cbc:	689b      	ldr	r3, [r3, #8]
    2cbe:	021b      	lsls	r3, r3, #8
    2cc0:	0c1b      	lsrs	r3, r3, #16
    2cc2:	b29b      	uxth	r3, r3
    2cc4:	60fb      	str	r3, [r7, #12]

	system_interrupt_leave_critical_section();
    2cc6:	4b16      	ldr	r3, [pc, #88]	; (2d20 <system_gclk_gen_get_hz+0xd0>)
    2cc8:	4798      	blx	r3

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    2cca:	2313      	movs	r3, #19
    2ccc:	18fb      	adds	r3, r7, r3
    2cce:	781b      	ldrb	r3, [r3, #0]
    2cd0:	2b00      	cmp	r3, #0
    2cd2:	d109      	bne.n	2ce8 <system_gclk_gen_get_hz+0x98>
    2cd4:	68fb      	ldr	r3, [r7, #12]
    2cd6:	2b01      	cmp	r3, #1
    2cd8:	d906      	bls.n	2ce8 <system_gclk_gen_get_hz+0x98>
		gen_input_hz /= divider;
    2cda:	4b12      	ldr	r3, [pc, #72]	; (2d24 <system_gclk_gen_get_hz+0xd4>)
    2cdc:	68f9      	ldr	r1, [r7, #12]
    2cde:	6978      	ldr	r0, [r7, #20]
    2ce0:	4798      	blx	r3
    2ce2:	0003      	movs	r3, r0
    2ce4:	617b      	str	r3, [r7, #20]
    2ce6:	e00a      	b.n	2cfe <system_gclk_gen_get_hz+0xae>
	} else if (divsel) {
    2ce8:	2313      	movs	r3, #19
    2cea:	18fb      	adds	r3, r7, r3
    2cec:	781b      	ldrb	r3, [r3, #0]
    2cee:	2b00      	cmp	r3, #0
    2cf0:	d005      	beq.n	2cfe <system_gclk_gen_get_hz+0xae>
		gen_input_hz >>= (divider+1);
    2cf2:	68fb      	ldr	r3, [r7, #12]
    2cf4:	3301      	adds	r3, #1
    2cf6:	697a      	ldr	r2, [r7, #20]
    2cf8:	40da      	lsrs	r2, r3
    2cfa:	0013      	movs	r3, r2
    2cfc:	617b      	str	r3, [r7, #20]
	}

	return gen_input_hz;
    2cfe:	697b      	ldr	r3, [r7, #20]
}
    2d00:	0018      	movs	r0, r3
    2d02:	46bd      	mov	sp, r7
    2d04:	b006      	add	sp, #24
    2d06:	bd80      	pop	{r7, pc}
    2d08:	00002a81 	.word	0x00002a81
    2d0c:	00002a59 	.word	0x00002a59
    2d10:	40000c04 	.word	0x40000c04
    2d14:	40000c00 	.word	0x40000c00
    2d18:	0000220d 	.word	0x0000220d
    2d1c:	40000c08 	.word	0x40000c08
    2d20:	00002a6d 	.word	0x00002a6d
    2d24:	000039a5 	.word	0x000039a5

00002d28 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    2d28:	b580      	push	{r7, lr}
    2d2a:	b084      	sub	sp, #16
    2d2c:	af00      	add	r7, sp, #0
    2d2e:	0002      	movs	r2, r0
    2d30:	6039      	str	r1, [r7, #0]
    2d32:	1dfb      	adds	r3, r7, #7
    2d34:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);
    2d36:	1dfb      	adds	r3, r7, #7
    2d38:	781b      	ldrb	r3, [r3, #0]
    2d3a:	60fb      	str	r3, [r7, #12]

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    2d3c:	683b      	ldr	r3, [r7, #0]
    2d3e:	781b      	ldrb	r3, [r3, #0]
    2d40:	021b      	lsls	r3, r3, #8
    2d42:	001a      	movs	r2, r3
    2d44:	68fb      	ldr	r3, [r7, #12]
    2d46:	4313      	orrs	r3, r2
    2d48:	60fb      	str	r3, [r7, #12]

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    2d4a:	1dfb      	adds	r3, r7, #7
    2d4c:	781b      	ldrb	r3, [r3, #0]
    2d4e:	0018      	movs	r0, r3
    2d50:	4b04      	ldr	r3, [pc, #16]	; (2d64 <system_gclk_chan_set_config+0x3c>)
    2d52:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    2d54:	4b04      	ldr	r3, [pc, #16]	; (2d68 <system_gclk_chan_set_config+0x40>)
    2d56:	68fa      	ldr	r2, [r7, #12]
    2d58:	b292      	uxth	r2, r2
    2d5a:	805a      	strh	r2, [r3, #2]
}
    2d5c:	46c0      	nop			; (mov r8, r8)
    2d5e:	46bd      	mov	sp, r7
    2d60:	b004      	add	sp, #16
    2d62:	bd80      	pop	{r7, pc}
    2d64:	00002db5 	.word	0x00002db5
    2d68:	40000c00 	.word	0x40000c00

00002d6c <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    2d6c:	b580      	push	{r7, lr}
    2d6e:	b082      	sub	sp, #8
    2d70:	af00      	add	r7, sp, #0
    2d72:	0002      	movs	r2, r0
    2d74:	1dfb      	adds	r3, r7, #7
    2d76:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
    2d78:	4b0a      	ldr	r3, [pc, #40]	; (2da4 <system_gclk_chan_enable+0x38>)
    2d7a:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    2d7c:	4a0a      	ldr	r2, [pc, #40]	; (2da8 <system_gclk_chan_enable+0x3c>)
    2d7e:	1dfb      	adds	r3, r7, #7
    2d80:	781b      	ldrb	r3, [r3, #0]
    2d82:	7013      	strb	r3, [r2, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    2d84:	4909      	ldr	r1, [pc, #36]	; (2dac <system_gclk_chan_enable+0x40>)
    2d86:	4b09      	ldr	r3, [pc, #36]	; (2dac <system_gclk_chan_enable+0x40>)
    2d88:	885b      	ldrh	r3, [r3, #2]
    2d8a:	b29b      	uxth	r3, r3
    2d8c:	2280      	movs	r2, #128	; 0x80
    2d8e:	01d2      	lsls	r2, r2, #7
    2d90:	4313      	orrs	r3, r2
    2d92:	b29b      	uxth	r3, r3
    2d94:	804b      	strh	r3, [r1, #2]

	system_interrupt_leave_critical_section();
    2d96:	4b06      	ldr	r3, [pc, #24]	; (2db0 <system_gclk_chan_enable+0x44>)
    2d98:	4798      	blx	r3
}
    2d9a:	46c0      	nop			; (mov r8, r8)
    2d9c:	46bd      	mov	sp, r7
    2d9e:	b002      	add	sp, #8
    2da0:	bd80      	pop	{r7, pc}
    2da2:	46c0      	nop			; (mov r8, r8)
    2da4:	00002a59 	.word	0x00002a59
    2da8:	40000c02 	.word	0x40000c02
    2dac:	40000c00 	.word	0x40000c00
    2db0:	00002a6d 	.word	0x00002a6d

00002db4 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    2db4:	b580      	push	{r7, lr}
    2db6:	b084      	sub	sp, #16
    2db8:	af00      	add	r7, sp, #0
    2dba:	0002      	movs	r2, r0
    2dbc:	1dfb      	adds	r3, r7, #7
    2dbe:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
    2dc0:	4b1c      	ldr	r3, [pc, #112]	; (2e34 <system_gclk_chan_disable+0x80>)
    2dc2:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    2dc4:	4a1c      	ldr	r2, [pc, #112]	; (2e38 <system_gclk_chan_disable+0x84>)
    2dc6:	1dfb      	adds	r3, r7, #7
    2dc8:	781b      	ldrb	r3, [r3, #0]
    2dca:	7013      	strb	r3, [r2, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    2dcc:	4b1b      	ldr	r3, [pc, #108]	; (2e3c <system_gclk_chan_disable+0x88>)
    2dce:	885b      	ldrh	r3, [r3, #2]
    2dd0:	051b      	lsls	r3, r3, #20
    2dd2:	0f1b      	lsrs	r3, r3, #28
    2dd4:	b2db      	uxtb	r3, r3
    2dd6:	60fb      	str	r3, [r7, #12]
	GCLK->CLKCTRL.bit.GEN = 0;
    2dd8:	4a18      	ldr	r2, [pc, #96]	; (2e3c <system_gclk_chan_disable+0x88>)
    2dda:	8853      	ldrh	r3, [r2, #2]
    2ddc:	4918      	ldr	r1, [pc, #96]	; (2e40 <system_gclk_chan_disable+0x8c>)
    2dde:	400b      	ands	r3, r1
    2de0:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    2de2:	4a16      	ldr	r2, [pc, #88]	; (2e3c <system_gclk_chan_disable+0x88>)
    2de4:	4b15      	ldr	r3, [pc, #84]	; (2e3c <system_gclk_chan_disable+0x88>)
    2de6:	885b      	ldrh	r3, [r3, #2]
    2de8:	b29b      	uxth	r3, r3
    2dea:	4916      	ldr	r1, [pc, #88]	; (2e44 <system_gclk_chan_disable+0x90>)
    2dec:	400b      	ands	r3, r1
    2dee:	b29b      	uxth	r3, r3
    2df0:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    2df2:	46c0      	nop			; (mov r8, r8)
    2df4:	4b11      	ldr	r3, [pc, #68]	; (2e3c <system_gclk_chan_disable+0x88>)
    2df6:	885b      	ldrh	r3, [r3, #2]
    2df8:	b29b      	uxth	r3, r3
    2dfa:	001a      	movs	r2, r3
    2dfc:	2380      	movs	r3, #128	; 0x80
    2dfe:	01db      	lsls	r3, r3, #7
    2e00:	4013      	ands	r3, r2
    2e02:	d1f7      	bne.n	2df4 <system_gclk_chan_disable+0x40>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    2e04:	4a0d      	ldr	r2, [pc, #52]	; (2e3c <system_gclk_chan_disable+0x88>)
    2e06:	68fb      	ldr	r3, [r7, #12]
    2e08:	b2db      	uxtb	r3, r3
    2e0a:	1c19      	adds	r1, r3, #0
    2e0c:	230f      	movs	r3, #15
    2e0e:	400b      	ands	r3, r1
    2e10:	b2d9      	uxtb	r1, r3
    2e12:	8853      	ldrh	r3, [r2, #2]
    2e14:	1c08      	adds	r0, r1, #0
    2e16:	210f      	movs	r1, #15
    2e18:	4001      	ands	r1, r0
    2e1a:	0208      	lsls	r0, r1, #8
    2e1c:	4908      	ldr	r1, [pc, #32]	; (2e40 <system_gclk_chan_disable+0x8c>)
    2e1e:	400b      	ands	r3, r1
    2e20:	1c19      	adds	r1, r3, #0
    2e22:	1c03      	adds	r3, r0, #0
    2e24:	430b      	orrs	r3, r1
    2e26:	8053      	strh	r3, [r2, #2]

	system_interrupt_leave_critical_section();
    2e28:	4b07      	ldr	r3, [pc, #28]	; (2e48 <system_gclk_chan_disable+0x94>)
    2e2a:	4798      	blx	r3
}
    2e2c:	46c0      	nop			; (mov r8, r8)
    2e2e:	46bd      	mov	sp, r7
    2e30:	b004      	add	sp, #16
    2e32:	bd80      	pop	{r7, pc}
    2e34:	00002a59 	.word	0x00002a59
    2e38:	40000c02 	.word	0x40000c02
    2e3c:	40000c00 	.word	0x40000c00
    2e40:	fffff0ff 	.word	0xfffff0ff
    2e44:	ffffbfff 	.word	0xffffbfff
    2e48:	00002a6d 	.word	0x00002a6d

00002e4c <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    2e4c:	b580      	push	{r7, lr}
    2e4e:	b084      	sub	sp, #16
    2e50:	af00      	add	r7, sp, #0
    2e52:	0002      	movs	r2, r0
    2e54:	1dfb      	adds	r3, r7, #7
    2e56:	701a      	strb	r2, [r3, #0]
	uint8_t gen_id;

	system_interrupt_enter_critical_section();
    2e58:	4b0d      	ldr	r3, [pc, #52]	; (2e90 <system_gclk_chan_get_hz+0x44>)
    2e5a:	4798      	blx	r3

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    2e5c:	4a0d      	ldr	r2, [pc, #52]	; (2e94 <system_gclk_chan_get_hz+0x48>)
    2e5e:	1dfb      	adds	r3, r7, #7
    2e60:	781b      	ldrb	r3, [r3, #0]
    2e62:	7013      	strb	r3, [r2, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    2e64:	4b0c      	ldr	r3, [pc, #48]	; (2e98 <system_gclk_chan_get_hz+0x4c>)
    2e66:	885b      	ldrh	r3, [r3, #2]
    2e68:	051b      	lsls	r3, r3, #20
    2e6a:	0f1b      	lsrs	r3, r3, #28
    2e6c:	b2da      	uxtb	r2, r3
    2e6e:	230f      	movs	r3, #15
    2e70:	18fb      	adds	r3, r7, r3
    2e72:	701a      	strb	r2, [r3, #0]

	system_interrupt_leave_critical_section();
    2e74:	4b09      	ldr	r3, [pc, #36]	; (2e9c <system_gclk_chan_get_hz+0x50>)
    2e76:	4798      	blx	r3

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    2e78:	230f      	movs	r3, #15
    2e7a:	18fb      	adds	r3, r7, r3
    2e7c:	781b      	ldrb	r3, [r3, #0]
    2e7e:	0018      	movs	r0, r3
    2e80:	4b07      	ldr	r3, [pc, #28]	; (2ea0 <system_gclk_chan_get_hz+0x54>)
    2e82:	4798      	blx	r3
    2e84:	0003      	movs	r3, r0
}
    2e86:	0018      	movs	r0, r3
    2e88:	46bd      	mov	sp, r7
    2e8a:	b004      	add	sp, #16
    2e8c:	bd80      	pop	{r7, pc}
    2e8e:	46c0      	nop			; (mov r8, r8)
    2e90:	00002a59 	.word	0x00002a59
    2e94:	40000c02 	.word	0x40000c02
    2e98:	40000c00 	.word	0x40000c00
    2e9c:	00002a6d 	.word	0x00002a6d
    2ea0:	00002c51 	.word	0x00002c51

00002ea4 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    2ea4:	b580      	push	{r7, lr}
    2ea6:	b084      	sub	sp, #16
    2ea8:	af00      	add	r7, sp, #0
    2eaa:	0002      	movs	r2, r0
    2eac:	1dfb      	adds	r3, r7, #7
    2eae:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    2eb0:	230f      	movs	r3, #15
    2eb2:	18fb      	adds	r3, r7, r3
    2eb4:	1dfa      	adds	r2, r7, #7
    2eb6:	7812      	ldrb	r2, [r2, #0]
    2eb8:	09d2      	lsrs	r2, r2, #7
    2eba:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    2ebc:	230e      	movs	r3, #14
    2ebe:	18fb      	adds	r3, r7, r3
    2ec0:	1dfa      	adds	r2, r7, #7
    2ec2:	7812      	ldrb	r2, [r2, #0]
    2ec4:	0952      	lsrs	r2, r2, #5
    2ec6:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    2ec8:	4b0d      	ldr	r3, [pc, #52]	; (2f00 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    2eca:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    2ecc:	230f      	movs	r3, #15
    2ece:	18fb      	adds	r3, r7, r3
    2ed0:	781b      	ldrb	r3, [r3, #0]
    2ed2:	2b00      	cmp	r3, #0
    2ed4:	d10f      	bne.n	2ef6 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    2ed6:	230f      	movs	r3, #15
    2ed8:	18fb      	adds	r3, r7, r3
    2eda:	781b      	ldrb	r3, [r3, #0]
    2edc:	009b      	lsls	r3, r3, #2
    2ede:	2210      	movs	r2, #16
    2ee0:	4694      	mov	ip, r2
    2ee2:	44bc      	add	ip, r7
    2ee4:	4463      	add	r3, ip
    2ee6:	3b08      	subs	r3, #8
    2ee8:	681a      	ldr	r2, [r3, #0]
    2eea:	230e      	movs	r3, #14
    2eec:	18fb      	adds	r3, r7, r3
    2eee:	781b      	ldrb	r3, [r3, #0]
    2ef0:	01db      	lsls	r3, r3, #7
    2ef2:	18d3      	adds	r3, r2, r3
    2ef4:	e000      	b.n	2ef8 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    2ef6:	2300      	movs	r3, #0
	}
}
    2ef8:	0018      	movs	r0, r3
    2efa:	46bd      	mov	sp, r7
    2efc:	b004      	add	sp, #16
    2efe:	bd80      	pop	{r7, pc}
    2f00:	41004400 	.word	0x41004400

00002f04 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    2f04:	b580      	push	{r7, lr}
    2f06:	b088      	sub	sp, #32
    2f08:	af00      	add	r7, sp, #0
    2f0a:	60f8      	str	r0, [r7, #12]
    2f0c:	60b9      	str	r1, [r7, #8]
    2f0e:	607a      	str	r2, [r7, #4]
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    2f10:	2300      	movs	r3, #0
    2f12:	61fb      	str	r3, [r7, #28]

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    2f14:	687b      	ldr	r3, [r7, #4]
    2f16:	78db      	ldrb	r3, [r3, #3]
    2f18:	2201      	movs	r2, #1
    2f1a:	4053      	eors	r3, r2
    2f1c:	b2db      	uxtb	r3, r3
    2f1e:	2b00      	cmp	r3, #0
    2f20:	d035      	beq.n	2f8e <_system_pinmux_config+0x8a>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    2f22:	687b      	ldr	r3, [r7, #4]
    2f24:	781b      	ldrb	r3, [r3, #0]
    2f26:	2b80      	cmp	r3, #128	; 0x80
    2f28:	d00b      	beq.n	2f42 <_system_pinmux_config+0x3e>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
    2f2a:	69fb      	ldr	r3, [r7, #28]
    2f2c:	2280      	movs	r2, #128	; 0x80
    2f2e:	0252      	lsls	r2, r2, #9
    2f30:	4313      	orrs	r3, r2
    2f32:	61fb      	str	r3, [r7, #28]
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    2f34:	687b      	ldr	r3, [r7, #4]
    2f36:	781b      	ldrb	r3, [r3, #0]
    2f38:	061b      	lsls	r3, r3, #24
    2f3a:	001a      	movs	r2, r3
    2f3c:	69fb      	ldr	r3, [r7, #28]
    2f3e:	4313      	orrs	r3, r2
    2f40:	61fb      	str	r3, [r7, #28]
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    2f42:	687b      	ldr	r3, [r7, #4]
    2f44:	785b      	ldrb	r3, [r3, #1]
    2f46:	2b00      	cmp	r3, #0
    2f48:	d003      	beq.n	2f52 <_system_pinmux_config+0x4e>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    2f4a:	687b      	ldr	r3, [r7, #4]
    2f4c:	785b      	ldrb	r3, [r3, #1]
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    2f4e:	2b02      	cmp	r3, #2
    2f50:	d110      	bne.n	2f74 <_system_pinmux_config+0x70>
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    2f52:	69fb      	ldr	r3, [r7, #28]
    2f54:	2280      	movs	r2, #128	; 0x80
    2f56:	0292      	lsls	r2, r2, #10
    2f58:	4313      	orrs	r3, r2
    2f5a:	61fb      	str	r3, [r7, #28]

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    2f5c:	687b      	ldr	r3, [r7, #4]
    2f5e:	789b      	ldrb	r3, [r3, #2]
    2f60:	2b00      	cmp	r3, #0
    2f62:	d004      	beq.n	2f6e <_system_pinmux_config+0x6a>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    2f64:	69fb      	ldr	r3, [r7, #28]
    2f66:	2280      	movs	r2, #128	; 0x80
    2f68:	02d2      	lsls	r2, r2, #11
    2f6a:	4313      	orrs	r3, r2
    2f6c:	61fb      	str	r3, [r7, #28]
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    2f6e:	68fb      	ldr	r3, [r7, #12]
    2f70:	68ba      	ldr	r2, [r7, #8]
    2f72:	605a      	str	r2, [r3, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    2f74:	687b      	ldr	r3, [r7, #4]
    2f76:	785b      	ldrb	r3, [r3, #1]
    2f78:	2b01      	cmp	r3, #1
    2f7a:	d003      	beq.n	2f84 <_system_pinmux_config+0x80>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    2f7c:	687b      	ldr	r3, [r7, #4]
    2f7e:	785b      	ldrb	r3, [r3, #1]
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    2f80:	2b02      	cmp	r3, #2
    2f82:	d107      	bne.n	2f94 <_system_pinmux_config+0x90>
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    2f84:	69fb      	ldr	r3, [r7, #28]
    2f86:	4a22      	ldr	r2, [pc, #136]	; (3010 <_system_pinmux_config+0x10c>)
    2f88:	4013      	ands	r3, r2
    2f8a:	61fb      	str	r3, [r7, #28]
    2f8c:	e002      	b.n	2f94 <_system_pinmux_config+0x90>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    2f8e:	68fb      	ldr	r3, [r7, #12]
    2f90:	68ba      	ldr	r2, [r7, #8]
    2f92:	605a      	str	r2, [r3, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    2f94:	68bb      	ldr	r3, [r7, #8]
    2f96:	041b      	lsls	r3, r3, #16
    2f98:	0c1b      	lsrs	r3, r3, #16
    2f9a:	61bb      	str	r3, [r7, #24]
	uint32_t upper_pin_mask = (pin_mask >> 16);
    2f9c:	68bb      	ldr	r3, [r7, #8]
    2f9e:	0c1b      	lsrs	r3, r3, #16
    2fa0:	617b      	str	r3, [r7, #20]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    2fa2:	69ba      	ldr	r2, [r7, #24]
    2fa4:	69fb      	ldr	r3, [r7, #28]
    2fa6:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    2fa8:	22a0      	movs	r2, #160	; 0xa0
    2faa:	05d2      	lsls	r2, r2, #23
    2fac:	431a      	orrs	r2, r3
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    2fae:	68fb      	ldr	r3, [r7, #12]
    2fb0:	629a      	str	r2, [r3, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    2fb2:	697a      	ldr	r2, [r7, #20]
    2fb4:	69fb      	ldr	r3, [r7, #28]
    2fb6:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    2fb8:	22d0      	movs	r2, #208	; 0xd0
    2fba:	0612      	lsls	r2, r2, #24
    2fbc:	431a      	orrs	r2, r3
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    2fbe:	68fb      	ldr	r3, [r7, #12]
    2fc0:	629a      	str	r2, [r3, #40]	; 0x28
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    2fc2:	687b      	ldr	r3, [r7, #4]
    2fc4:	78db      	ldrb	r3, [r3, #3]
    2fc6:	2201      	movs	r2, #1
    2fc8:	4053      	eors	r3, r2
    2fca:	b2db      	uxtb	r3, r3
    2fcc:	2b00      	cmp	r3, #0
    2fce:	d01a      	beq.n	3006 <_system_pinmux_config+0x102>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    2fd0:	69fa      	ldr	r2, [r7, #28]
    2fd2:	2380      	movs	r3, #128	; 0x80
    2fd4:	02db      	lsls	r3, r3, #11
    2fd6:	4013      	ands	r3, r2
    2fd8:	d00a      	beq.n	2ff0 <_system_pinmux_config+0xec>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    2fda:	687b      	ldr	r3, [r7, #4]
    2fdc:	789b      	ldrb	r3, [r3, #2]
    2fde:	2b01      	cmp	r3, #1
    2fe0:	d103      	bne.n	2fea <_system_pinmux_config+0xe6>
				port->OUTSET.reg = pin_mask;
    2fe2:	68fb      	ldr	r3, [r7, #12]
    2fe4:	68ba      	ldr	r2, [r7, #8]
    2fe6:	619a      	str	r2, [r3, #24]
    2fe8:	e002      	b.n	2ff0 <_system_pinmux_config+0xec>
			} else {
				port->OUTCLR.reg = pin_mask;
    2fea:	68fb      	ldr	r3, [r7, #12]
    2fec:	68ba      	ldr	r2, [r7, #8]
    2fee:	615a      	str	r2, [r3, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    2ff0:	687b      	ldr	r3, [r7, #4]
    2ff2:	785b      	ldrb	r3, [r3, #1]
    2ff4:	2b01      	cmp	r3, #1
    2ff6:	d003      	beq.n	3000 <_system_pinmux_config+0xfc>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    2ff8:	687b      	ldr	r3, [r7, #4]
    2ffa:	785b      	ldrb	r3, [r3, #1]
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    2ffc:	2b02      	cmp	r3, #2
    2ffe:	d102      	bne.n	3006 <_system_pinmux_config+0x102>
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    3000:	68fb      	ldr	r3, [r7, #12]
    3002:	68ba      	ldr	r2, [r7, #8]
    3004:	609a      	str	r2, [r3, #8]
		}
	}
}
    3006:	46c0      	nop			; (mov r8, r8)
    3008:	46bd      	mov	sp, r7
    300a:	b008      	add	sp, #32
    300c:	bd80      	pop	{r7, pc}
    300e:	46c0      	nop			; (mov r8, r8)
    3010:	fffbffff 	.word	0xfffbffff

00003014 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    3014:	b580      	push	{r7, lr}
    3016:	b084      	sub	sp, #16
    3018:	af00      	add	r7, sp, #0
    301a:	0002      	movs	r2, r0
    301c:	6039      	str	r1, [r7, #0]
    301e:	1dfb      	adds	r3, r7, #7
    3020:	701a      	strb	r2, [r3, #0]
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
    3022:	1dfb      	adds	r3, r7, #7
    3024:	781b      	ldrb	r3, [r3, #0]
    3026:	0018      	movs	r0, r3
    3028:	4b0a      	ldr	r3, [pc, #40]	; (3054 <system_pinmux_pin_set_config+0x40>)
    302a:	4798      	blx	r3
    302c:	0003      	movs	r3, r0
    302e:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    3030:	1dfb      	adds	r3, r7, #7
    3032:	781b      	ldrb	r3, [r3, #0]
    3034:	221f      	movs	r2, #31
    3036:	4013      	ands	r3, r2
    3038:	2201      	movs	r2, #1
    303a:	409a      	lsls	r2, r3
    303c:	0013      	movs	r3, r2
    303e:	60bb      	str	r3, [r7, #8]

	_system_pinmux_config(port, pin_mask, config);
    3040:	683a      	ldr	r2, [r7, #0]
    3042:	68b9      	ldr	r1, [r7, #8]
    3044:	68fb      	ldr	r3, [r7, #12]
    3046:	0018      	movs	r0, r3
    3048:	4b03      	ldr	r3, [pc, #12]	; (3058 <system_pinmux_pin_set_config+0x44>)
    304a:	4798      	blx	r3
}
    304c:	46c0      	nop			; (mov r8, r8)
    304e:	46bd      	mov	sp, r7
    3050:	b004      	add	sp, #16
    3052:	bd80      	pop	{r7, pc}
    3054:	00002ea5 	.word	0x00002ea5
    3058:	00002f05 	.word	0x00002f05

0000305c <_system_dummy_init>:
 * Dummy initialization function, used as a weak alias target for the various
 * init functions called by \ref system_init().
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
    305c:	b580      	push	{r7, lr}
    305e:	af00      	add	r7, sp, #0
	return;
    3060:	46c0      	nop			; (mov r8, r8)
}
    3062:	46bd      	mov	sp, r7
    3064:	bd80      	pop	{r7, pc}
	...

00003068 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    3068:	b580      	push	{r7, lr}
    306a:	af00      	add	r7, sp, #0
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    306c:	4b06      	ldr	r3, [pc, #24]	; (3088 <system_init+0x20>)
    306e:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    3070:	4b06      	ldr	r3, [pc, #24]	; (308c <system_init+0x24>)
    3072:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    3074:	4b06      	ldr	r3, [pc, #24]	; (3090 <system_init+0x28>)
    3076:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    3078:	4b06      	ldr	r3, [pc, #24]	; (3094 <system_init+0x2c>)
    307a:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    307c:	4b06      	ldr	r3, [pc, #24]	; (3098 <system_init+0x30>)
    307e:	4798      	blx	r3
}
    3080:	46c0      	nop			; (mov r8, r8)
    3082:	46bd      	mov	sp, r7
    3084:	bd80      	pop	{r7, pc}
    3086:	46c0      	nop			; (mov r8, r8)
    3088:	0000269d 	.word	0x0000269d
    308c:	00001f65 	.word	0x00001f65
    3090:	0000305d 	.word	0x0000305d
    3094:	00000a5d 	.word	0x00000a5d
    3098:	0000305d 	.word	0x0000305d

0000309c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    309c:	b580      	push	{r7, lr}
    309e:	b082      	sub	sp, #8
    30a0:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
    30a2:	4b2f      	ldr	r3, [pc, #188]	; (3160 <Reset_Handler+0xc4>)
    30a4:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
    30a6:	4b2f      	ldr	r3, [pc, #188]	; (3164 <Reset_Handler+0xc8>)
    30a8:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
    30aa:	687a      	ldr	r2, [r7, #4]
    30ac:	683b      	ldr	r3, [r7, #0]
    30ae:	429a      	cmp	r2, r3
    30b0:	d00c      	beq.n	30cc <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
    30b2:	e007      	b.n	30c4 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
    30b4:	683b      	ldr	r3, [r7, #0]
    30b6:	1d1a      	adds	r2, r3, #4
    30b8:	603a      	str	r2, [r7, #0]
    30ba:	687a      	ldr	r2, [r7, #4]
    30bc:	1d11      	adds	r1, r2, #4
    30be:	6079      	str	r1, [r7, #4]
    30c0:	6812      	ldr	r2, [r2, #0]
    30c2:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
    30c4:	683a      	ldr	r2, [r7, #0]
    30c6:	4b28      	ldr	r3, [pc, #160]	; (3168 <Reset_Handler+0xcc>)
    30c8:	429a      	cmp	r2, r3
    30ca:	d3f3      	bcc.n	30b4 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    30cc:	4b27      	ldr	r3, [pc, #156]	; (316c <Reset_Handler+0xd0>)
    30ce:	603b      	str	r3, [r7, #0]
    30d0:	e004      	b.n	30dc <Reset_Handler+0x40>
                *pDest++ = 0;
    30d2:	683b      	ldr	r3, [r7, #0]
    30d4:	1d1a      	adds	r2, r3, #4
    30d6:	603a      	str	r2, [r7, #0]
    30d8:	2200      	movs	r2, #0
    30da:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
    30dc:	683a      	ldr	r2, [r7, #0]
    30de:	4b24      	ldr	r3, [pc, #144]	; (3170 <Reset_Handler+0xd4>)
    30e0:	429a      	cmp	r2, r3
    30e2:	d3f6      	bcc.n	30d2 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
    30e4:	4b23      	ldr	r3, [pc, #140]	; (3174 <Reset_Handler+0xd8>)
    30e6:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    30e8:	4b23      	ldr	r3, [pc, #140]	; (3178 <Reset_Handler+0xdc>)
    30ea:	687a      	ldr	r2, [r7, #4]
    30ec:	21ff      	movs	r1, #255	; 0xff
    30ee:	438a      	bics	r2, r1
    30f0:	609a      	str	r2, [r3, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    30f2:	4a22      	ldr	r2, [pc, #136]	; (317c <Reset_Handler+0xe0>)
    30f4:	2390      	movs	r3, #144	; 0x90
    30f6:	005b      	lsls	r3, r3, #1
    30f8:	2102      	movs	r1, #2
    30fa:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    30fc:	4a20      	ldr	r2, [pc, #128]	; (3180 <Reset_Handler+0xe4>)
    30fe:	78d3      	ldrb	r3, [r2, #3]
    3100:	2103      	movs	r1, #3
    3102:	438b      	bics	r3, r1
    3104:	1c19      	adds	r1, r3, #0
    3106:	2302      	movs	r3, #2
    3108:	430b      	orrs	r3, r1
    310a:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    310c:	4a1c      	ldr	r2, [pc, #112]	; (3180 <Reset_Handler+0xe4>)
    310e:	78d3      	ldrb	r3, [r2, #3]
    3110:	210c      	movs	r1, #12
    3112:	438b      	bics	r3, r1
    3114:	1c19      	adds	r1, r3, #0
    3116:	2308      	movs	r3, #8
    3118:	430b      	orrs	r3, r1
    311a:	70d3      	strb	r3, [r2, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
    311c:	4a19      	ldr	r2, [pc, #100]	; (3184 <Reset_Handler+0xe8>)
    311e:	7b93      	ldrb	r3, [r2, #14]
    3120:	2130      	movs	r1, #48	; 0x30
    3122:	438b      	bics	r3, r1
    3124:	1c19      	adds	r1, r3, #0
    3126:	2320      	movs	r3, #32
    3128:	430b      	orrs	r3, r1
    312a:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    312c:	4a15      	ldr	r2, [pc, #84]	; (3184 <Reset_Handler+0xe8>)
    312e:	7b93      	ldrb	r3, [r2, #14]
    3130:	210c      	movs	r1, #12
    3132:	438b      	bics	r3, r1
    3134:	1c19      	adds	r1, r3, #0
    3136:	2308      	movs	r3, #8
    3138:	430b      	orrs	r3, r1
    313a:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    313c:	4a11      	ldr	r2, [pc, #68]	; (3184 <Reset_Handler+0xe8>)
    313e:	7b93      	ldrb	r3, [r2, #14]
    3140:	2103      	movs	r1, #3
    3142:	438b      	bics	r3, r1
    3144:	1c19      	adds	r1, r3, #0
    3146:	2302      	movs	r3, #2
    3148:	430b      	orrs	r3, r1
    314a:	7393      	strb	r3, [r2, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    314c:	4a0e      	ldr	r2, [pc, #56]	; (3188 <Reset_Handler+0xec>)
    314e:	6853      	ldr	r3, [r2, #4]
    3150:	2180      	movs	r1, #128	; 0x80
    3152:	430b      	orrs	r3, r1
    3154:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    3156:	4b0d      	ldr	r3, [pc, #52]	; (318c <Reset_Handler+0xf0>)
    3158:	4798      	blx	r3

        /* Branch to main function */
        main();
    315a:	4b0d      	ldr	r3, [pc, #52]	; (3190 <Reset_Handler+0xf4>)
    315c:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    315e:	e7fe      	b.n	315e <Reset_Handler+0xc2>
    3160:	00004754 	.word	0x00004754
    3164:	20000000 	.word	0x20000000
    3168:	20000074 	.word	0x20000074
    316c:	20000074 	.word	0x20000074
    3170:	200002ec 	.word	0x200002ec
    3174:	00000000 	.word	0x00000000
    3178:	e000ed00 	.word	0xe000ed00
    317c:	41007000 	.word	0x41007000
    3180:	41005000 	.word	0x41005000
    3184:	41004800 	.word	0x41004800
    3188:	41004000 	.word	0x41004000
    318c:	00003d65 	.word	0x00003d65
    3190:	00003391 	.word	0x00003391

00003194 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    3194:	b580      	push	{r7, lr}
    3196:	af00      	add	r7, sp, #0
        while (1) {
    3198:	e7fe      	b.n	3198 <Dummy_Handler+0x4>
	...

0000319c <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    319c:	b580      	push	{r7, lr}
    319e:	b084      	sub	sp, #16
    31a0:	af00      	add	r7, sp, #0
    31a2:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    31a4:	4b0a      	ldr	r3, [pc, #40]	; (31d0 <_sbrk+0x34>)
    31a6:	681b      	ldr	r3, [r3, #0]
    31a8:	2b00      	cmp	r3, #0
    31aa:	d102      	bne.n	31b2 <_sbrk+0x16>
		heap = (unsigned char *)&_end;
    31ac:	4b08      	ldr	r3, [pc, #32]	; (31d0 <_sbrk+0x34>)
    31ae:	4a09      	ldr	r2, [pc, #36]	; (31d4 <_sbrk+0x38>)
    31b0:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
    31b2:	4b07      	ldr	r3, [pc, #28]	; (31d0 <_sbrk+0x34>)
    31b4:	681b      	ldr	r3, [r3, #0]
    31b6:	60fb      	str	r3, [r7, #12]

	heap += incr;
    31b8:	4b05      	ldr	r3, [pc, #20]	; (31d0 <_sbrk+0x34>)
    31ba:	681a      	ldr	r2, [r3, #0]
    31bc:	687b      	ldr	r3, [r7, #4]
    31be:	18d2      	adds	r2, r2, r3
    31c0:	4b03      	ldr	r3, [pc, #12]	; (31d0 <_sbrk+0x34>)
    31c2:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap;
    31c4:	68fb      	ldr	r3, [r7, #12]
}
    31c6:	0018      	movs	r0, r3
    31c8:	46bd      	mov	sp, r7
    31ca:	b004      	add	sp, #16
    31cc:	bd80      	pop	{r7, pc}
    31ce:	46c0      	nop			; (mov r8, r8)
    31d0:	20000178 	.word	0x20000178
    31d4:	200022f0 	.word	0x200022f0

000031d8 <system_pinmux_get_group_from_gpio_pin>:
{
    31d8:	b580      	push	{r7, lr}
    31da:	b084      	sub	sp, #16
    31dc:	af00      	add	r7, sp, #0
    31de:	0002      	movs	r2, r0
    31e0:	1dfb      	adds	r3, r7, #7
    31e2:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    31e4:	230f      	movs	r3, #15
    31e6:	18fb      	adds	r3, r7, r3
    31e8:	1dfa      	adds	r2, r7, #7
    31ea:	7812      	ldrb	r2, [r2, #0]
    31ec:	09d2      	lsrs	r2, r2, #7
    31ee:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    31f0:	230e      	movs	r3, #14
    31f2:	18fb      	adds	r3, r7, r3
    31f4:	1dfa      	adds	r2, r7, #7
    31f6:	7812      	ldrb	r2, [r2, #0]
    31f8:	0952      	lsrs	r2, r2, #5
    31fa:	701a      	strb	r2, [r3, #0]
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    31fc:	4b0d      	ldr	r3, [pc, #52]	; (3234 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    31fe:	60bb      	str	r3, [r7, #8]
	if (port_index < PORT_INST_NUM) {
    3200:	230f      	movs	r3, #15
    3202:	18fb      	adds	r3, r7, r3
    3204:	781b      	ldrb	r3, [r3, #0]
    3206:	2b00      	cmp	r3, #0
    3208:	d10f      	bne.n	322a <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    320a:	230f      	movs	r3, #15
    320c:	18fb      	adds	r3, r7, r3
    320e:	781b      	ldrb	r3, [r3, #0]
    3210:	009b      	lsls	r3, r3, #2
    3212:	2210      	movs	r2, #16
    3214:	4694      	mov	ip, r2
    3216:	44bc      	add	ip, r7
    3218:	4463      	add	r3, ip
    321a:	3b08      	subs	r3, #8
    321c:	681a      	ldr	r2, [r3, #0]
    321e:	230e      	movs	r3, #14
    3220:	18fb      	adds	r3, r7, r3
    3222:	781b      	ldrb	r3, [r3, #0]
    3224:	01db      	lsls	r3, r3, #7
    3226:	18d3      	adds	r3, r2, r3
    3228:	e000      	b.n	322c <system_pinmux_get_group_from_gpio_pin+0x54>
		return NULL;
    322a:	2300      	movs	r3, #0
}
    322c:	0018      	movs	r0, r3
    322e:	46bd      	mov	sp, r7
    3230:	b004      	add	sp, #16
    3232:	bd80      	pop	{r7, pc}
    3234:	41004400 	.word	0x41004400

00003238 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    3238:	b580      	push	{r7, lr}
    323a:	b082      	sub	sp, #8
    323c:	af00      	add	r7, sp, #0
    323e:	0002      	movs	r2, r0
    3240:	1dfb      	adds	r3, r7, #7
    3242:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    3244:	1dfb      	adds	r3, r7, #7
    3246:	781b      	ldrb	r3, [r3, #0]
    3248:	0018      	movs	r0, r3
    324a:	4b03      	ldr	r3, [pc, #12]	; (3258 <port_get_group_from_gpio_pin+0x20>)
    324c:	4798      	blx	r3
    324e:	0003      	movs	r3, r0
}
    3250:	0018      	movs	r0, r3
    3252:	46bd      	mov	sp, r7
    3254:	b002      	add	sp, #8
    3256:	bd80      	pop	{r7, pc}
    3258:	000031d9 	.word	0x000031d9

0000325c <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    325c:	b580      	push	{r7, lr}
    325e:	b082      	sub	sp, #8
    3260:	af00      	add	r7, sp, #0
    3262:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    3264:	687b      	ldr	r3, [r7, #4]
    3266:	2200      	movs	r2, #0
    3268:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    326a:	687b      	ldr	r3, [r7, #4]
    326c:	2201      	movs	r2, #1
    326e:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    3270:	687b      	ldr	r3, [r7, #4]
    3272:	2200      	movs	r2, #0
    3274:	709a      	strb	r2, [r3, #2]
}
    3276:	46c0      	nop			; (mov r8, r8)
    3278:	46bd      	mov	sp, r7
    327a:	b002      	add	sp, #8
    327c:	bd80      	pop	{r7, pc}
	...

00003280 <port_pin_get_input_level>:
 *
 *  \return Status of the port pin's input buffer.
 */
static inline bool port_pin_get_input_level(
		const uint8_t gpio_pin)
{
    3280:	b580      	push	{r7, lr}
    3282:	b084      	sub	sp, #16
    3284:	af00      	add	r7, sp, #0
    3286:	0002      	movs	r2, r0
    3288:	1dfb      	adds	r3, r7, #7
    328a:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    328c:	1dfb      	adds	r3, r7, #7
    328e:	781b      	ldrb	r3, [r3, #0]
    3290:	0018      	movs	r0, r3
    3292:	4b0b      	ldr	r3, [pc, #44]	; (32c0 <port_pin_get_input_level+0x40>)
    3294:	4798      	blx	r3
    3296:	0003      	movs	r3, r0
    3298:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    329a:	1dfb      	adds	r3, r7, #7
    329c:	781b      	ldrb	r3, [r3, #0]
    329e:	221f      	movs	r2, #31
    32a0:	4013      	ands	r3, r2
    32a2:	2201      	movs	r2, #1
    32a4:	409a      	lsls	r2, r3
    32a6:	0013      	movs	r3, r2
    32a8:	60bb      	str	r3, [r7, #8]

	return (port_base->IN.reg & pin_mask);
    32aa:	68fb      	ldr	r3, [r7, #12]
    32ac:	6a1b      	ldr	r3, [r3, #32]
    32ae:	68ba      	ldr	r2, [r7, #8]
    32b0:	4013      	ands	r3, r2
    32b2:	1e5a      	subs	r2, r3, #1
    32b4:	4193      	sbcs	r3, r2
    32b6:	b2db      	uxtb	r3, r3
}
    32b8:	0018      	movs	r0, r3
    32ba:	46bd      	mov	sp, r7
    32bc:	b004      	add	sp, #16
    32be:	bd80      	pop	{r7, pc}
    32c0:	00003239 	.word	0x00003239

000032c4 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    32c4:	b580      	push	{r7, lr}
    32c6:	b084      	sub	sp, #16
    32c8:	af00      	add	r7, sp, #0
    32ca:	0002      	movs	r2, r0
    32cc:	1dfb      	adds	r3, r7, #7
    32ce:	701a      	strb	r2, [r3, #0]
    32d0:	1dbb      	adds	r3, r7, #6
    32d2:	1c0a      	adds	r2, r1, #0
    32d4:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    32d6:	1dfb      	adds	r3, r7, #7
    32d8:	781b      	ldrb	r3, [r3, #0]
    32da:	0018      	movs	r0, r3
    32dc:	4b0d      	ldr	r3, [pc, #52]	; (3314 <port_pin_set_output_level+0x50>)
    32de:	4798      	blx	r3
    32e0:	0003      	movs	r3, r0
    32e2:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    32e4:	1dfb      	adds	r3, r7, #7
    32e6:	781b      	ldrb	r3, [r3, #0]
    32e8:	221f      	movs	r2, #31
    32ea:	4013      	ands	r3, r2
    32ec:	2201      	movs	r2, #1
    32ee:	409a      	lsls	r2, r3
    32f0:	0013      	movs	r3, r2
    32f2:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    32f4:	1dbb      	adds	r3, r7, #6
    32f6:	781b      	ldrb	r3, [r3, #0]
    32f8:	2b00      	cmp	r3, #0
    32fa:	d003      	beq.n	3304 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    32fc:	68fb      	ldr	r3, [r7, #12]
    32fe:	68ba      	ldr	r2, [r7, #8]
    3300:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    3302:	e002      	b.n	330a <port_pin_set_output_level+0x46>
		port_base->OUTCLR.reg = pin_mask;
    3304:	68fb      	ldr	r3, [r7, #12]
    3306:	68ba      	ldr	r2, [r7, #8]
    3308:	615a      	str	r2, [r3, #20]
}
    330a:	46c0      	nop			; (mov r8, r8)
    330c:	46bd      	mov	sp, r7
    330e:	b004      	add	sp, #16
    3310:	bd80      	pop	{r7, pc}
    3312:	46c0      	nop			; (mov r8, r8)
    3314:	00003239 	.word	0x00003239

00003318 <nvm_get_config_defaults>:
{
    3318:	b580      	push	{r7, lr}
    331a:	b082      	sub	sp, #8
    331c:	af00      	add	r7, sp, #0
    331e:	6078      	str	r0, [r7, #4]
	config->sleep_power_mode  = NVM_SLEEP_POWER_MODE_WAKEONACCESS;
    3320:	687b      	ldr	r3, [r7, #4]
    3322:	2200      	movs	r2, #0
    3324:	701a      	strb	r2, [r3, #0]
	config->manual_page_write = true;
    3326:	687b      	ldr	r3, [r7, #4]
    3328:	2201      	movs	r2, #1
    332a:	705a      	strb	r2, [r3, #1]
	config->wait_states       = NVMCTRL->CTRLB.bit.RWS;
    332c:	4b08      	ldr	r3, [pc, #32]	; (3350 <nvm_get_config_defaults+0x38>)
    332e:	685b      	ldr	r3, [r3, #4]
    3330:	06db      	lsls	r3, r3, #27
    3332:	0f1b      	lsrs	r3, r3, #28
    3334:	b2db      	uxtb	r3, r3
    3336:	001a      	movs	r2, r3
    3338:	687b      	ldr	r3, [r7, #4]
    333a:	709a      	strb	r2, [r3, #2]
	config->disable_cache     = false;
    333c:	687b      	ldr	r3, [r7, #4]
    333e:	2200      	movs	r2, #0
    3340:	70da      	strb	r2, [r3, #3]
	config->cache_readmode    = NVM_CACHE_READMODE_NO_MISS_PENALTY;
    3342:	687b      	ldr	r3, [r7, #4]
    3344:	2200      	movs	r2, #0
    3346:	711a      	strb	r2, [r3, #4]
}
    3348:	46c0      	nop			; (mov r8, r8)
    334a:	46bd      	mov	sp, r7
    334c:	b002      	add	sp, #8
    334e:	bd80      	pop	{r7, pc}
    3350:	41004000 	.word	0x41004000

00003354 <sleepmgr_init>:
 * Sets all lock counts to 0, except the very last one, which is set to 1. This
 * is done to simplify the algorithm for finding the deepest allowable sleep
 * mode in \ref sleepmgr_enter_sleep.
 */
static inline void sleepmgr_init(void)
{
    3354:	b580      	push	{r7, lr}
    3356:	b082      	sub	sp, #8
    3358:	af00      	add	r7, sp, #0
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
    335a:	1dfb      	adds	r3, r7, #7
    335c:	2200      	movs	r2, #0
    335e:	701a      	strb	r2, [r3, #0]
    3360:	e009      	b.n	3376 <sleepmgr_init+0x22>
		sleepmgr_locks[i] = 0;
    3362:	1dfb      	adds	r3, r7, #7
    3364:	781b      	ldrb	r3, [r3, #0]
    3366:	4a09      	ldr	r2, [pc, #36]	; (338c <sleepmgr_init+0x38>)
    3368:	2100      	movs	r1, #0
    336a:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
    336c:	1dfb      	adds	r3, r7, #7
    336e:	781a      	ldrb	r2, [r3, #0]
    3370:	1dfb      	adds	r3, r7, #7
    3372:	3201      	adds	r2, #1
    3374:	701a      	strb	r2, [r3, #0]
    3376:	1dfb      	adds	r3, r7, #7
    3378:	781b      	ldrb	r3, [r3, #0]
    337a:	2b03      	cmp	r3, #3
    337c:	d9f1      	bls.n	3362 <sleepmgr_init+0xe>
	}
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
    337e:	4b03      	ldr	r3, [pc, #12]	; (338c <sleepmgr_init+0x38>)
    3380:	2201      	movs	r2, #1
    3382:	711a      	strb	r2, [r3, #4]
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
    3384:	46c0      	nop			; (mov r8, r8)
    3386:	46bd      	mov	sp, r7
    3388:	b002      	add	sp, #8
    338a:	bd80      	pop	{r7, pc}
    338c:	200002e0 	.word	0x200002e0

00003390 <main>:
#define GSM_PWR_AS_OP	GSM_PWR_DDR|=GSM_PWR_POS
#define GSM_PWR_ON		GSM_PWR_PORT|=GSM_PWR_POS
#define GSM_PWR_OFF		GSM_PWR_PORT&=~(GSM_PWR_POS)

int main (void)
{
    3390:	b5f0      	push	{r4, r5, r6, r7, lr}
    3392:	b08d      	sub	sp, #52	; 0x34
    3394:	af00      	add	r7, sp, #0
	system_init();
    3396:	4b50      	ldr	r3, [pc, #320]	; (34d8 <main+0x148>)
    3398:	4798      	blx	r3
	
	sleepmgr_init();
    339a:	4b50      	ldr	r3, [pc, #320]	; (34dc <main+0x14c>)
    339c:	4798      	blx	r3
	
	irq_initialize_vectors();
	cpu_irq_enable();
    339e:	4b50      	ldr	r3, [pc, #320]	; (34e0 <main+0x150>)
    33a0:	2201      	movs	r2, #1
    33a2:	701a      	strb	r2, [r3, #0]
    33a4:	f3bf 8f5f 	dmb	sy
    33a8:	b662      	cpsie	i
	
	delay_init();
    33aa:	4b4e      	ldr	r3, [pc, #312]	; (34e4 <main+0x154>)
    33ac:	4798      	blx	r3
	
	#ifdef LCD_SUPPORT
	LCD_PWR_CONFIG();
    33ae:	4b4e      	ldr	r3, [pc, #312]	; (34e8 <main+0x158>)
    33b0:	4798      	blx	r3
	LCD_PWR_EN();
    33b2:	4b4e      	ldr	r3, [pc, #312]	; (34ec <main+0x15c>)
    33b4:	4798      	blx	r3
	delay_ms(200);
    33b6:	2000      	movs	r0, #0
    33b8:	4b4d      	ldr	r3, [pc, #308]	; (34f0 <main+0x160>)
    33ba:	4798      	blx	r3
    33bc:	0003      	movs	r3, r0
    33be:	60bb      	str	r3, [r7, #8]
    33c0:	2300      	movs	r3, #0
    33c2:	60fb      	str	r3, [r7, #12]
    33c4:	4c4b      	ldr	r4, [pc, #300]	; (34f4 <main+0x164>)
    33c6:	22c8      	movs	r2, #200	; 0xc8
    33c8:	2300      	movs	r3, #0
    33ca:	68b8      	ldr	r0, [r7, #8]
    33cc:	68f9      	ldr	r1, [r7, #12]
    33ce:	47a0      	blx	r4
    33d0:	0003      	movs	r3, r0
    33d2:	000c      	movs	r4, r1
    33d4:	0019      	movs	r1, r3
    33d6:	0022      	movs	r2, r4
    33d8:	4b47      	ldr	r3, [pc, #284]	; (34f8 <main+0x168>)
    33da:	2400      	movs	r4, #0
    33dc:	18c9      	adds	r1, r1, r3
    33de:	4162      	adcs	r2, r4
    33e0:	0008      	movs	r0, r1
    33e2:	0011      	movs	r1, r2
    33e4:	4c45      	ldr	r4, [pc, #276]	; (34fc <main+0x16c>)
    33e6:	4a46      	ldr	r2, [pc, #280]	; (3500 <main+0x170>)
    33e8:	2300      	movs	r3, #0
    33ea:	47a0      	blx	r4
    33ec:	0003      	movs	r3, r0
    33ee:	000c      	movs	r4, r1
    33f0:	0018      	movs	r0, r3
    33f2:	4b44      	ldr	r3, [pc, #272]	; (3504 <main+0x174>)
    33f4:	4798      	blx	r3
	LCD_init();
    33f6:	4b44      	ldr	r3, [pc, #272]	; (3508 <main+0x178>)
    33f8:	4798      	blx	r3
	#endif
	
	struct nvm_config nvm_cfg;
	/* Initialize the NVM */
	nvm_get_config_defaults(&nvm_cfg);
    33fa:	2310      	movs	r3, #16
    33fc:	2210      	movs	r2, #16
    33fe:	4694      	mov	ip, r2
    3400:	44bc      	add	ip, r7
    3402:	4463      	add	r3, ip
    3404:	0018      	movs	r0, r3
    3406:	4b41      	ldr	r3, [pc, #260]	; (350c <main+0x17c>)
    3408:	4798      	blx	r3
	nvm_cfg.manual_page_write = false;
    340a:	2310      	movs	r3, #16
    340c:	2210      	movs	r2, #16
    340e:	4694      	mov	ip, r2
    3410:	44bc      	add	ip, r7
    3412:	4463      	add	r3, ip
    3414:	2200      	movs	r2, #0
    3416:	705a      	strb	r2, [r3, #1]
	nvm_set_config(&nvm_cfg);
    3418:	2310      	movs	r3, #16
    341a:	2210      	movs	r2, #16
    341c:	4694      	mov	ip, r2
    341e:	44bc      	add	ip, r7
    3420:	4463      	add	r3, ip
    3422:	0018      	movs	r0, r3
    3424:	4b3a      	ldr	r3, [pc, #232]	; (3510 <main+0x180>)
    3426:	4798      	blx	r3
	

	#ifdef LCD_SUPPORT
	byte progressbar[8] = {
    3428:	2308      	movs	r3, #8
    342a:	2210      	movs	r2, #16
    342c:	4694      	mov	ip, r2
    342e:	44bc      	add	ip, r7
    3430:	4463      	add	r3, ip
    3432:	0018      	movs	r0, r3
    3434:	2308      	movs	r3, #8
    3436:	001a      	movs	r2, r3
    3438:	2100      	movs	r1, #0
    343a:	4b36      	ldr	r3, [pc, #216]	; (3514 <main+0x184>)
    343c:	4798      	blx	r3
    343e:	2308      	movs	r3, #8
    3440:	2210      	movs	r2, #16
    3442:	4694      	mov	ip, r2
    3444:	44bc      	add	ip, r7
    3446:	4463      	add	r3, ip
    3448:	220f      	movs	r2, #15
    344a:	701a      	strb	r2, [r3, #0]
    344c:	2308      	movs	r3, #8
    344e:	2210      	movs	r2, #16
    3450:	4694      	mov	ip, r2
    3452:	44bc      	add	ip, r7
    3454:	4463      	add	r3, ip
    3456:	220f      	movs	r2, #15
    3458:	705a      	strb	r2, [r3, #1]
    345a:	2308      	movs	r3, #8
    345c:	2210      	movs	r2, #16
    345e:	4694      	mov	ip, r2
    3460:	44bc      	add	ip, r7
    3462:	4463      	add	r3, ip
    3464:	220f      	movs	r2, #15
    3466:	709a      	strb	r2, [r3, #2]
    3468:	2308      	movs	r3, #8
    346a:	2210      	movs	r2, #16
    346c:	4694      	mov	ip, r2
    346e:	44bc      	add	ip, r7
    3470:	4463      	add	r3, ip
    3472:	220f      	movs	r2, #15
    3474:	70da      	strb	r2, [r3, #3]
    3476:	2308      	movs	r3, #8
    3478:	2210      	movs	r2, #16
    347a:	4694      	mov	ip, r2
    347c:	44bc      	add	ip, r7
    347e:	4463      	add	r3, ip
    3480:	220f      	movs	r2, #15
    3482:	711a      	strb	r2, [r3, #4]
    3484:	2308      	movs	r3, #8
    3486:	2210      	movs	r2, #16
    3488:	4694      	mov	ip, r2
    348a:	44bc      	add	ip, r7
    348c:	4463      	add	r3, ip
    348e:	220f      	movs	r2, #15
    3490:	715a      	strb	r2, [r3, #5]
    3492:	2308      	movs	r3, #8
    3494:	2210      	movs	r2, #16
    3496:	4694      	mov	ip, r2
    3498:	44bc      	add	ip, r7
    349a:	4463      	add	r3, ip
    349c:	220f      	movs	r2, #15
    349e:	719a      	strb	r2, [r3, #6]
		B01111,
		B01111,
		B01111,
		B01111,
	};
	LCD_Create_Custom_createChar(0,progressbar);
    34a0:	2308      	movs	r3, #8
    34a2:	2210      	movs	r2, #16
    34a4:	4694      	mov	ip, r2
    34a6:	44bc      	add	ip, r7
    34a8:	4463      	add	r3, ip
    34aa:	0019      	movs	r1, r3
    34ac:	2000      	movs	r0, #0
    34ae:	4b1a      	ldr	r3, [pc, #104]	; (3518 <main+0x188>)
    34b0:	4798      	blx	r3
	LCD_clear();
    34b2:	4b1a      	ldr	r3, [pc, #104]	; (351c <main+0x18c>)
    34b4:	4798      	blx	r3
	lcd_printf("   BOOTING UP   ");
    34b6:	4b1a      	ldr	r3, [pc, #104]	; (3520 <main+0x190>)
    34b8:	0018      	movs	r0, r3
    34ba:	4b1a      	ldr	r3, [pc, #104]	; (3524 <main+0x194>)
    34bc:	4798      	blx	r3
	LCD_setCursor(0,1);
    34be:	2101      	movs	r1, #1
    34c0:	2000      	movs	r0, #0
    34c2:	4b19      	ldr	r3, [pc, #100]	; (3528 <main+0x198>)
    34c4:	4798      	blx	r3
	for (uint8_t i=0;i<16;i++)
    34c6:	231f      	movs	r3, #31
    34c8:	2210      	movs	r2, #16
    34ca:	4694      	mov	ip, r2
    34cc:	44bc      	add	ip, r7
    34ce:	4463      	add	r3, ip
    34d0:	2200      	movs	r2, #0
    34d2:	701a      	strb	r2, [r3, #0]
    34d4:	e05a      	b.n	358c <main+0x1fc>
    34d6:	46c0      	nop			; (mov r8, r8)
    34d8:	00003069 	.word	0x00003069
    34dc:	00003355 	.word	0x00003355
    34e0:	2000000c 	.word	0x2000000c
    34e4:	00001d75 	.word	0x00001d75
    34e8:	000004d5 	.word	0x000004d5
    34ec:	00000509 	.word	0x00000509
    34f0:	00002c51 	.word	0x00002c51
    34f4:	00003b79 	.word	0x00003b79
    34f8:	00001b57 	.word	0x00001b57
    34fc:	00003b39 	.word	0x00003b39
    3500:	00001b58 	.word	0x00001b58
    3504:	20000001 	.word	0x20000001
    3508:	00000211 	.word	0x00000211
    350c:	00003319 	.word	0x00003319
    3510:	00001e05 	.word	0x00001e05
    3514:	00003de7 	.word	0x00003de7
    3518:	000007b1 	.word	0x000007b1
    351c:	00000741 	.word	0x00000741
    3520:	000046b8 	.word	0x000046b8
    3524:	0000090d 	.word	0x0000090d
    3528:	00000811 	.word	0x00000811
	{
		LCD_write(0);
    352c:	2000      	movs	r0, #0
    352e:	4bf9      	ldr	r3, [pc, #996]	; (3914 <main+0x584>)
    3530:	4798      	blx	r3
		delay_ms(50);
    3532:	2000      	movs	r0, #0
    3534:	4bf8      	ldr	r3, [pc, #992]	; (3918 <main+0x588>)
    3536:	4798      	blx	r3
    3538:	0003      	movs	r3, r0
    353a:	603b      	str	r3, [r7, #0]
    353c:	2300      	movs	r3, #0
    353e:	607b      	str	r3, [r7, #4]
    3540:	4cf6      	ldr	r4, [pc, #984]	; (391c <main+0x58c>)
    3542:	2232      	movs	r2, #50	; 0x32
    3544:	2300      	movs	r3, #0
    3546:	6838      	ldr	r0, [r7, #0]
    3548:	6879      	ldr	r1, [r7, #4]
    354a:	47a0      	blx	r4
    354c:	0003      	movs	r3, r0
    354e:	000c      	movs	r4, r1
    3550:	0019      	movs	r1, r3
    3552:	0022      	movs	r2, r4
    3554:	4bf2      	ldr	r3, [pc, #968]	; (3920 <main+0x590>)
    3556:	2400      	movs	r4, #0
    3558:	18c9      	adds	r1, r1, r3
    355a:	4162      	adcs	r2, r4
    355c:	0008      	movs	r0, r1
    355e:	0011      	movs	r1, r2
    3560:	4cf0      	ldr	r4, [pc, #960]	; (3924 <main+0x594>)
    3562:	4af1      	ldr	r2, [pc, #964]	; (3928 <main+0x598>)
    3564:	2300      	movs	r3, #0
    3566:	47a0      	blx	r4
    3568:	0003      	movs	r3, r0
    356a:	000c      	movs	r4, r1
    356c:	0018      	movs	r0, r3
    356e:	4bef      	ldr	r3, [pc, #956]	; (392c <main+0x59c>)
    3570:	4798      	blx	r3
	for (uint8_t i=0;i<16;i++)
    3572:	231f      	movs	r3, #31
    3574:	2210      	movs	r2, #16
    3576:	4694      	mov	ip, r2
    3578:	44bc      	add	ip, r7
    357a:	4463      	add	r3, ip
    357c:	781a      	ldrb	r2, [r3, #0]
    357e:	231f      	movs	r3, #31
    3580:	2110      	movs	r1, #16
    3582:	468c      	mov	ip, r1
    3584:	44bc      	add	ip, r7
    3586:	4463      	add	r3, ip
    3588:	3201      	adds	r2, #1
    358a:	701a      	strb	r2, [r3, #0]
    358c:	231f      	movs	r3, #31
    358e:	2210      	movs	r2, #16
    3590:	4694      	mov	ip, r2
    3592:	44bc      	add	ip, r7
    3594:	4463      	add	r3, ip
    3596:	781b      	ldrb	r3, [r3, #0]
    3598:	2b0f      	cmp	r3, #15
    359a:	d9c7      	bls.n	352c <main+0x19c>
	}
	LCD_clear();
    359c:	4be4      	ldr	r3, [pc, #912]	; (3930 <main+0x5a0>)
    359e:	4798      	blx	r3

struct port_config pin_conf_LED;
port_get_config_defaults(&pin_conf_LED);
    35a0:	2314      	movs	r3, #20
    35a2:	18fb      	adds	r3, r7, r3
    35a4:	0018      	movs	r0, r3
    35a6:	4be3      	ldr	r3, [pc, #908]	; (3934 <main+0x5a4>)
    35a8:	4798      	blx	r3
pin_conf_LED.direction  = PORT_PIN_DIR_OUTPUT;
    35aa:	2314      	movs	r3, #20
    35ac:	18fb      	adds	r3, r7, r3
    35ae:	2201      	movs	r2, #1
    35b0:	701a      	strb	r2, [r3, #0]
port_pin_set_config(AUTO_LED, &pin_conf_LED);
    35b2:	2314      	movs	r3, #20
    35b4:	18fb      	adds	r3, r7, r3
    35b6:	0019      	movs	r1, r3
    35b8:	2028      	movs	r0, #40	; 0x28
    35ba:	4bdf      	ldr	r3, [pc, #892]	; (3938 <main+0x5a8>)
    35bc:	4798      	blx	r3
port_pin_set_config(PHASE_LED, &pin_conf_LED);
    35be:	2314      	movs	r3, #20
    35c0:	18fb      	adds	r3, r7, r3
    35c2:	0019      	movs	r1, r3
    35c4:	2027      	movs	r0, #39	; 0x27
    35c6:	4bdc      	ldr	r3, [pc, #880]	; (3938 <main+0x5a8>)
    35c8:	4798      	blx	r3
port_pin_set_config(MOTOR_LED, &pin_conf_LED);
    35ca:	2314      	movs	r3, #20
    35cc:	18fb      	adds	r3, r7, r3
    35ce:	0019      	movs	r1, r3
    35d0:	2005      	movs	r0, #5
    35d2:	4bd9      	ldr	r3, [pc, #868]	; (3938 <main+0x5a8>)
    35d4:	4798      	blx	r3


port_get_config_defaults(&pin_conf_LED);
    35d6:	2314      	movs	r3, #20
    35d8:	18fb      	adds	r3, r7, r3
    35da:	0018      	movs	r0, r3
    35dc:	4bd5      	ldr	r3, [pc, #852]	; (3934 <main+0x5a4>)
    35de:	4798      	blx	r3
pin_conf_LED.direction = PORT_PIN_DIR_INPUT;
    35e0:	2314      	movs	r3, #20
    35e2:	18fb      	adds	r3, r7, r3
    35e4:	2200      	movs	r2, #0
    35e6:	701a      	strb	r2, [r3, #0]
pin_conf_LED.input_pull = PORT_PIN_PULL_UP;
    35e8:	2314      	movs	r3, #20
    35ea:	18fb      	adds	r3, r7, r3
    35ec:	2201      	movs	r2, #1
    35ee:	705a      	strb	r2, [r3, #1]
//
port_pin_set_config(AUTO_BUTTON, &pin_conf_LED);
    35f0:	2314      	movs	r3, #20
    35f2:	18fb      	adds	r3, r7, r3
    35f4:	0019      	movs	r1, r3
    35f6:	201c      	movs	r0, #28
    35f8:	4bcf      	ldr	r3, [pc, #828]	; (3938 <main+0x5a8>)
    35fa:	4798      	blx	r3
port_pin_set_config(ON_BUTTON, &pin_conf_LED);
    35fc:	2314      	movs	r3, #20
    35fe:	18fb      	adds	r3, r7, r3
    3600:	0019      	movs	r1, r3
    3602:	2026      	movs	r0, #38	; 0x26
    3604:	4bcc      	ldr	r3, [pc, #816]	; (3938 <main+0x5a8>)
    3606:	4798      	blx	r3
port_pin_set_config(OFF_BUTTON, &pin_conf_LED);
    3608:	2314      	movs	r3, #20
    360a:	18fb      	adds	r3, r7, r3
    360c:	0019      	movs	r1, r3
    360e:	2025      	movs	r0, #37	; 0x25
    3610:	4bc9      	ldr	r3, [pc, #804]	; (3938 <main+0x5a8>)
    3612:	4798      	blx	r3
port_pin_set_config(LCD_BUTTON, &pin_conf_LED);
    3614:	2314      	movs	r3, #20
    3616:	18fb      	adds	r3, r7, r3
    3618:	0019      	movs	r1, r3
    361a:	2029      	movs	r0, #41	; 0x29
    361c:	4bc6      	ldr	r3, [pc, #792]	; (3938 <main+0x5a8>)
    361e:	4798      	blx	r3


bool autoLed,phaseLed,MotorLed;
bool autoButtonLevel,onButtonLevel,offButtonLevel,LCDButtonLevel;
autoButtonLevel=onButtonLevel=offButtonLevel=true;
    3620:	2319      	movs	r3, #25
    3622:	2210      	movs	r2, #16
    3624:	4694      	mov	ip, r2
    3626:	44bc      	add	ip, r7
    3628:	4463      	add	r3, ip
    362a:	2201      	movs	r2, #1
    362c:	701a      	strb	r2, [r3, #0]
    362e:	231a      	movs	r3, #26
    3630:	2210      	movs	r2, #16
    3632:	4694      	mov	ip, r2
    3634:	44bc      	add	ip, r7
    3636:	4463      	add	r3, ip
    3638:	2219      	movs	r2, #25
    363a:	2110      	movs	r1, #16
    363c:	468c      	mov	ip, r1
    363e:	44bc      	add	ip, r7
    3640:	4462      	add	r2, ip
    3642:	7812      	ldrb	r2, [r2, #0]
    3644:	701a      	strb	r2, [r3, #0]
    3646:	231b      	movs	r3, #27
    3648:	2210      	movs	r2, #16
    364a:	4694      	mov	ip, r2
    364c:	44bc      	add	ip, r7
    364e:	4463      	add	r3, ip
    3650:	221a      	movs	r2, #26
    3652:	2110      	movs	r1, #16
    3654:	468c      	mov	ip, r1
    3656:	44bc      	add	ip, r7
    3658:	4462      	add	r2, ip
    365a:	7812      	ldrb	r2, [r2, #0]
    365c:	701a      	strb	r2, [r3, #0]
LCDButtonLevel=false;
    365e:	2318      	movs	r3, #24
    3660:	2210      	movs	r2, #16
    3662:	4694      	mov	ip, r2
    3664:	44bc      	add	ip, r7
    3666:	4463      	add	r3, ip
    3668:	2200      	movs	r2, #0
    366a:	701a      	strb	r2, [r3, #0]
autoLed=phaseLed=MotorLed=false;
    366c:	231c      	movs	r3, #28
    366e:	2210      	movs	r2, #16
    3670:	4694      	mov	ip, r2
    3672:	44bc      	add	ip, r7
    3674:	4463      	add	r3, ip
    3676:	2200      	movs	r2, #0
    3678:	701a      	strb	r2, [r3, #0]
    367a:	231d      	movs	r3, #29
    367c:	2210      	movs	r2, #16
    367e:	4694      	mov	ip, r2
    3680:	44bc      	add	ip, r7
    3682:	4463      	add	r3, ip
    3684:	221c      	movs	r2, #28
    3686:	2110      	movs	r1, #16
    3688:	468c      	mov	ip, r1
    368a:	44bc      	add	ip, r7
    368c:	4462      	add	r2, ip
    368e:	7812      	ldrb	r2, [r2, #0]
    3690:	701a      	strb	r2, [r3, #0]
    3692:	231e      	movs	r3, #30
    3694:	2210      	movs	r2, #16
    3696:	4694      	mov	ip, r2
    3698:	44bc      	add	ip, r7
    369a:	4463      	add	r3, ip
    369c:	221d      	movs	r2, #29
    369e:	2110      	movs	r1, #16
    36a0:	468c      	mov	ip, r1
    36a2:	44bc      	add	ip, r7
    36a4:	4462      	add	r2, ip
    36a6:	7812      	ldrb	r2, [r2, #0]
    36a8:	701a      	strb	r2, [r3, #0]
port_pin_set_output_level(AUTO_LED, false);
    36aa:	2100      	movs	r1, #0
    36ac:	2028      	movs	r0, #40	; 0x28
    36ae:	4ba3      	ldr	r3, [pc, #652]	; (393c <main+0x5ac>)
    36b0:	4798      	blx	r3
port_pin_set_output_level(PHASE_LED, false);
    36b2:	2100      	movs	r1, #0
    36b4:	2027      	movs	r0, #39	; 0x27
    36b6:	4ba1      	ldr	r3, [pc, #644]	; (393c <main+0x5ac>)
    36b8:	4798      	blx	r3
port_pin_set_output_level(MOTOR_LED, false);
    36ba:	2100      	movs	r1, #0
    36bc:	2005      	movs	r0, #5
    36be:	4b9f      	ldr	r3, [pc, #636]	; (393c <main+0x5ac>)
    36c0:	4798      	blx	r3
GSM_PWR_AS_OP;
    36c2:	4b9f      	ldr	r3, [pc, #636]	; (3940 <main+0x5b0>)
    36c4:	4a9e      	ldr	r2, [pc, #632]	; (3940 <main+0x5b0>)
    36c6:	6812      	ldr	r2, [r2, #0]
    36c8:	2180      	movs	r1, #128	; 0x80
    36ca:	0249      	lsls	r1, r1, #9
    36cc:	430a      	orrs	r2, r1
    36ce:	601a      	str	r2, [r3, #0]
GSM_PWR_ON;
    36d0:	4b9c      	ldr	r3, [pc, #624]	; (3944 <main+0x5b4>)
    36d2:	4a9c      	ldr	r2, [pc, #624]	; (3944 <main+0x5b4>)
    36d4:	6812      	ldr	r2, [r2, #0]
    36d6:	2180      	movs	r1, #128	; 0x80
    36d8:	0249      	lsls	r1, r1, #9
    36da:	430a      	orrs	r2, r1
    36dc:	601a      	str	r2, [r3, #0]
LCD_setCursor(0,0);
    36de:	2100      	movs	r1, #0
    36e0:	2000      	movs	r0, #0
    36e2:	4b99      	ldr	r3, [pc, #612]	; (3948 <main+0x5b8>)
    36e4:	4798      	blx	r3
lcd_printf("PRESS BUTTON TO");
    36e6:	4b99      	ldr	r3, [pc, #612]	; (394c <main+0x5bc>)
    36e8:	0018      	movs	r0, r3
    36ea:	4b99      	ldr	r3, [pc, #612]	; (3950 <main+0x5c0>)
    36ec:	4798      	blx	r3
LCD_setCursor(0,1);
    36ee:	2101      	movs	r1, #1
    36f0:	2000      	movs	r0, #0
    36f2:	4b95      	ldr	r3, [pc, #596]	; (3948 <main+0x5b8>)
    36f4:	4798      	blx	r3
lcd_printf("GLOW LED");
    36f6:	4b97      	ldr	r3, [pc, #604]	; (3954 <main+0x5c4>)
    36f8:	0018      	movs	r0, r3
    36fa:	4b95      	ldr	r3, [pc, #596]	; (3950 <main+0x5c0>)
    36fc:	4798      	blx	r3
	while(1)
	{

		
		if(autoButtonLevel!=(!port_pin_get_input_level(AUTO_BUTTON)))
    36fe:	201c      	movs	r0, #28
    3700:	4b95      	ldr	r3, [pc, #596]	; (3958 <main+0x5c8>)
    3702:	4798      	blx	r3
    3704:	0003      	movs	r3, r0
    3706:	001a      	movs	r2, r3
    3708:	2301      	movs	r3, #1
    370a:	4053      	eors	r3, r2
    370c:	b2db      	uxtb	r3, r3
    370e:	221b      	movs	r2, #27
    3710:	2110      	movs	r1, #16
    3712:	468c      	mov	ip, r1
    3714:	44bc      	add	ip, r7
    3716:	4462      	add	r2, ip
    3718:	7812      	ldrb	r2, [r2, #0]
    371a:	429a      	cmp	r2, r3
    371c:	d02b      	beq.n	3776 <main+0x3e6>
		{
			autoLed=!autoLed;	
    371e:	231e      	movs	r3, #30
    3720:	2210      	movs	r2, #16
    3722:	4694      	mov	ip, r2
    3724:	44bc      	add	ip, r7
    3726:	4463      	add	r3, ip
    3728:	781b      	ldrb	r3, [r3, #0]
    372a:	1e5a      	subs	r2, r3, #1
    372c:	4193      	sbcs	r3, r2
    372e:	b2db      	uxtb	r3, r3
    3730:	2201      	movs	r2, #1
    3732:	4053      	eors	r3, r2
    3734:	b2db      	uxtb	r3, r3
    3736:	001a      	movs	r2, r3
    3738:	231e      	movs	r3, #30
    373a:	2110      	movs	r1, #16
    373c:	468c      	mov	ip, r1
    373e:	44bc      	add	ip, r7
    3740:	4463      	add	r3, ip
    3742:	701a      	strb	r2, [r3, #0]
    3744:	781a      	ldrb	r2, [r3, #0]
    3746:	2101      	movs	r1, #1
    3748:	400a      	ands	r2, r1
    374a:	701a      	strb	r2, [r3, #0]
			autoButtonLevel=!port_pin_get_input_level(AUTO_BUTTON);
    374c:	201c      	movs	r0, #28
    374e:	4b82      	ldr	r3, [pc, #520]	; (3958 <main+0x5c8>)
    3750:	4798      	blx	r3
    3752:	0003      	movs	r3, r0
    3754:	1e5a      	subs	r2, r3, #1
    3756:	4193      	sbcs	r3, r2
    3758:	b2db      	uxtb	r3, r3
    375a:	2201      	movs	r2, #1
    375c:	4053      	eors	r3, r2
    375e:	b2db      	uxtb	r3, r3
    3760:	001a      	movs	r2, r3
    3762:	231b      	movs	r3, #27
    3764:	2110      	movs	r1, #16
    3766:	468c      	mov	ip, r1
    3768:	44bc      	add	ip, r7
    376a:	4463      	add	r3, ip
    376c:	701a      	strb	r2, [r3, #0]
    376e:	781a      	ldrb	r2, [r3, #0]
    3770:	2101      	movs	r1, #1
    3772:	400a      	ands	r2, r1
    3774:	701a      	strb	r2, [r3, #0]
		}
			port_pin_set_output_level(AUTO_LED, autoLed);
    3776:	231e      	movs	r3, #30
    3778:	2210      	movs	r2, #16
    377a:	4694      	mov	ip, r2
    377c:	44bc      	add	ip, r7
    377e:	4463      	add	r3, ip
    3780:	781b      	ldrb	r3, [r3, #0]
    3782:	0019      	movs	r1, r3
    3784:	2028      	movs	r0, #40	; 0x28
    3786:	4b6d      	ldr	r3, [pc, #436]	; (393c <main+0x5ac>)
    3788:	4798      	blx	r3
		
		if(onButtonLevel!=(!port_pin_get_input_level(ON_BUTTON)))
    378a:	2026      	movs	r0, #38	; 0x26
    378c:	4b72      	ldr	r3, [pc, #456]	; (3958 <main+0x5c8>)
    378e:	4798      	blx	r3
    3790:	0003      	movs	r3, r0
    3792:	001a      	movs	r2, r3
    3794:	2301      	movs	r3, #1
    3796:	4053      	eors	r3, r2
    3798:	b2db      	uxtb	r3, r3
    379a:	221a      	movs	r2, #26
    379c:	2110      	movs	r1, #16
    379e:	468c      	mov	ip, r1
    37a0:	44bc      	add	ip, r7
    37a2:	4462      	add	r2, ip
    37a4:	7812      	ldrb	r2, [r2, #0]
    37a6:	429a      	cmp	r2, r3
    37a8:	d02b      	beq.n	3802 <main+0x472>
		{
			phaseLed=!phaseLed;	
    37aa:	231d      	movs	r3, #29
    37ac:	2210      	movs	r2, #16
    37ae:	4694      	mov	ip, r2
    37b0:	44bc      	add	ip, r7
    37b2:	4463      	add	r3, ip
    37b4:	781b      	ldrb	r3, [r3, #0]
    37b6:	1e5a      	subs	r2, r3, #1
    37b8:	4193      	sbcs	r3, r2
    37ba:	b2db      	uxtb	r3, r3
    37bc:	2201      	movs	r2, #1
    37be:	4053      	eors	r3, r2
    37c0:	b2db      	uxtb	r3, r3
    37c2:	001a      	movs	r2, r3
    37c4:	231d      	movs	r3, #29
    37c6:	2110      	movs	r1, #16
    37c8:	468c      	mov	ip, r1
    37ca:	44bc      	add	ip, r7
    37cc:	4463      	add	r3, ip
    37ce:	701a      	strb	r2, [r3, #0]
    37d0:	781a      	ldrb	r2, [r3, #0]
    37d2:	2101      	movs	r1, #1
    37d4:	400a      	ands	r2, r1
    37d6:	701a      	strb	r2, [r3, #0]
			onButtonLevel=!port_pin_get_input_level(ON_BUTTON);
    37d8:	2026      	movs	r0, #38	; 0x26
    37da:	4b5f      	ldr	r3, [pc, #380]	; (3958 <main+0x5c8>)
    37dc:	4798      	blx	r3
    37de:	0003      	movs	r3, r0
    37e0:	1e5a      	subs	r2, r3, #1
    37e2:	4193      	sbcs	r3, r2
    37e4:	b2db      	uxtb	r3, r3
    37e6:	2201      	movs	r2, #1
    37e8:	4053      	eors	r3, r2
    37ea:	b2db      	uxtb	r3, r3
    37ec:	001a      	movs	r2, r3
    37ee:	231a      	movs	r3, #26
    37f0:	2110      	movs	r1, #16
    37f2:	468c      	mov	ip, r1
    37f4:	44bc      	add	ip, r7
    37f6:	4463      	add	r3, ip
    37f8:	701a      	strb	r2, [r3, #0]
    37fa:	781a      	ldrb	r2, [r3, #0]
    37fc:	2101      	movs	r1, #1
    37fe:	400a      	ands	r2, r1
    3800:	701a      	strb	r2, [r3, #0]
		}
			port_pin_set_output_level(PHASE_LED, phaseLed);
    3802:	231d      	movs	r3, #29
    3804:	2210      	movs	r2, #16
    3806:	4694      	mov	ip, r2
    3808:	44bc      	add	ip, r7
    380a:	4463      	add	r3, ip
    380c:	781b      	ldrb	r3, [r3, #0]
    380e:	0019      	movs	r1, r3
    3810:	2027      	movs	r0, #39	; 0x27
    3812:	4b4a      	ldr	r3, [pc, #296]	; (393c <main+0x5ac>)
    3814:	4798      	blx	r3
		
		if(offButtonLevel!=(!port_pin_get_input_level(OFF_BUTTON)))
    3816:	2025      	movs	r0, #37	; 0x25
    3818:	4b4f      	ldr	r3, [pc, #316]	; (3958 <main+0x5c8>)
    381a:	4798      	blx	r3
    381c:	0003      	movs	r3, r0
    381e:	001a      	movs	r2, r3
    3820:	2301      	movs	r3, #1
    3822:	4053      	eors	r3, r2
    3824:	b2db      	uxtb	r3, r3
    3826:	2219      	movs	r2, #25
    3828:	2110      	movs	r1, #16
    382a:	468c      	mov	ip, r1
    382c:	44bc      	add	ip, r7
    382e:	4462      	add	r2, ip
    3830:	7812      	ldrb	r2, [r2, #0]
    3832:	429a      	cmp	r2, r3
    3834:	d02b      	beq.n	388e <main+0x4fe>
		{
			MotorLed=!MotorLed;	
    3836:	231c      	movs	r3, #28
    3838:	2210      	movs	r2, #16
    383a:	4694      	mov	ip, r2
    383c:	44bc      	add	ip, r7
    383e:	4463      	add	r3, ip
    3840:	781b      	ldrb	r3, [r3, #0]
    3842:	1e5a      	subs	r2, r3, #1
    3844:	4193      	sbcs	r3, r2
    3846:	b2db      	uxtb	r3, r3
    3848:	2201      	movs	r2, #1
    384a:	4053      	eors	r3, r2
    384c:	b2db      	uxtb	r3, r3
    384e:	001a      	movs	r2, r3
    3850:	231c      	movs	r3, #28
    3852:	2110      	movs	r1, #16
    3854:	468c      	mov	ip, r1
    3856:	44bc      	add	ip, r7
    3858:	4463      	add	r3, ip
    385a:	701a      	strb	r2, [r3, #0]
    385c:	781a      	ldrb	r2, [r3, #0]
    385e:	2101      	movs	r1, #1
    3860:	400a      	ands	r2, r1
    3862:	701a      	strb	r2, [r3, #0]
			offButtonLevel=!port_pin_get_input_level(OFF_BUTTON);
    3864:	2025      	movs	r0, #37	; 0x25
    3866:	4b3c      	ldr	r3, [pc, #240]	; (3958 <main+0x5c8>)
    3868:	4798      	blx	r3
    386a:	0003      	movs	r3, r0
    386c:	1e5a      	subs	r2, r3, #1
    386e:	4193      	sbcs	r3, r2
    3870:	b2db      	uxtb	r3, r3
    3872:	2201      	movs	r2, #1
    3874:	4053      	eors	r3, r2
    3876:	b2db      	uxtb	r3, r3
    3878:	001a      	movs	r2, r3
    387a:	2319      	movs	r3, #25
    387c:	2110      	movs	r1, #16
    387e:	468c      	mov	ip, r1
    3880:	44bc      	add	ip, r7
    3882:	4463      	add	r3, ip
    3884:	701a      	strb	r2, [r3, #0]
    3886:	781a      	ldrb	r2, [r3, #0]
    3888:	2101      	movs	r1, #1
    388a:	400a      	ands	r2, r1
    388c:	701a      	strb	r2, [r3, #0]
		}
			port_pin_set_output_level(MOTOR_LED, MotorLed);
    388e:	231c      	movs	r3, #28
    3890:	2210      	movs	r2, #16
    3892:	4694      	mov	ip, r2
    3894:	44bc      	add	ip, r7
    3896:	4463      	add	r3, ip
    3898:	781b      	ldrb	r3, [r3, #0]
    389a:	0019      	movs	r1, r3
    389c:	2005      	movs	r0, #5
    389e:	4b27      	ldr	r3, [pc, #156]	; (393c <main+0x5ac>)
    38a0:	4798      	blx	r3
		
		if(LCDButtonLevel!=(!port_pin_get_input_level(LCD_BUTTON)))
    38a2:	2029      	movs	r0, #41	; 0x29
    38a4:	4b2c      	ldr	r3, [pc, #176]	; (3958 <main+0x5c8>)
    38a6:	4798      	blx	r3
    38a8:	0003      	movs	r3, r0
    38aa:	001a      	movs	r2, r3
    38ac:	2301      	movs	r3, #1
    38ae:	4053      	eors	r3, r2
    38b0:	b2db      	uxtb	r3, r3
    38b2:	2218      	movs	r2, #24
    38b4:	2110      	movs	r1, #16
    38b6:	468c      	mov	ip, r1
    38b8:	44bc      	add	ip, r7
    38ba:	4462      	add	r2, ip
    38bc:	7812      	ldrb	r2, [r2, #0]
    38be:	429a      	cmp	r2, r3
    38c0:	d100      	bne.n	38c4 <main+0x534>
    38c2:	e71c      	b.n	36fe <main+0x36e>
		{
			LCD_clear();
    38c4:	4b1a      	ldr	r3, [pc, #104]	; (3930 <main+0x5a0>)
    38c6:	4798      	blx	r3
			LCD_setCursor(0,1);
    38c8:	2101      	movs	r1, #1
    38ca:	2000      	movs	r0, #0
    38cc:	4b1e      	ldr	r3, [pc, #120]	; (3948 <main+0x5b8>)
    38ce:	4798      	blx	r3
			lcd_printf("LCD BUTTON PRESS");
    38d0:	4b22      	ldr	r3, [pc, #136]	; (395c <main+0x5cc>)
    38d2:	0018      	movs	r0, r3
    38d4:	4b1e      	ldr	r3, [pc, #120]	; (3950 <main+0x5c0>)
    38d6:	4798      	blx	r3
			delay_ms(1000);
    38d8:	2000      	movs	r0, #0
    38da:	4b0f      	ldr	r3, [pc, #60]	; (3918 <main+0x588>)
    38dc:	4798      	blx	r3
    38de:	0003      	movs	r3, r0
    38e0:	001d      	movs	r5, r3
    38e2:	2300      	movs	r3, #0
    38e4:	001e      	movs	r6, r3
    38e6:	4c0d      	ldr	r4, [pc, #52]	; (391c <main+0x58c>)
    38e8:	22fa      	movs	r2, #250	; 0xfa
    38ea:	0092      	lsls	r2, r2, #2
    38ec:	2300      	movs	r3, #0
    38ee:	0028      	movs	r0, r5
    38f0:	0031      	movs	r1, r6
    38f2:	47a0      	blx	r4
    38f4:	0003      	movs	r3, r0
    38f6:	000c      	movs	r4, r1
    38f8:	0019      	movs	r1, r3
    38fa:	0022      	movs	r2, r4
    38fc:	4b08      	ldr	r3, [pc, #32]	; (3920 <main+0x590>)
    38fe:	2400      	movs	r4, #0
    3900:	18c9      	adds	r1, r1, r3
    3902:	4162      	adcs	r2, r4
    3904:	0008      	movs	r0, r1
    3906:	0011      	movs	r1, r2
    3908:	4c06      	ldr	r4, [pc, #24]	; (3924 <main+0x594>)
    390a:	4a07      	ldr	r2, [pc, #28]	; (3928 <main+0x598>)
    390c:	2300      	movs	r3, #0
    390e:	47a0      	blx	r4
    3910:	0003      	movs	r3, r0
    3912:	e025      	b.n	3960 <main+0x5d0>
    3914:	000006c5 	.word	0x000006c5
    3918:	00002c51 	.word	0x00002c51
    391c:	00003b79 	.word	0x00003b79
    3920:	00001b57 	.word	0x00001b57
    3924:	00003b39 	.word	0x00003b39
    3928:	00001b58 	.word	0x00001b58
    392c:	20000001 	.word	0x20000001
    3930:	00000741 	.word	0x00000741
    3934:	0000325d 	.word	0x0000325d
    3938:	00001f05 	.word	0x00001f05
    393c:	000032c5 	.word	0x000032c5
    3940:	41004480 	.word	0x41004480
    3944:	41004490 	.word	0x41004490
    3948:	00000811 	.word	0x00000811
    394c:	000046cc 	.word	0x000046cc
    3950:	0000090d 	.word	0x0000090d
    3954:	000046dc 	.word	0x000046dc
    3958:	00003281 	.word	0x00003281
    395c:	000046e8 	.word	0x000046e8
    3960:	000c      	movs	r4, r1
    3962:	0018      	movs	r0, r3
    3964:	4b0c      	ldr	r3, [pc, #48]	; (3998 <main+0x608>)
    3966:	4798      	blx	r3
			LCDButtonLevel=!port_pin_get_input_level(LCD_BUTTON);
    3968:	2029      	movs	r0, #41	; 0x29
    396a:	4b0c      	ldr	r3, [pc, #48]	; (399c <main+0x60c>)
    396c:	4798      	blx	r3
    396e:	0003      	movs	r3, r0
    3970:	1e5a      	subs	r2, r3, #1
    3972:	4193      	sbcs	r3, r2
    3974:	b2db      	uxtb	r3, r3
    3976:	2201      	movs	r2, #1
    3978:	4053      	eors	r3, r2
    397a:	b2db      	uxtb	r3, r3
    397c:	001a      	movs	r2, r3
    397e:	2318      	movs	r3, #24
    3980:	2110      	movs	r1, #16
    3982:	468c      	mov	ip, r1
    3984:	44bc      	add	ip, r7
    3986:	4463      	add	r3, ip
    3988:	701a      	strb	r2, [r3, #0]
    398a:	781a      	ldrb	r2, [r3, #0]
    398c:	2101      	movs	r1, #1
    398e:	400a      	ands	r2, r1
    3990:	701a      	strb	r2, [r3, #0]
			LCD_clear();
    3992:	4b03      	ldr	r3, [pc, #12]	; (39a0 <main+0x610>)
    3994:	4798      	blx	r3
		if(autoButtonLevel!=(!port_pin_get_input_level(AUTO_BUTTON)))
    3996:	e6b2      	b.n	36fe <main+0x36e>
    3998:	20000001 	.word	0x20000001
    399c:	00003281 	.word	0x00003281
    39a0:	00000741 	.word	0x00000741

000039a4 <__udivsi3>:
    39a4:	2200      	movs	r2, #0
    39a6:	0843      	lsrs	r3, r0, #1
    39a8:	428b      	cmp	r3, r1
    39aa:	d374      	bcc.n	3a96 <__udivsi3+0xf2>
    39ac:	0903      	lsrs	r3, r0, #4
    39ae:	428b      	cmp	r3, r1
    39b0:	d35f      	bcc.n	3a72 <__udivsi3+0xce>
    39b2:	0a03      	lsrs	r3, r0, #8
    39b4:	428b      	cmp	r3, r1
    39b6:	d344      	bcc.n	3a42 <__udivsi3+0x9e>
    39b8:	0b03      	lsrs	r3, r0, #12
    39ba:	428b      	cmp	r3, r1
    39bc:	d328      	bcc.n	3a10 <__udivsi3+0x6c>
    39be:	0c03      	lsrs	r3, r0, #16
    39c0:	428b      	cmp	r3, r1
    39c2:	d30d      	bcc.n	39e0 <__udivsi3+0x3c>
    39c4:	22ff      	movs	r2, #255	; 0xff
    39c6:	0209      	lsls	r1, r1, #8
    39c8:	ba12      	rev	r2, r2
    39ca:	0c03      	lsrs	r3, r0, #16
    39cc:	428b      	cmp	r3, r1
    39ce:	d302      	bcc.n	39d6 <__udivsi3+0x32>
    39d0:	1212      	asrs	r2, r2, #8
    39d2:	0209      	lsls	r1, r1, #8
    39d4:	d065      	beq.n	3aa2 <__udivsi3+0xfe>
    39d6:	0b03      	lsrs	r3, r0, #12
    39d8:	428b      	cmp	r3, r1
    39da:	d319      	bcc.n	3a10 <__udivsi3+0x6c>
    39dc:	e000      	b.n	39e0 <__udivsi3+0x3c>
    39de:	0a09      	lsrs	r1, r1, #8
    39e0:	0bc3      	lsrs	r3, r0, #15
    39e2:	428b      	cmp	r3, r1
    39e4:	d301      	bcc.n	39ea <__udivsi3+0x46>
    39e6:	03cb      	lsls	r3, r1, #15
    39e8:	1ac0      	subs	r0, r0, r3
    39ea:	4152      	adcs	r2, r2
    39ec:	0b83      	lsrs	r3, r0, #14
    39ee:	428b      	cmp	r3, r1
    39f0:	d301      	bcc.n	39f6 <__udivsi3+0x52>
    39f2:	038b      	lsls	r3, r1, #14
    39f4:	1ac0      	subs	r0, r0, r3
    39f6:	4152      	adcs	r2, r2
    39f8:	0b43      	lsrs	r3, r0, #13
    39fa:	428b      	cmp	r3, r1
    39fc:	d301      	bcc.n	3a02 <__udivsi3+0x5e>
    39fe:	034b      	lsls	r3, r1, #13
    3a00:	1ac0      	subs	r0, r0, r3
    3a02:	4152      	adcs	r2, r2
    3a04:	0b03      	lsrs	r3, r0, #12
    3a06:	428b      	cmp	r3, r1
    3a08:	d301      	bcc.n	3a0e <__udivsi3+0x6a>
    3a0a:	030b      	lsls	r3, r1, #12
    3a0c:	1ac0      	subs	r0, r0, r3
    3a0e:	4152      	adcs	r2, r2
    3a10:	0ac3      	lsrs	r3, r0, #11
    3a12:	428b      	cmp	r3, r1
    3a14:	d301      	bcc.n	3a1a <__udivsi3+0x76>
    3a16:	02cb      	lsls	r3, r1, #11
    3a18:	1ac0      	subs	r0, r0, r3
    3a1a:	4152      	adcs	r2, r2
    3a1c:	0a83      	lsrs	r3, r0, #10
    3a1e:	428b      	cmp	r3, r1
    3a20:	d301      	bcc.n	3a26 <__udivsi3+0x82>
    3a22:	028b      	lsls	r3, r1, #10
    3a24:	1ac0      	subs	r0, r0, r3
    3a26:	4152      	adcs	r2, r2
    3a28:	0a43      	lsrs	r3, r0, #9
    3a2a:	428b      	cmp	r3, r1
    3a2c:	d301      	bcc.n	3a32 <__udivsi3+0x8e>
    3a2e:	024b      	lsls	r3, r1, #9
    3a30:	1ac0      	subs	r0, r0, r3
    3a32:	4152      	adcs	r2, r2
    3a34:	0a03      	lsrs	r3, r0, #8
    3a36:	428b      	cmp	r3, r1
    3a38:	d301      	bcc.n	3a3e <__udivsi3+0x9a>
    3a3a:	020b      	lsls	r3, r1, #8
    3a3c:	1ac0      	subs	r0, r0, r3
    3a3e:	4152      	adcs	r2, r2
    3a40:	d2cd      	bcs.n	39de <__udivsi3+0x3a>
    3a42:	09c3      	lsrs	r3, r0, #7
    3a44:	428b      	cmp	r3, r1
    3a46:	d301      	bcc.n	3a4c <__udivsi3+0xa8>
    3a48:	01cb      	lsls	r3, r1, #7
    3a4a:	1ac0      	subs	r0, r0, r3
    3a4c:	4152      	adcs	r2, r2
    3a4e:	0983      	lsrs	r3, r0, #6
    3a50:	428b      	cmp	r3, r1
    3a52:	d301      	bcc.n	3a58 <__udivsi3+0xb4>
    3a54:	018b      	lsls	r3, r1, #6
    3a56:	1ac0      	subs	r0, r0, r3
    3a58:	4152      	adcs	r2, r2
    3a5a:	0943      	lsrs	r3, r0, #5
    3a5c:	428b      	cmp	r3, r1
    3a5e:	d301      	bcc.n	3a64 <__udivsi3+0xc0>
    3a60:	014b      	lsls	r3, r1, #5
    3a62:	1ac0      	subs	r0, r0, r3
    3a64:	4152      	adcs	r2, r2
    3a66:	0903      	lsrs	r3, r0, #4
    3a68:	428b      	cmp	r3, r1
    3a6a:	d301      	bcc.n	3a70 <__udivsi3+0xcc>
    3a6c:	010b      	lsls	r3, r1, #4
    3a6e:	1ac0      	subs	r0, r0, r3
    3a70:	4152      	adcs	r2, r2
    3a72:	08c3      	lsrs	r3, r0, #3
    3a74:	428b      	cmp	r3, r1
    3a76:	d301      	bcc.n	3a7c <__udivsi3+0xd8>
    3a78:	00cb      	lsls	r3, r1, #3
    3a7a:	1ac0      	subs	r0, r0, r3
    3a7c:	4152      	adcs	r2, r2
    3a7e:	0883      	lsrs	r3, r0, #2
    3a80:	428b      	cmp	r3, r1
    3a82:	d301      	bcc.n	3a88 <__udivsi3+0xe4>
    3a84:	008b      	lsls	r3, r1, #2
    3a86:	1ac0      	subs	r0, r0, r3
    3a88:	4152      	adcs	r2, r2
    3a8a:	0843      	lsrs	r3, r0, #1
    3a8c:	428b      	cmp	r3, r1
    3a8e:	d301      	bcc.n	3a94 <__udivsi3+0xf0>
    3a90:	004b      	lsls	r3, r1, #1
    3a92:	1ac0      	subs	r0, r0, r3
    3a94:	4152      	adcs	r2, r2
    3a96:	1a41      	subs	r1, r0, r1
    3a98:	d200      	bcs.n	3a9c <__udivsi3+0xf8>
    3a9a:	4601      	mov	r1, r0
    3a9c:	4152      	adcs	r2, r2
    3a9e:	4610      	mov	r0, r2
    3aa0:	4770      	bx	lr
    3aa2:	e7ff      	b.n	3aa4 <__udivsi3+0x100>
    3aa4:	b501      	push	{r0, lr}
    3aa6:	2000      	movs	r0, #0
    3aa8:	f000 f806 	bl	3ab8 <__aeabi_idiv0>
    3aac:	bd02      	pop	{r1, pc}
    3aae:	46c0      	nop			; (mov r8, r8)

00003ab0 <__aeabi_uidivmod>:
    3ab0:	2900      	cmp	r1, #0
    3ab2:	d0f7      	beq.n	3aa4 <__udivsi3+0x100>
    3ab4:	e776      	b.n	39a4 <__udivsi3>
    3ab6:	4770      	bx	lr

00003ab8 <__aeabi_idiv0>:
    3ab8:	4770      	bx	lr
    3aba:	46c0      	nop			; (mov r8, r8)

00003abc <__clzsi2>:
    3abc:	211c      	movs	r1, #28
    3abe:	2301      	movs	r3, #1
    3ac0:	041b      	lsls	r3, r3, #16
    3ac2:	4298      	cmp	r0, r3
    3ac4:	d301      	bcc.n	3aca <__clzsi2+0xe>
    3ac6:	0c00      	lsrs	r0, r0, #16
    3ac8:	3910      	subs	r1, #16
    3aca:	0a1b      	lsrs	r3, r3, #8
    3acc:	4298      	cmp	r0, r3
    3ace:	d301      	bcc.n	3ad4 <__clzsi2+0x18>
    3ad0:	0a00      	lsrs	r0, r0, #8
    3ad2:	3908      	subs	r1, #8
    3ad4:	091b      	lsrs	r3, r3, #4
    3ad6:	4298      	cmp	r0, r3
    3ad8:	d301      	bcc.n	3ade <__clzsi2+0x22>
    3ada:	0900      	lsrs	r0, r0, #4
    3adc:	3904      	subs	r1, #4
    3ade:	a202      	add	r2, pc, #8	; (adr r2, 3ae8 <__clzsi2+0x2c>)
    3ae0:	5c10      	ldrb	r0, [r2, r0]
    3ae2:	1840      	adds	r0, r0, r1
    3ae4:	4770      	bx	lr
    3ae6:	46c0      	nop			; (mov r8, r8)
    3ae8:	02020304 	.word	0x02020304
    3aec:	01010101 	.word	0x01010101
	...

00003af8 <__ctzsi2>:
    3af8:	4241      	negs	r1, r0
    3afa:	4008      	ands	r0, r1
    3afc:	211c      	movs	r1, #28
    3afe:	2301      	movs	r3, #1
    3b00:	041b      	lsls	r3, r3, #16
    3b02:	4298      	cmp	r0, r3
    3b04:	d301      	bcc.n	3b0a <__ctzsi2+0x12>
    3b06:	0c00      	lsrs	r0, r0, #16
    3b08:	3910      	subs	r1, #16
    3b0a:	0a1b      	lsrs	r3, r3, #8
    3b0c:	4298      	cmp	r0, r3
    3b0e:	d301      	bcc.n	3b14 <__ctzsi2+0x1c>
    3b10:	0a00      	lsrs	r0, r0, #8
    3b12:	3908      	subs	r1, #8
    3b14:	091b      	lsrs	r3, r3, #4
    3b16:	4298      	cmp	r0, r3
    3b18:	d301      	bcc.n	3b1e <__ctzsi2+0x26>
    3b1a:	0900      	lsrs	r0, r0, #4
    3b1c:	3904      	subs	r1, #4
    3b1e:	a202      	add	r2, pc, #8	; (adr r2, 3b28 <__ctzsi2+0x30>)
    3b20:	5c10      	ldrb	r0, [r2, r0]
    3b22:	1a40      	subs	r0, r0, r1
    3b24:	4770      	bx	lr
    3b26:	46c0      	nop			; (mov r8, r8)
    3b28:	1d1d1c1b 	.word	0x1d1d1c1b
    3b2c:	1e1e1e1e 	.word	0x1e1e1e1e
    3b30:	1f1f1f1f 	.word	0x1f1f1f1f
    3b34:	1f1f1f1f 	.word	0x1f1f1f1f

00003b38 <__aeabi_uldivmod>:
    3b38:	2b00      	cmp	r3, #0
    3b3a:	d111      	bne.n	3b60 <__aeabi_uldivmod+0x28>
    3b3c:	2a00      	cmp	r2, #0
    3b3e:	d10f      	bne.n	3b60 <__aeabi_uldivmod+0x28>
    3b40:	2900      	cmp	r1, #0
    3b42:	d100      	bne.n	3b46 <__aeabi_uldivmod+0xe>
    3b44:	2800      	cmp	r0, #0
    3b46:	d002      	beq.n	3b4e <__aeabi_uldivmod+0x16>
    3b48:	2100      	movs	r1, #0
    3b4a:	43c9      	mvns	r1, r1
    3b4c:	1c08      	adds	r0, r1, #0
    3b4e:	b407      	push	{r0, r1, r2}
    3b50:	4802      	ldr	r0, [pc, #8]	; (3b5c <__aeabi_uldivmod+0x24>)
    3b52:	a102      	add	r1, pc, #8	; (adr r1, 3b5c <__aeabi_uldivmod+0x24>)
    3b54:	1840      	adds	r0, r0, r1
    3b56:	9002      	str	r0, [sp, #8]
    3b58:	bd03      	pop	{r0, r1, pc}
    3b5a:	46c0      	nop			; (mov r8, r8)
    3b5c:	ffffff5d 	.word	0xffffff5d
    3b60:	b403      	push	{r0, r1}
    3b62:	4668      	mov	r0, sp
    3b64:	b501      	push	{r0, lr}
    3b66:	9802      	ldr	r0, [sp, #8]
    3b68:	f000 f830 	bl	3bcc <__udivmoddi4>
    3b6c:	9b01      	ldr	r3, [sp, #4]
    3b6e:	469e      	mov	lr, r3
    3b70:	b002      	add	sp, #8
    3b72:	bc0c      	pop	{r2, r3}
    3b74:	4770      	bx	lr
    3b76:	46c0      	nop			; (mov r8, r8)

00003b78 <__aeabi_lmul>:
    3b78:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b7a:	46ce      	mov	lr, r9
    3b7c:	4647      	mov	r7, r8
    3b7e:	0415      	lsls	r5, r2, #16
    3b80:	0c2d      	lsrs	r5, r5, #16
    3b82:	002e      	movs	r6, r5
    3b84:	b580      	push	{r7, lr}
    3b86:	0407      	lsls	r7, r0, #16
    3b88:	0c14      	lsrs	r4, r2, #16
    3b8a:	0c3f      	lsrs	r7, r7, #16
    3b8c:	4699      	mov	r9, r3
    3b8e:	0c03      	lsrs	r3, r0, #16
    3b90:	437e      	muls	r6, r7
    3b92:	435d      	muls	r5, r3
    3b94:	4367      	muls	r7, r4
    3b96:	4363      	muls	r3, r4
    3b98:	197f      	adds	r7, r7, r5
    3b9a:	0c34      	lsrs	r4, r6, #16
    3b9c:	19e4      	adds	r4, r4, r7
    3b9e:	469c      	mov	ip, r3
    3ba0:	42a5      	cmp	r5, r4
    3ba2:	d903      	bls.n	3bac <__aeabi_lmul+0x34>
    3ba4:	2380      	movs	r3, #128	; 0x80
    3ba6:	025b      	lsls	r3, r3, #9
    3ba8:	4698      	mov	r8, r3
    3baa:	44c4      	add	ip, r8
    3bac:	464b      	mov	r3, r9
    3bae:	4351      	muls	r1, r2
    3bb0:	4343      	muls	r3, r0
    3bb2:	0436      	lsls	r6, r6, #16
    3bb4:	0c36      	lsrs	r6, r6, #16
    3bb6:	0c25      	lsrs	r5, r4, #16
    3bb8:	0424      	lsls	r4, r4, #16
    3bba:	4465      	add	r5, ip
    3bbc:	19a4      	adds	r4, r4, r6
    3bbe:	1859      	adds	r1, r3, r1
    3bc0:	1949      	adds	r1, r1, r5
    3bc2:	0020      	movs	r0, r4
    3bc4:	bc0c      	pop	{r2, r3}
    3bc6:	4690      	mov	r8, r2
    3bc8:	4699      	mov	r9, r3
    3bca:	bdf0      	pop	{r4, r5, r6, r7, pc}

00003bcc <__udivmoddi4>:
    3bcc:	b5f0      	push	{r4, r5, r6, r7, lr}
    3bce:	4657      	mov	r7, sl
    3bd0:	464e      	mov	r6, r9
    3bd2:	4645      	mov	r5, r8
    3bd4:	46de      	mov	lr, fp
    3bd6:	b5e0      	push	{r5, r6, r7, lr}
    3bd8:	0004      	movs	r4, r0
    3bda:	b083      	sub	sp, #12
    3bdc:	000d      	movs	r5, r1
    3bde:	4692      	mov	sl, r2
    3be0:	4699      	mov	r9, r3
    3be2:	428b      	cmp	r3, r1
    3be4:	d82f      	bhi.n	3c46 <__udivmoddi4+0x7a>
    3be6:	d02c      	beq.n	3c42 <__udivmoddi4+0x76>
    3be8:	4649      	mov	r1, r9
    3bea:	4650      	mov	r0, sl
    3bec:	f000 f8ae 	bl	3d4c <__clzdi2>
    3bf0:	0029      	movs	r1, r5
    3bf2:	0006      	movs	r6, r0
    3bf4:	0020      	movs	r0, r4
    3bf6:	f000 f8a9 	bl	3d4c <__clzdi2>
    3bfa:	1a33      	subs	r3, r6, r0
    3bfc:	4698      	mov	r8, r3
    3bfe:	3b20      	subs	r3, #32
    3c00:	469b      	mov	fp, r3
    3c02:	d500      	bpl.n	3c06 <__udivmoddi4+0x3a>
    3c04:	e074      	b.n	3cf0 <__udivmoddi4+0x124>
    3c06:	4653      	mov	r3, sl
    3c08:	465a      	mov	r2, fp
    3c0a:	4093      	lsls	r3, r2
    3c0c:	001f      	movs	r7, r3
    3c0e:	4653      	mov	r3, sl
    3c10:	4642      	mov	r2, r8
    3c12:	4093      	lsls	r3, r2
    3c14:	001e      	movs	r6, r3
    3c16:	42af      	cmp	r7, r5
    3c18:	d829      	bhi.n	3c6e <__udivmoddi4+0xa2>
    3c1a:	d026      	beq.n	3c6a <__udivmoddi4+0x9e>
    3c1c:	465b      	mov	r3, fp
    3c1e:	1ba4      	subs	r4, r4, r6
    3c20:	41bd      	sbcs	r5, r7
    3c22:	2b00      	cmp	r3, #0
    3c24:	da00      	bge.n	3c28 <__udivmoddi4+0x5c>
    3c26:	e079      	b.n	3d1c <__udivmoddi4+0x150>
    3c28:	2200      	movs	r2, #0
    3c2a:	2300      	movs	r3, #0
    3c2c:	9200      	str	r2, [sp, #0]
    3c2e:	9301      	str	r3, [sp, #4]
    3c30:	2301      	movs	r3, #1
    3c32:	465a      	mov	r2, fp
    3c34:	4093      	lsls	r3, r2
    3c36:	9301      	str	r3, [sp, #4]
    3c38:	2301      	movs	r3, #1
    3c3a:	4642      	mov	r2, r8
    3c3c:	4093      	lsls	r3, r2
    3c3e:	9300      	str	r3, [sp, #0]
    3c40:	e019      	b.n	3c76 <__udivmoddi4+0xaa>
    3c42:	4282      	cmp	r2, r0
    3c44:	d9d0      	bls.n	3be8 <__udivmoddi4+0x1c>
    3c46:	2200      	movs	r2, #0
    3c48:	2300      	movs	r3, #0
    3c4a:	9200      	str	r2, [sp, #0]
    3c4c:	9301      	str	r3, [sp, #4]
    3c4e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3c50:	2b00      	cmp	r3, #0
    3c52:	d001      	beq.n	3c58 <__udivmoddi4+0x8c>
    3c54:	601c      	str	r4, [r3, #0]
    3c56:	605d      	str	r5, [r3, #4]
    3c58:	9800      	ldr	r0, [sp, #0]
    3c5a:	9901      	ldr	r1, [sp, #4]
    3c5c:	b003      	add	sp, #12
    3c5e:	bc3c      	pop	{r2, r3, r4, r5}
    3c60:	4690      	mov	r8, r2
    3c62:	4699      	mov	r9, r3
    3c64:	46a2      	mov	sl, r4
    3c66:	46ab      	mov	fp, r5
    3c68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c6a:	42a3      	cmp	r3, r4
    3c6c:	d9d6      	bls.n	3c1c <__udivmoddi4+0x50>
    3c6e:	2200      	movs	r2, #0
    3c70:	2300      	movs	r3, #0
    3c72:	9200      	str	r2, [sp, #0]
    3c74:	9301      	str	r3, [sp, #4]
    3c76:	4643      	mov	r3, r8
    3c78:	2b00      	cmp	r3, #0
    3c7a:	d0e8      	beq.n	3c4e <__udivmoddi4+0x82>
    3c7c:	07fb      	lsls	r3, r7, #31
    3c7e:	0872      	lsrs	r2, r6, #1
    3c80:	431a      	orrs	r2, r3
    3c82:	4646      	mov	r6, r8
    3c84:	087b      	lsrs	r3, r7, #1
    3c86:	e00e      	b.n	3ca6 <__udivmoddi4+0xda>
    3c88:	42ab      	cmp	r3, r5
    3c8a:	d101      	bne.n	3c90 <__udivmoddi4+0xc4>
    3c8c:	42a2      	cmp	r2, r4
    3c8e:	d80c      	bhi.n	3caa <__udivmoddi4+0xde>
    3c90:	1aa4      	subs	r4, r4, r2
    3c92:	419d      	sbcs	r5, r3
    3c94:	2001      	movs	r0, #1
    3c96:	1924      	adds	r4, r4, r4
    3c98:	416d      	adcs	r5, r5
    3c9a:	2100      	movs	r1, #0
    3c9c:	3e01      	subs	r6, #1
    3c9e:	1824      	adds	r4, r4, r0
    3ca0:	414d      	adcs	r5, r1
    3ca2:	2e00      	cmp	r6, #0
    3ca4:	d006      	beq.n	3cb4 <__udivmoddi4+0xe8>
    3ca6:	42ab      	cmp	r3, r5
    3ca8:	d9ee      	bls.n	3c88 <__udivmoddi4+0xbc>
    3caa:	3e01      	subs	r6, #1
    3cac:	1924      	adds	r4, r4, r4
    3cae:	416d      	adcs	r5, r5
    3cb0:	2e00      	cmp	r6, #0
    3cb2:	d1f8      	bne.n	3ca6 <__udivmoddi4+0xda>
    3cb4:	465b      	mov	r3, fp
    3cb6:	9800      	ldr	r0, [sp, #0]
    3cb8:	9901      	ldr	r1, [sp, #4]
    3cba:	1900      	adds	r0, r0, r4
    3cbc:	4169      	adcs	r1, r5
    3cbe:	2b00      	cmp	r3, #0
    3cc0:	db22      	blt.n	3d08 <__udivmoddi4+0x13c>
    3cc2:	002b      	movs	r3, r5
    3cc4:	465a      	mov	r2, fp
    3cc6:	40d3      	lsrs	r3, r2
    3cc8:	002a      	movs	r2, r5
    3cca:	4644      	mov	r4, r8
    3ccc:	40e2      	lsrs	r2, r4
    3cce:	001c      	movs	r4, r3
    3cd0:	465b      	mov	r3, fp
    3cd2:	0015      	movs	r5, r2
    3cd4:	2b00      	cmp	r3, #0
    3cd6:	db2c      	blt.n	3d32 <__udivmoddi4+0x166>
    3cd8:	0026      	movs	r6, r4
    3cda:	409e      	lsls	r6, r3
    3cdc:	0033      	movs	r3, r6
    3cde:	0026      	movs	r6, r4
    3ce0:	4647      	mov	r7, r8
    3ce2:	40be      	lsls	r6, r7
    3ce4:	0032      	movs	r2, r6
    3ce6:	1a80      	subs	r0, r0, r2
    3ce8:	4199      	sbcs	r1, r3
    3cea:	9000      	str	r0, [sp, #0]
    3cec:	9101      	str	r1, [sp, #4]
    3cee:	e7ae      	b.n	3c4e <__udivmoddi4+0x82>
    3cf0:	4642      	mov	r2, r8
    3cf2:	2320      	movs	r3, #32
    3cf4:	1a9b      	subs	r3, r3, r2
    3cf6:	4652      	mov	r2, sl
    3cf8:	40da      	lsrs	r2, r3
    3cfa:	4641      	mov	r1, r8
    3cfc:	0013      	movs	r3, r2
    3cfe:	464a      	mov	r2, r9
    3d00:	408a      	lsls	r2, r1
    3d02:	0017      	movs	r7, r2
    3d04:	431f      	orrs	r7, r3
    3d06:	e782      	b.n	3c0e <__udivmoddi4+0x42>
    3d08:	4642      	mov	r2, r8
    3d0a:	2320      	movs	r3, #32
    3d0c:	1a9b      	subs	r3, r3, r2
    3d0e:	002a      	movs	r2, r5
    3d10:	4646      	mov	r6, r8
    3d12:	409a      	lsls	r2, r3
    3d14:	0023      	movs	r3, r4
    3d16:	40f3      	lsrs	r3, r6
    3d18:	4313      	orrs	r3, r2
    3d1a:	e7d5      	b.n	3cc8 <__udivmoddi4+0xfc>
    3d1c:	4642      	mov	r2, r8
    3d1e:	2320      	movs	r3, #32
    3d20:	2100      	movs	r1, #0
    3d22:	1a9b      	subs	r3, r3, r2
    3d24:	2200      	movs	r2, #0
    3d26:	9100      	str	r1, [sp, #0]
    3d28:	9201      	str	r2, [sp, #4]
    3d2a:	2201      	movs	r2, #1
    3d2c:	40da      	lsrs	r2, r3
    3d2e:	9201      	str	r2, [sp, #4]
    3d30:	e782      	b.n	3c38 <__udivmoddi4+0x6c>
    3d32:	4642      	mov	r2, r8
    3d34:	2320      	movs	r3, #32
    3d36:	0026      	movs	r6, r4
    3d38:	1a9b      	subs	r3, r3, r2
    3d3a:	40de      	lsrs	r6, r3
    3d3c:	002f      	movs	r7, r5
    3d3e:	46b4      	mov	ip, r6
    3d40:	4097      	lsls	r7, r2
    3d42:	4666      	mov	r6, ip
    3d44:	003b      	movs	r3, r7
    3d46:	4333      	orrs	r3, r6
    3d48:	e7c9      	b.n	3cde <__udivmoddi4+0x112>
    3d4a:	46c0      	nop			; (mov r8, r8)

00003d4c <__clzdi2>:
    3d4c:	b510      	push	{r4, lr}
    3d4e:	2900      	cmp	r1, #0
    3d50:	d103      	bne.n	3d5a <__clzdi2+0xe>
    3d52:	f7ff feb3 	bl	3abc <__clzsi2>
    3d56:	3020      	adds	r0, #32
    3d58:	e002      	b.n	3d60 <__clzdi2+0x14>
    3d5a:	1c08      	adds	r0, r1, #0
    3d5c:	f7ff feae 	bl	3abc <__clzsi2>
    3d60:	bd10      	pop	{r4, pc}
    3d62:	46c0      	nop			; (mov r8, r8)

00003d64 <__libc_init_array>:
    3d64:	b570      	push	{r4, r5, r6, lr}
    3d66:	2600      	movs	r6, #0
    3d68:	4d0c      	ldr	r5, [pc, #48]	; (3d9c <__libc_init_array+0x38>)
    3d6a:	4c0d      	ldr	r4, [pc, #52]	; (3da0 <__libc_init_array+0x3c>)
    3d6c:	1b64      	subs	r4, r4, r5
    3d6e:	10a4      	asrs	r4, r4, #2
    3d70:	42a6      	cmp	r6, r4
    3d72:	d109      	bne.n	3d88 <__libc_init_array+0x24>
    3d74:	2600      	movs	r6, #0
    3d76:	f000 fcd9 	bl	472c <_init>
    3d7a:	4d0a      	ldr	r5, [pc, #40]	; (3da4 <__libc_init_array+0x40>)
    3d7c:	4c0a      	ldr	r4, [pc, #40]	; (3da8 <__libc_init_array+0x44>)
    3d7e:	1b64      	subs	r4, r4, r5
    3d80:	10a4      	asrs	r4, r4, #2
    3d82:	42a6      	cmp	r6, r4
    3d84:	d105      	bne.n	3d92 <__libc_init_array+0x2e>
    3d86:	bd70      	pop	{r4, r5, r6, pc}
    3d88:	00b3      	lsls	r3, r6, #2
    3d8a:	58eb      	ldr	r3, [r5, r3]
    3d8c:	4798      	blx	r3
    3d8e:	3601      	adds	r6, #1
    3d90:	e7ee      	b.n	3d70 <__libc_init_array+0xc>
    3d92:	00b3      	lsls	r3, r6, #2
    3d94:	58eb      	ldr	r3, [r5, r3]
    3d96:	4798      	blx	r3
    3d98:	3601      	adds	r6, #1
    3d9a:	e7f2      	b.n	3d82 <__libc_init_array+0x1e>
    3d9c:	00004738 	.word	0x00004738
    3da0:	00004738 	.word	0x00004738
    3da4:	00004738 	.word	0x00004738
    3da8:	0000473c 	.word	0x0000473c

00003dac <malloc>:
    3dac:	b510      	push	{r4, lr}
    3dae:	4b03      	ldr	r3, [pc, #12]	; (3dbc <malloc+0x10>)
    3db0:	0001      	movs	r1, r0
    3db2:	6818      	ldr	r0, [r3, #0]
    3db4:	f000 f86a 	bl	3e8c <_malloc_r>
    3db8:	bd10      	pop	{r4, pc}
    3dba:	46c0      	nop			; (mov r8, r8)
    3dbc:	20000010 	.word	0x20000010

00003dc0 <free>:
    3dc0:	b510      	push	{r4, lr}
    3dc2:	4b03      	ldr	r3, [pc, #12]	; (3dd0 <free+0x10>)
    3dc4:	0001      	movs	r1, r0
    3dc6:	6818      	ldr	r0, [r3, #0]
    3dc8:	f000 f816 	bl	3df8 <_free_r>
    3dcc:	bd10      	pop	{r4, pc}
    3dce:	46c0      	nop			; (mov r8, r8)
    3dd0:	20000010 	.word	0x20000010

00003dd4 <memcpy>:
    3dd4:	2300      	movs	r3, #0
    3dd6:	b510      	push	{r4, lr}
    3dd8:	429a      	cmp	r2, r3
    3dda:	d100      	bne.n	3dde <memcpy+0xa>
    3ddc:	bd10      	pop	{r4, pc}
    3dde:	5ccc      	ldrb	r4, [r1, r3]
    3de0:	54c4      	strb	r4, [r0, r3]
    3de2:	3301      	adds	r3, #1
    3de4:	e7f8      	b.n	3dd8 <memcpy+0x4>

00003de6 <memset>:
    3de6:	0003      	movs	r3, r0
    3de8:	1882      	adds	r2, r0, r2
    3dea:	4293      	cmp	r3, r2
    3dec:	d100      	bne.n	3df0 <memset+0xa>
    3dee:	4770      	bx	lr
    3df0:	7019      	strb	r1, [r3, #0]
    3df2:	3301      	adds	r3, #1
    3df4:	e7f9      	b.n	3dea <memset+0x4>
	...

00003df8 <_free_r>:
    3df8:	b570      	push	{r4, r5, r6, lr}
    3dfa:	0005      	movs	r5, r0
    3dfc:	2900      	cmp	r1, #0
    3dfe:	d010      	beq.n	3e22 <_free_r+0x2a>
    3e00:	1f0c      	subs	r4, r1, #4
    3e02:	6823      	ldr	r3, [r4, #0]
    3e04:	2b00      	cmp	r3, #0
    3e06:	da00      	bge.n	3e0a <_free_r+0x12>
    3e08:	18e4      	adds	r4, r4, r3
    3e0a:	0028      	movs	r0, r5
    3e0c:	f000 f8da 	bl	3fc4 <__malloc_lock>
    3e10:	4a1d      	ldr	r2, [pc, #116]	; (3e88 <_free_r+0x90>)
    3e12:	6813      	ldr	r3, [r2, #0]
    3e14:	2b00      	cmp	r3, #0
    3e16:	d105      	bne.n	3e24 <_free_r+0x2c>
    3e18:	6063      	str	r3, [r4, #4]
    3e1a:	6014      	str	r4, [r2, #0]
    3e1c:	0028      	movs	r0, r5
    3e1e:	f000 f8d2 	bl	3fc6 <__malloc_unlock>
    3e22:	bd70      	pop	{r4, r5, r6, pc}
    3e24:	42a3      	cmp	r3, r4
    3e26:	d909      	bls.n	3e3c <_free_r+0x44>
    3e28:	6821      	ldr	r1, [r4, #0]
    3e2a:	1860      	adds	r0, r4, r1
    3e2c:	4283      	cmp	r3, r0
    3e2e:	d1f3      	bne.n	3e18 <_free_r+0x20>
    3e30:	6818      	ldr	r0, [r3, #0]
    3e32:	685b      	ldr	r3, [r3, #4]
    3e34:	1841      	adds	r1, r0, r1
    3e36:	6021      	str	r1, [r4, #0]
    3e38:	e7ee      	b.n	3e18 <_free_r+0x20>
    3e3a:	0013      	movs	r3, r2
    3e3c:	685a      	ldr	r2, [r3, #4]
    3e3e:	2a00      	cmp	r2, #0
    3e40:	d001      	beq.n	3e46 <_free_r+0x4e>
    3e42:	42a2      	cmp	r2, r4
    3e44:	d9f9      	bls.n	3e3a <_free_r+0x42>
    3e46:	6819      	ldr	r1, [r3, #0]
    3e48:	1858      	adds	r0, r3, r1
    3e4a:	42a0      	cmp	r0, r4
    3e4c:	d10b      	bne.n	3e66 <_free_r+0x6e>
    3e4e:	6820      	ldr	r0, [r4, #0]
    3e50:	1809      	adds	r1, r1, r0
    3e52:	1858      	adds	r0, r3, r1
    3e54:	6019      	str	r1, [r3, #0]
    3e56:	4282      	cmp	r2, r0
    3e58:	d1e0      	bne.n	3e1c <_free_r+0x24>
    3e5a:	6810      	ldr	r0, [r2, #0]
    3e5c:	6852      	ldr	r2, [r2, #4]
    3e5e:	1841      	adds	r1, r0, r1
    3e60:	6019      	str	r1, [r3, #0]
    3e62:	605a      	str	r2, [r3, #4]
    3e64:	e7da      	b.n	3e1c <_free_r+0x24>
    3e66:	42a0      	cmp	r0, r4
    3e68:	d902      	bls.n	3e70 <_free_r+0x78>
    3e6a:	230c      	movs	r3, #12
    3e6c:	602b      	str	r3, [r5, #0]
    3e6e:	e7d5      	b.n	3e1c <_free_r+0x24>
    3e70:	6821      	ldr	r1, [r4, #0]
    3e72:	1860      	adds	r0, r4, r1
    3e74:	4282      	cmp	r2, r0
    3e76:	d103      	bne.n	3e80 <_free_r+0x88>
    3e78:	6810      	ldr	r0, [r2, #0]
    3e7a:	6852      	ldr	r2, [r2, #4]
    3e7c:	1841      	adds	r1, r0, r1
    3e7e:	6021      	str	r1, [r4, #0]
    3e80:	6062      	str	r2, [r4, #4]
    3e82:	605c      	str	r4, [r3, #4]
    3e84:	e7ca      	b.n	3e1c <_free_r+0x24>
    3e86:	46c0      	nop			; (mov r8, r8)
    3e88:	2000017c 	.word	0x2000017c

00003e8c <_malloc_r>:
    3e8c:	2303      	movs	r3, #3
    3e8e:	b570      	push	{r4, r5, r6, lr}
    3e90:	1ccd      	adds	r5, r1, #3
    3e92:	439d      	bics	r5, r3
    3e94:	3508      	adds	r5, #8
    3e96:	0006      	movs	r6, r0
    3e98:	2d0c      	cmp	r5, #12
    3e9a:	d21e      	bcs.n	3eda <_malloc_r+0x4e>
    3e9c:	250c      	movs	r5, #12
    3e9e:	42a9      	cmp	r1, r5
    3ea0:	d81d      	bhi.n	3ede <_malloc_r+0x52>
    3ea2:	0030      	movs	r0, r6
    3ea4:	f000 f88e 	bl	3fc4 <__malloc_lock>
    3ea8:	4a25      	ldr	r2, [pc, #148]	; (3f40 <_malloc_r+0xb4>)
    3eaa:	6814      	ldr	r4, [r2, #0]
    3eac:	0021      	movs	r1, r4
    3eae:	2900      	cmp	r1, #0
    3eb0:	d119      	bne.n	3ee6 <_malloc_r+0x5a>
    3eb2:	4c24      	ldr	r4, [pc, #144]	; (3f44 <_malloc_r+0xb8>)
    3eb4:	6823      	ldr	r3, [r4, #0]
    3eb6:	2b00      	cmp	r3, #0
    3eb8:	d103      	bne.n	3ec2 <_malloc_r+0x36>
    3eba:	0030      	movs	r0, r6
    3ebc:	f000 f844 	bl	3f48 <_sbrk_r>
    3ec0:	6020      	str	r0, [r4, #0]
    3ec2:	0029      	movs	r1, r5
    3ec4:	0030      	movs	r0, r6
    3ec6:	f000 f83f 	bl	3f48 <_sbrk_r>
    3eca:	1c43      	adds	r3, r0, #1
    3ecc:	d12c      	bne.n	3f28 <_malloc_r+0x9c>
    3ece:	230c      	movs	r3, #12
    3ed0:	0030      	movs	r0, r6
    3ed2:	6033      	str	r3, [r6, #0]
    3ed4:	f000 f877 	bl	3fc6 <__malloc_unlock>
    3ed8:	e003      	b.n	3ee2 <_malloc_r+0x56>
    3eda:	2d00      	cmp	r5, #0
    3edc:	dadf      	bge.n	3e9e <_malloc_r+0x12>
    3ede:	230c      	movs	r3, #12
    3ee0:	6033      	str	r3, [r6, #0]
    3ee2:	2000      	movs	r0, #0
    3ee4:	bd70      	pop	{r4, r5, r6, pc}
    3ee6:	680b      	ldr	r3, [r1, #0]
    3ee8:	1b5b      	subs	r3, r3, r5
    3eea:	d41a      	bmi.n	3f22 <_malloc_r+0x96>
    3eec:	2b0b      	cmp	r3, #11
    3eee:	d903      	bls.n	3ef8 <_malloc_r+0x6c>
    3ef0:	600b      	str	r3, [r1, #0]
    3ef2:	18cc      	adds	r4, r1, r3
    3ef4:	6025      	str	r5, [r4, #0]
    3ef6:	e003      	b.n	3f00 <_malloc_r+0x74>
    3ef8:	428c      	cmp	r4, r1
    3efa:	d10e      	bne.n	3f1a <_malloc_r+0x8e>
    3efc:	6863      	ldr	r3, [r4, #4]
    3efe:	6013      	str	r3, [r2, #0]
    3f00:	0030      	movs	r0, r6
    3f02:	f000 f860 	bl	3fc6 <__malloc_unlock>
    3f06:	0020      	movs	r0, r4
    3f08:	2207      	movs	r2, #7
    3f0a:	300b      	adds	r0, #11
    3f0c:	1d23      	adds	r3, r4, #4
    3f0e:	4390      	bics	r0, r2
    3f10:	1ac3      	subs	r3, r0, r3
    3f12:	d0e7      	beq.n	3ee4 <_malloc_r+0x58>
    3f14:	425a      	negs	r2, r3
    3f16:	50e2      	str	r2, [r4, r3]
    3f18:	e7e4      	b.n	3ee4 <_malloc_r+0x58>
    3f1a:	684b      	ldr	r3, [r1, #4]
    3f1c:	6063      	str	r3, [r4, #4]
    3f1e:	000c      	movs	r4, r1
    3f20:	e7ee      	b.n	3f00 <_malloc_r+0x74>
    3f22:	000c      	movs	r4, r1
    3f24:	6849      	ldr	r1, [r1, #4]
    3f26:	e7c2      	b.n	3eae <_malloc_r+0x22>
    3f28:	2303      	movs	r3, #3
    3f2a:	1cc4      	adds	r4, r0, #3
    3f2c:	439c      	bics	r4, r3
    3f2e:	42a0      	cmp	r0, r4
    3f30:	d0e0      	beq.n	3ef4 <_malloc_r+0x68>
    3f32:	1a21      	subs	r1, r4, r0
    3f34:	0030      	movs	r0, r6
    3f36:	f000 f807 	bl	3f48 <_sbrk_r>
    3f3a:	1c43      	adds	r3, r0, #1
    3f3c:	d1da      	bne.n	3ef4 <_malloc_r+0x68>
    3f3e:	e7c6      	b.n	3ece <_malloc_r+0x42>
    3f40:	2000017c 	.word	0x2000017c
    3f44:	20000180 	.word	0x20000180

00003f48 <_sbrk_r>:
    3f48:	2300      	movs	r3, #0
    3f4a:	b570      	push	{r4, r5, r6, lr}
    3f4c:	4c06      	ldr	r4, [pc, #24]	; (3f68 <_sbrk_r+0x20>)
    3f4e:	0005      	movs	r5, r0
    3f50:	0008      	movs	r0, r1
    3f52:	6023      	str	r3, [r4, #0]
    3f54:	f7ff f922 	bl	319c <_sbrk>
    3f58:	1c43      	adds	r3, r0, #1
    3f5a:	d103      	bne.n	3f64 <_sbrk_r+0x1c>
    3f5c:	6823      	ldr	r3, [r4, #0]
    3f5e:	2b00      	cmp	r3, #0
    3f60:	d000      	beq.n	3f64 <_sbrk_r+0x1c>
    3f62:	602b      	str	r3, [r5, #0]
    3f64:	bd70      	pop	{r4, r5, r6, pc}
    3f66:	46c0      	nop			; (mov r8, r8)
    3f68:	200002e8 	.word	0x200002e8

00003f6c <strlen>:
    3f6c:	2300      	movs	r3, #0
    3f6e:	5cc2      	ldrb	r2, [r0, r3]
    3f70:	3301      	adds	r3, #1
    3f72:	2a00      	cmp	r2, #0
    3f74:	d1fb      	bne.n	3f6e <strlen+0x2>
    3f76:	1e58      	subs	r0, r3, #1
    3f78:	4770      	bx	lr
	...

00003f7c <_vsiprintf_r>:
    3f7c:	b530      	push	{r4, r5, lr}
    3f7e:	b09b      	sub	sp, #108	; 0x6c
    3f80:	9100      	str	r1, [sp, #0]
    3f82:	9104      	str	r1, [sp, #16]
    3f84:	4908      	ldr	r1, [pc, #32]	; (3fa8 <_vsiprintf_r+0x2c>)
    3f86:	466d      	mov	r5, sp
    3f88:	9102      	str	r1, [sp, #8]
    3f8a:	9105      	str	r1, [sp, #20]
    3f8c:	2101      	movs	r1, #1
    3f8e:	2482      	movs	r4, #130	; 0x82
    3f90:	4249      	negs	r1, r1
    3f92:	81e9      	strh	r1, [r5, #14]
    3f94:	00a4      	lsls	r4, r4, #2
    3f96:	4669      	mov	r1, sp
    3f98:	81ac      	strh	r4, [r5, #12]
    3f9a:	f000 f877 	bl	408c <_svfiprintf_r>
    3f9e:	2300      	movs	r3, #0
    3fa0:	9a00      	ldr	r2, [sp, #0]
    3fa2:	7013      	strb	r3, [r2, #0]
    3fa4:	b01b      	add	sp, #108	; 0x6c
    3fa6:	bd30      	pop	{r4, r5, pc}
    3fa8:	7fffffff 	.word	0x7fffffff

00003fac <vsiprintf>:
    3fac:	b510      	push	{r4, lr}
    3fae:	0013      	movs	r3, r2
    3fb0:	000a      	movs	r2, r1
    3fb2:	0001      	movs	r1, r0
    3fb4:	4802      	ldr	r0, [pc, #8]	; (3fc0 <vsiprintf+0x14>)
    3fb6:	6800      	ldr	r0, [r0, #0]
    3fb8:	f7ff ffe0 	bl	3f7c <_vsiprintf_r>
    3fbc:	bd10      	pop	{r4, pc}
    3fbe:	46c0      	nop			; (mov r8, r8)
    3fc0:	20000010 	.word	0x20000010

00003fc4 <__malloc_lock>:
    3fc4:	4770      	bx	lr

00003fc6 <__malloc_unlock>:
    3fc6:	4770      	bx	lr

00003fc8 <__ssputs_r>:
    3fc8:	b5f0      	push	{r4, r5, r6, r7, lr}
    3fca:	688e      	ldr	r6, [r1, #8]
    3fcc:	b085      	sub	sp, #20
    3fce:	0007      	movs	r7, r0
    3fd0:	000c      	movs	r4, r1
    3fd2:	9203      	str	r2, [sp, #12]
    3fd4:	9301      	str	r3, [sp, #4]
    3fd6:	429e      	cmp	r6, r3
    3fd8:	d839      	bhi.n	404e <__ssputs_r+0x86>
    3fda:	2390      	movs	r3, #144	; 0x90
    3fdc:	898a      	ldrh	r2, [r1, #12]
    3fde:	00db      	lsls	r3, r3, #3
    3fe0:	421a      	tst	r2, r3
    3fe2:	d034      	beq.n	404e <__ssputs_r+0x86>
    3fe4:	2503      	movs	r5, #3
    3fe6:	6909      	ldr	r1, [r1, #16]
    3fe8:	6823      	ldr	r3, [r4, #0]
    3fea:	1a5b      	subs	r3, r3, r1
    3fec:	9302      	str	r3, [sp, #8]
    3fee:	6963      	ldr	r3, [r4, #20]
    3ff0:	9802      	ldr	r0, [sp, #8]
    3ff2:	435d      	muls	r5, r3
    3ff4:	0feb      	lsrs	r3, r5, #31
    3ff6:	195d      	adds	r5, r3, r5
    3ff8:	9b01      	ldr	r3, [sp, #4]
    3ffa:	106d      	asrs	r5, r5, #1
    3ffc:	3301      	adds	r3, #1
    3ffe:	181b      	adds	r3, r3, r0
    4000:	42ab      	cmp	r3, r5
    4002:	d900      	bls.n	4006 <__ssputs_r+0x3e>
    4004:	001d      	movs	r5, r3
    4006:	0553      	lsls	r3, r2, #21
    4008:	d532      	bpl.n	4070 <__ssputs_r+0xa8>
    400a:	0029      	movs	r1, r5
    400c:	0038      	movs	r0, r7
    400e:	f7ff ff3d 	bl	3e8c <_malloc_r>
    4012:	1e06      	subs	r6, r0, #0
    4014:	d109      	bne.n	402a <__ssputs_r+0x62>
    4016:	230c      	movs	r3, #12
    4018:	603b      	str	r3, [r7, #0]
    401a:	2340      	movs	r3, #64	; 0x40
    401c:	2001      	movs	r0, #1
    401e:	89a2      	ldrh	r2, [r4, #12]
    4020:	4240      	negs	r0, r0
    4022:	4313      	orrs	r3, r2
    4024:	81a3      	strh	r3, [r4, #12]
    4026:	b005      	add	sp, #20
    4028:	bdf0      	pop	{r4, r5, r6, r7, pc}
    402a:	9a02      	ldr	r2, [sp, #8]
    402c:	6921      	ldr	r1, [r4, #16]
    402e:	f7ff fed1 	bl	3dd4 <memcpy>
    4032:	89a3      	ldrh	r3, [r4, #12]
    4034:	4a14      	ldr	r2, [pc, #80]	; (4088 <__ssputs_r+0xc0>)
    4036:	401a      	ands	r2, r3
    4038:	2380      	movs	r3, #128	; 0x80
    403a:	4313      	orrs	r3, r2
    403c:	81a3      	strh	r3, [r4, #12]
    403e:	9b02      	ldr	r3, [sp, #8]
    4040:	6126      	str	r6, [r4, #16]
    4042:	18f6      	adds	r6, r6, r3
    4044:	6026      	str	r6, [r4, #0]
    4046:	6165      	str	r5, [r4, #20]
    4048:	9e01      	ldr	r6, [sp, #4]
    404a:	1aed      	subs	r5, r5, r3
    404c:	60a5      	str	r5, [r4, #8]
    404e:	9b01      	ldr	r3, [sp, #4]
    4050:	42b3      	cmp	r3, r6
    4052:	d200      	bcs.n	4056 <__ssputs_r+0x8e>
    4054:	001e      	movs	r6, r3
    4056:	0032      	movs	r2, r6
    4058:	9903      	ldr	r1, [sp, #12]
    405a:	6820      	ldr	r0, [r4, #0]
    405c:	f000 faad 	bl	45ba <memmove>
    4060:	68a3      	ldr	r3, [r4, #8]
    4062:	2000      	movs	r0, #0
    4064:	1b9b      	subs	r3, r3, r6
    4066:	60a3      	str	r3, [r4, #8]
    4068:	6823      	ldr	r3, [r4, #0]
    406a:	199e      	adds	r6, r3, r6
    406c:	6026      	str	r6, [r4, #0]
    406e:	e7da      	b.n	4026 <__ssputs_r+0x5e>
    4070:	002a      	movs	r2, r5
    4072:	0038      	movs	r0, r7
    4074:	f000 fab3 	bl	45de <_realloc_r>
    4078:	1e06      	subs	r6, r0, #0
    407a:	d1e0      	bne.n	403e <__ssputs_r+0x76>
    407c:	6921      	ldr	r1, [r4, #16]
    407e:	0038      	movs	r0, r7
    4080:	f7ff feba 	bl	3df8 <_free_r>
    4084:	e7c7      	b.n	4016 <__ssputs_r+0x4e>
    4086:	46c0      	nop			; (mov r8, r8)
    4088:	fffffb7f 	.word	0xfffffb7f

0000408c <_svfiprintf_r>:
    408c:	b5f0      	push	{r4, r5, r6, r7, lr}
    408e:	b09f      	sub	sp, #124	; 0x7c
    4090:	9002      	str	r0, [sp, #8]
    4092:	9305      	str	r3, [sp, #20]
    4094:	898b      	ldrh	r3, [r1, #12]
    4096:	000f      	movs	r7, r1
    4098:	0016      	movs	r6, r2
    409a:	061b      	lsls	r3, r3, #24
    409c:	d511      	bpl.n	40c2 <_svfiprintf_r+0x36>
    409e:	690b      	ldr	r3, [r1, #16]
    40a0:	2b00      	cmp	r3, #0
    40a2:	d10e      	bne.n	40c2 <_svfiprintf_r+0x36>
    40a4:	2140      	movs	r1, #64	; 0x40
    40a6:	f7ff fef1 	bl	3e8c <_malloc_r>
    40aa:	6038      	str	r0, [r7, #0]
    40ac:	6138      	str	r0, [r7, #16]
    40ae:	2800      	cmp	r0, #0
    40b0:	d105      	bne.n	40be <_svfiprintf_r+0x32>
    40b2:	230c      	movs	r3, #12
    40b4:	9a02      	ldr	r2, [sp, #8]
    40b6:	3801      	subs	r0, #1
    40b8:	6013      	str	r3, [r2, #0]
    40ba:	b01f      	add	sp, #124	; 0x7c
    40bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    40be:	2340      	movs	r3, #64	; 0x40
    40c0:	617b      	str	r3, [r7, #20]
    40c2:	2300      	movs	r3, #0
    40c4:	ad06      	add	r5, sp, #24
    40c6:	616b      	str	r3, [r5, #20]
    40c8:	3320      	adds	r3, #32
    40ca:	766b      	strb	r3, [r5, #25]
    40cc:	3310      	adds	r3, #16
    40ce:	76ab      	strb	r3, [r5, #26]
    40d0:	0034      	movs	r4, r6
    40d2:	7823      	ldrb	r3, [r4, #0]
    40d4:	2b00      	cmp	r3, #0
    40d6:	d147      	bne.n	4168 <_svfiprintf_r+0xdc>
    40d8:	1ba3      	subs	r3, r4, r6
    40da:	9304      	str	r3, [sp, #16]
    40dc:	d00d      	beq.n	40fa <_svfiprintf_r+0x6e>
    40de:	1ba3      	subs	r3, r4, r6
    40e0:	0032      	movs	r2, r6
    40e2:	0039      	movs	r1, r7
    40e4:	9802      	ldr	r0, [sp, #8]
    40e6:	f7ff ff6f 	bl	3fc8 <__ssputs_r>
    40ea:	1c43      	adds	r3, r0, #1
    40ec:	d100      	bne.n	40f0 <_svfiprintf_r+0x64>
    40ee:	e0b5      	b.n	425c <_svfiprintf_r+0x1d0>
    40f0:	696a      	ldr	r2, [r5, #20]
    40f2:	9b04      	ldr	r3, [sp, #16]
    40f4:	4694      	mov	ip, r2
    40f6:	4463      	add	r3, ip
    40f8:	616b      	str	r3, [r5, #20]
    40fa:	7823      	ldrb	r3, [r4, #0]
    40fc:	2b00      	cmp	r3, #0
    40fe:	d100      	bne.n	4102 <_svfiprintf_r+0x76>
    4100:	e0ac      	b.n	425c <_svfiprintf_r+0x1d0>
    4102:	2201      	movs	r2, #1
    4104:	2300      	movs	r3, #0
    4106:	4252      	negs	r2, r2
    4108:	606a      	str	r2, [r5, #4]
    410a:	a902      	add	r1, sp, #8
    410c:	3254      	adds	r2, #84	; 0x54
    410e:	1852      	adds	r2, r2, r1
    4110:	3401      	adds	r4, #1
    4112:	602b      	str	r3, [r5, #0]
    4114:	60eb      	str	r3, [r5, #12]
    4116:	60ab      	str	r3, [r5, #8]
    4118:	7013      	strb	r3, [r2, #0]
    411a:	65ab      	str	r3, [r5, #88]	; 0x58
    411c:	4e58      	ldr	r6, [pc, #352]	; (4280 <_svfiprintf_r+0x1f4>)
    411e:	2205      	movs	r2, #5
    4120:	7821      	ldrb	r1, [r4, #0]
    4122:	0030      	movs	r0, r6
    4124:	f000 fa3e 	bl	45a4 <memchr>
    4128:	1c62      	adds	r2, r4, #1
    412a:	2800      	cmp	r0, #0
    412c:	d120      	bne.n	4170 <_svfiprintf_r+0xe4>
    412e:	6829      	ldr	r1, [r5, #0]
    4130:	06cb      	lsls	r3, r1, #27
    4132:	d504      	bpl.n	413e <_svfiprintf_r+0xb2>
    4134:	2353      	movs	r3, #83	; 0x53
    4136:	ae02      	add	r6, sp, #8
    4138:	3020      	adds	r0, #32
    413a:	199b      	adds	r3, r3, r6
    413c:	7018      	strb	r0, [r3, #0]
    413e:	070b      	lsls	r3, r1, #28
    4140:	d504      	bpl.n	414c <_svfiprintf_r+0xc0>
    4142:	2353      	movs	r3, #83	; 0x53
    4144:	202b      	movs	r0, #43	; 0x2b
    4146:	ae02      	add	r6, sp, #8
    4148:	199b      	adds	r3, r3, r6
    414a:	7018      	strb	r0, [r3, #0]
    414c:	7823      	ldrb	r3, [r4, #0]
    414e:	2b2a      	cmp	r3, #42	; 0x2a
    4150:	d016      	beq.n	4180 <_svfiprintf_r+0xf4>
    4152:	2000      	movs	r0, #0
    4154:	210a      	movs	r1, #10
    4156:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4158:	7822      	ldrb	r2, [r4, #0]
    415a:	3a30      	subs	r2, #48	; 0x30
    415c:	2a09      	cmp	r2, #9
    415e:	d955      	bls.n	420c <_svfiprintf_r+0x180>
    4160:	2800      	cmp	r0, #0
    4162:	d015      	beq.n	4190 <_svfiprintf_r+0x104>
    4164:	9309      	str	r3, [sp, #36]	; 0x24
    4166:	e013      	b.n	4190 <_svfiprintf_r+0x104>
    4168:	2b25      	cmp	r3, #37	; 0x25
    416a:	d0b5      	beq.n	40d8 <_svfiprintf_r+0x4c>
    416c:	3401      	adds	r4, #1
    416e:	e7b0      	b.n	40d2 <_svfiprintf_r+0x46>
    4170:	2301      	movs	r3, #1
    4172:	1b80      	subs	r0, r0, r6
    4174:	4083      	lsls	r3, r0
    4176:	6829      	ldr	r1, [r5, #0]
    4178:	0014      	movs	r4, r2
    417a:	430b      	orrs	r3, r1
    417c:	602b      	str	r3, [r5, #0]
    417e:	e7cd      	b.n	411c <_svfiprintf_r+0x90>
    4180:	9b05      	ldr	r3, [sp, #20]
    4182:	1d18      	adds	r0, r3, #4
    4184:	681b      	ldr	r3, [r3, #0]
    4186:	9005      	str	r0, [sp, #20]
    4188:	2b00      	cmp	r3, #0
    418a:	db39      	blt.n	4200 <_svfiprintf_r+0x174>
    418c:	9309      	str	r3, [sp, #36]	; 0x24
    418e:	0014      	movs	r4, r2
    4190:	7823      	ldrb	r3, [r4, #0]
    4192:	2b2e      	cmp	r3, #46	; 0x2e
    4194:	d10b      	bne.n	41ae <_svfiprintf_r+0x122>
    4196:	7863      	ldrb	r3, [r4, #1]
    4198:	1c62      	adds	r2, r4, #1
    419a:	2b2a      	cmp	r3, #42	; 0x2a
    419c:	d13e      	bne.n	421c <_svfiprintf_r+0x190>
    419e:	9b05      	ldr	r3, [sp, #20]
    41a0:	3402      	adds	r4, #2
    41a2:	1d1a      	adds	r2, r3, #4
    41a4:	681b      	ldr	r3, [r3, #0]
    41a6:	9205      	str	r2, [sp, #20]
    41a8:	2b00      	cmp	r3, #0
    41aa:	db34      	blt.n	4216 <_svfiprintf_r+0x18a>
    41ac:	9307      	str	r3, [sp, #28]
    41ae:	4e35      	ldr	r6, [pc, #212]	; (4284 <_svfiprintf_r+0x1f8>)
    41b0:	7821      	ldrb	r1, [r4, #0]
    41b2:	2203      	movs	r2, #3
    41b4:	0030      	movs	r0, r6
    41b6:	f000 f9f5 	bl	45a4 <memchr>
    41ba:	2800      	cmp	r0, #0
    41bc:	d006      	beq.n	41cc <_svfiprintf_r+0x140>
    41be:	2340      	movs	r3, #64	; 0x40
    41c0:	1b80      	subs	r0, r0, r6
    41c2:	4083      	lsls	r3, r0
    41c4:	682a      	ldr	r2, [r5, #0]
    41c6:	3401      	adds	r4, #1
    41c8:	4313      	orrs	r3, r2
    41ca:	602b      	str	r3, [r5, #0]
    41cc:	7821      	ldrb	r1, [r4, #0]
    41ce:	2206      	movs	r2, #6
    41d0:	482d      	ldr	r0, [pc, #180]	; (4288 <_svfiprintf_r+0x1fc>)
    41d2:	1c66      	adds	r6, r4, #1
    41d4:	7629      	strb	r1, [r5, #24]
    41d6:	f000 f9e5 	bl	45a4 <memchr>
    41da:	2800      	cmp	r0, #0
    41dc:	d046      	beq.n	426c <_svfiprintf_r+0x1e0>
    41de:	4b2b      	ldr	r3, [pc, #172]	; (428c <_svfiprintf_r+0x200>)
    41e0:	2b00      	cmp	r3, #0
    41e2:	d12f      	bne.n	4244 <_svfiprintf_r+0x1b8>
    41e4:	6829      	ldr	r1, [r5, #0]
    41e6:	9b05      	ldr	r3, [sp, #20]
    41e8:	2207      	movs	r2, #7
    41ea:	05c9      	lsls	r1, r1, #23
    41ec:	d528      	bpl.n	4240 <_svfiprintf_r+0x1b4>
    41ee:	189b      	adds	r3, r3, r2
    41f0:	4393      	bics	r3, r2
    41f2:	3308      	adds	r3, #8
    41f4:	9305      	str	r3, [sp, #20]
    41f6:	696b      	ldr	r3, [r5, #20]
    41f8:	9a03      	ldr	r2, [sp, #12]
    41fa:	189b      	adds	r3, r3, r2
    41fc:	616b      	str	r3, [r5, #20]
    41fe:	e767      	b.n	40d0 <_svfiprintf_r+0x44>
    4200:	425b      	negs	r3, r3
    4202:	60eb      	str	r3, [r5, #12]
    4204:	2302      	movs	r3, #2
    4206:	430b      	orrs	r3, r1
    4208:	602b      	str	r3, [r5, #0]
    420a:	e7c0      	b.n	418e <_svfiprintf_r+0x102>
    420c:	434b      	muls	r3, r1
    420e:	3401      	adds	r4, #1
    4210:	189b      	adds	r3, r3, r2
    4212:	2001      	movs	r0, #1
    4214:	e7a0      	b.n	4158 <_svfiprintf_r+0xcc>
    4216:	2301      	movs	r3, #1
    4218:	425b      	negs	r3, r3
    421a:	e7c7      	b.n	41ac <_svfiprintf_r+0x120>
    421c:	2300      	movs	r3, #0
    421e:	0014      	movs	r4, r2
    4220:	200a      	movs	r0, #10
    4222:	001a      	movs	r2, r3
    4224:	606b      	str	r3, [r5, #4]
    4226:	7821      	ldrb	r1, [r4, #0]
    4228:	3930      	subs	r1, #48	; 0x30
    422a:	2909      	cmp	r1, #9
    422c:	d903      	bls.n	4236 <_svfiprintf_r+0x1aa>
    422e:	2b00      	cmp	r3, #0
    4230:	d0bd      	beq.n	41ae <_svfiprintf_r+0x122>
    4232:	9207      	str	r2, [sp, #28]
    4234:	e7bb      	b.n	41ae <_svfiprintf_r+0x122>
    4236:	4342      	muls	r2, r0
    4238:	3401      	adds	r4, #1
    423a:	1852      	adds	r2, r2, r1
    423c:	2301      	movs	r3, #1
    423e:	e7f2      	b.n	4226 <_svfiprintf_r+0x19a>
    4240:	3307      	adds	r3, #7
    4242:	e7d5      	b.n	41f0 <_svfiprintf_r+0x164>
    4244:	ab05      	add	r3, sp, #20
    4246:	9300      	str	r3, [sp, #0]
    4248:	003a      	movs	r2, r7
    424a:	4b11      	ldr	r3, [pc, #68]	; (4290 <_svfiprintf_r+0x204>)
    424c:	0029      	movs	r1, r5
    424e:	9802      	ldr	r0, [sp, #8]
    4250:	e000      	b.n	4254 <_svfiprintf_r+0x1c8>
    4252:	bf00      	nop
    4254:	9003      	str	r0, [sp, #12]
    4256:	9b03      	ldr	r3, [sp, #12]
    4258:	3301      	adds	r3, #1
    425a:	d1cc      	bne.n	41f6 <_svfiprintf_r+0x16a>
    425c:	89bb      	ldrh	r3, [r7, #12]
    425e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    4260:	065b      	lsls	r3, r3, #25
    4262:	d400      	bmi.n	4266 <_svfiprintf_r+0x1da>
    4264:	e729      	b.n	40ba <_svfiprintf_r+0x2e>
    4266:	2001      	movs	r0, #1
    4268:	4240      	negs	r0, r0
    426a:	e726      	b.n	40ba <_svfiprintf_r+0x2e>
    426c:	ab05      	add	r3, sp, #20
    426e:	9300      	str	r3, [sp, #0]
    4270:	003a      	movs	r2, r7
    4272:	4b07      	ldr	r3, [pc, #28]	; (4290 <_svfiprintf_r+0x204>)
    4274:	0029      	movs	r1, r5
    4276:	9802      	ldr	r0, [sp, #8]
    4278:	f000 f87a 	bl	4370 <_printf_i>
    427c:	e7ea      	b.n	4254 <_svfiprintf_r+0x1c8>
    427e:	46c0      	nop			; (mov r8, r8)
    4280:	000046f9 	.word	0x000046f9
    4284:	000046ff 	.word	0x000046ff
    4288:	00004703 	.word	0x00004703
    428c:	00000000 	.word	0x00000000
    4290:	00003fc9 	.word	0x00003fc9

00004294 <_printf_common>:
    4294:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4296:	0015      	movs	r5, r2
    4298:	9301      	str	r3, [sp, #4]
    429a:	688a      	ldr	r2, [r1, #8]
    429c:	690b      	ldr	r3, [r1, #16]
    429e:	9000      	str	r0, [sp, #0]
    42a0:	000c      	movs	r4, r1
    42a2:	4293      	cmp	r3, r2
    42a4:	da00      	bge.n	42a8 <_printf_common+0x14>
    42a6:	0013      	movs	r3, r2
    42a8:	0022      	movs	r2, r4
    42aa:	602b      	str	r3, [r5, #0]
    42ac:	3243      	adds	r2, #67	; 0x43
    42ae:	7812      	ldrb	r2, [r2, #0]
    42b0:	2a00      	cmp	r2, #0
    42b2:	d001      	beq.n	42b8 <_printf_common+0x24>
    42b4:	3301      	adds	r3, #1
    42b6:	602b      	str	r3, [r5, #0]
    42b8:	6823      	ldr	r3, [r4, #0]
    42ba:	069b      	lsls	r3, r3, #26
    42bc:	d502      	bpl.n	42c4 <_printf_common+0x30>
    42be:	682b      	ldr	r3, [r5, #0]
    42c0:	3302      	adds	r3, #2
    42c2:	602b      	str	r3, [r5, #0]
    42c4:	2706      	movs	r7, #6
    42c6:	6823      	ldr	r3, [r4, #0]
    42c8:	401f      	ands	r7, r3
    42ca:	d027      	beq.n	431c <_printf_common+0x88>
    42cc:	0023      	movs	r3, r4
    42ce:	3343      	adds	r3, #67	; 0x43
    42d0:	781b      	ldrb	r3, [r3, #0]
    42d2:	1e5a      	subs	r2, r3, #1
    42d4:	4193      	sbcs	r3, r2
    42d6:	6822      	ldr	r2, [r4, #0]
    42d8:	0692      	lsls	r2, r2, #26
    42da:	d430      	bmi.n	433e <_printf_common+0xaa>
    42dc:	0022      	movs	r2, r4
    42de:	9901      	ldr	r1, [sp, #4]
    42e0:	3243      	adds	r2, #67	; 0x43
    42e2:	9800      	ldr	r0, [sp, #0]
    42e4:	9e08      	ldr	r6, [sp, #32]
    42e6:	47b0      	blx	r6
    42e8:	1c43      	adds	r3, r0, #1
    42ea:	d025      	beq.n	4338 <_printf_common+0xa4>
    42ec:	2306      	movs	r3, #6
    42ee:	6820      	ldr	r0, [r4, #0]
    42f0:	682a      	ldr	r2, [r5, #0]
    42f2:	68e1      	ldr	r1, [r4, #12]
    42f4:	4003      	ands	r3, r0
    42f6:	2500      	movs	r5, #0
    42f8:	2b04      	cmp	r3, #4
    42fa:	d103      	bne.n	4304 <_printf_common+0x70>
    42fc:	1a8d      	subs	r5, r1, r2
    42fe:	43eb      	mvns	r3, r5
    4300:	17db      	asrs	r3, r3, #31
    4302:	401d      	ands	r5, r3
    4304:	68a3      	ldr	r3, [r4, #8]
    4306:	6922      	ldr	r2, [r4, #16]
    4308:	4293      	cmp	r3, r2
    430a:	dd01      	ble.n	4310 <_printf_common+0x7c>
    430c:	1a9b      	subs	r3, r3, r2
    430e:	18ed      	adds	r5, r5, r3
    4310:	2700      	movs	r7, #0
    4312:	42bd      	cmp	r5, r7
    4314:	d120      	bne.n	4358 <_printf_common+0xc4>
    4316:	2000      	movs	r0, #0
    4318:	e010      	b.n	433c <_printf_common+0xa8>
    431a:	3701      	adds	r7, #1
    431c:	68e3      	ldr	r3, [r4, #12]
    431e:	682a      	ldr	r2, [r5, #0]
    4320:	1a9b      	subs	r3, r3, r2
    4322:	429f      	cmp	r7, r3
    4324:	dad2      	bge.n	42cc <_printf_common+0x38>
    4326:	0022      	movs	r2, r4
    4328:	2301      	movs	r3, #1
    432a:	3219      	adds	r2, #25
    432c:	9901      	ldr	r1, [sp, #4]
    432e:	9800      	ldr	r0, [sp, #0]
    4330:	9e08      	ldr	r6, [sp, #32]
    4332:	47b0      	blx	r6
    4334:	1c43      	adds	r3, r0, #1
    4336:	d1f0      	bne.n	431a <_printf_common+0x86>
    4338:	2001      	movs	r0, #1
    433a:	4240      	negs	r0, r0
    433c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    433e:	2030      	movs	r0, #48	; 0x30
    4340:	18e1      	adds	r1, r4, r3
    4342:	3143      	adds	r1, #67	; 0x43
    4344:	7008      	strb	r0, [r1, #0]
    4346:	0021      	movs	r1, r4
    4348:	1c5a      	adds	r2, r3, #1
    434a:	3145      	adds	r1, #69	; 0x45
    434c:	7809      	ldrb	r1, [r1, #0]
    434e:	18a2      	adds	r2, r4, r2
    4350:	3243      	adds	r2, #67	; 0x43
    4352:	3302      	adds	r3, #2
    4354:	7011      	strb	r1, [r2, #0]
    4356:	e7c1      	b.n	42dc <_printf_common+0x48>
    4358:	0022      	movs	r2, r4
    435a:	2301      	movs	r3, #1
    435c:	321a      	adds	r2, #26
    435e:	9901      	ldr	r1, [sp, #4]
    4360:	9800      	ldr	r0, [sp, #0]
    4362:	9e08      	ldr	r6, [sp, #32]
    4364:	47b0      	blx	r6
    4366:	1c43      	adds	r3, r0, #1
    4368:	d0e6      	beq.n	4338 <_printf_common+0xa4>
    436a:	3701      	adds	r7, #1
    436c:	e7d1      	b.n	4312 <_printf_common+0x7e>
	...

00004370 <_printf_i>:
    4370:	b5f0      	push	{r4, r5, r6, r7, lr}
    4372:	b08b      	sub	sp, #44	; 0x2c
    4374:	9206      	str	r2, [sp, #24]
    4376:	000a      	movs	r2, r1
    4378:	3243      	adds	r2, #67	; 0x43
    437a:	9307      	str	r3, [sp, #28]
    437c:	9005      	str	r0, [sp, #20]
    437e:	9204      	str	r2, [sp, #16]
    4380:	7e0a      	ldrb	r2, [r1, #24]
    4382:	000c      	movs	r4, r1
    4384:	9b10      	ldr	r3, [sp, #64]	; 0x40
    4386:	2a6e      	cmp	r2, #110	; 0x6e
    4388:	d100      	bne.n	438c <_printf_i+0x1c>
    438a:	e08f      	b.n	44ac <_printf_i+0x13c>
    438c:	d817      	bhi.n	43be <_printf_i+0x4e>
    438e:	2a63      	cmp	r2, #99	; 0x63
    4390:	d02c      	beq.n	43ec <_printf_i+0x7c>
    4392:	d808      	bhi.n	43a6 <_printf_i+0x36>
    4394:	2a00      	cmp	r2, #0
    4396:	d100      	bne.n	439a <_printf_i+0x2a>
    4398:	e099      	b.n	44ce <_printf_i+0x15e>
    439a:	2a58      	cmp	r2, #88	; 0x58
    439c:	d054      	beq.n	4448 <_printf_i+0xd8>
    439e:	0026      	movs	r6, r4
    43a0:	3642      	adds	r6, #66	; 0x42
    43a2:	7032      	strb	r2, [r6, #0]
    43a4:	e029      	b.n	43fa <_printf_i+0x8a>
    43a6:	2a64      	cmp	r2, #100	; 0x64
    43a8:	d001      	beq.n	43ae <_printf_i+0x3e>
    43aa:	2a69      	cmp	r2, #105	; 0x69
    43ac:	d1f7      	bne.n	439e <_printf_i+0x2e>
    43ae:	6821      	ldr	r1, [r4, #0]
    43b0:	681a      	ldr	r2, [r3, #0]
    43b2:	0608      	lsls	r0, r1, #24
    43b4:	d523      	bpl.n	43fe <_printf_i+0x8e>
    43b6:	1d11      	adds	r1, r2, #4
    43b8:	6019      	str	r1, [r3, #0]
    43ba:	6815      	ldr	r5, [r2, #0]
    43bc:	e025      	b.n	440a <_printf_i+0x9a>
    43be:	2a73      	cmp	r2, #115	; 0x73
    43c0:	d100      	bne.n	43c4 <_printf_i+0x54>
    43c2:	e088      	b.n	44d6 <_printf_i+0x166>
    43c4:	d808      	bhi.n	43d8 <_printf_i+0x68>
    43c6:	2a6f      	cmp	r2, #111	; 0x6f
    43c8:	d029      	beq.n	441e <_printf_i+0xae>
    43ca:	2a70      	cmp	r2, #112	; 0x70
    43cc:	d1e7      	bne.n	439e <_printf_i+0x2e>
    43ce:	2220      	movs	r2, #32
    43d0:	6809      	ldr	r1, [r1, #0]
    43d2:	430a      	orrs	r2, r1
    43d4:	6022      	str	r2, [r4, #0]
    43d6:	e003      	b.n	43e0 <_printf_i+0x70>
    43d8:	2a75      	cmp	r2, #117	; 0x75
    43da:	d020      	beq.n	441e <_printf_i+0xae>
    43dc:	2a78      	cmp	r2, #120	; 0x78
    43de:	d1de      	bne.n	439e <_printf_i+0x2e>
    43e0:	0022      	movs	r2, r4
    43e2:	2178      	movs	r1, #120	; 0x78
    43e4:	3245      	adds	r2, #69	; 0x45
    43e6:	7011      	strb	r1, [r2, #0]
    43e8:	4a6c      	ldr	r2, [pc, #432]	; (459c <_printf_i+0x22c>)
    43ea:	e030      	b.n	444e <_printf_i+0xde>
    43ec:	000e      	movs	r6, r1
    43ee:	681a      	ldr	r2, [r3, #0]
    43f0:	3642      	adds	r6, #66	; 0x42
    43f2:	1d11      	adds	r1, r2, #4
    43f4:	6019      	str	r1, [r3, #0]
    43f6:	6813      	ldr	r3, [r2, #0]
    43f8:	7033      	strb	r3, [r6, #0]
    43fa:	2301      	movs	r3, #1
    43fc:	e079      	b.n	44f2 <_printf_i+0x182>
    43fe:	0649      	lsls	r1, r1, #25
    4400:	d5d9      	bpl.n	43b6 <_printf_i+0x46>
    4402:	1d11      	adds	r1, r2, #4
    4404:	6019      	str	r1, [r3, #0]
    4406:	2300      	movs	r3, #0
    4408:	5ed5      	ldrsh	r5, [r2, r3]
    440a:	2d00      	cmp	r5, #0
    440c:	da03      	bge.n	4416 <_printf_i+0xa6>
    440e:	232d      	movs	r3, #45	; 0x2d
    4410:	9a04      	ldr	r2, [sp, #16]
    4412:	426d      	negs	r5, r5
    4414:	7013      	strb	r3, [r2, #0]
    4416:	4b62      	ldr	r3, [pc, #392]	; (45a0 <_printf_i+0x230>)
    4418:	270a      	movs	r7, #10
    441a:	9303      	str	r3, [sp, #12]
    441c:	e02f      	b.n	447e <_printf_i+0x10e>
    441e:	6820      	ldr	r0, [r4, #0]
    4420:	6819      	ldr	r1, [r3, #0]
    4422:	0605      	lsls	r5, r0, #24
    4424:	d503      	bpl.n	442e <_printf_i+0xbe>
    4426:	1d08      	adds	r0, r1, #4
    4428:	6018      	str	r0, [r3, #0]
    442a:	680d      	ldr	r5, [r1, #0]
    442c:	e005      	b.n	443a <_printf_i+0xca>
    442e:	0640      	lsls	r0, r0, #25
    4430:	d5f9      	bpl.n	4426 <_printf_i+0xb6>
    4432:	680d      	ldr	r5, [r1, #0]
    4434:	1d08      	adds	r0, r1, #4
    4436:	6018      	str	r0, [r3, #0]
    4438:	b2ad      	uxth	r5, r5
    443a:	4b59      	ldr	r3, [pc, #356]	; (45a0 <_printf_i+0x230>)
    443c:	2708      	movs	r7, #8
    443e:	9303      	str	r3, [sp, #12]
    4440:	2a6f      	cmp	r2, #111	; 0x6f
    4442:	d018      	beq.n	4476 <_printf_i+0x106>
    4444:	270a      	movs	r7, #10
    4446:	e016      	b.n	4476 <_printf_i+0x106>
    4448:	3145      	adds	r1, #69	; 0x45
    444a:	700a      	strb	r2, [r1, #0]
    444c:	4a54      	ldr	r2, [pc, #336]	; (45a0 <_printf_i+0x230>)
    444e:	9203      	str	r2, [sp, #12]
    4450:	681a      	ldr	r2, [r3, #0]
    4452:	6821      	ldr	r1, [r4, #0]
    4454:	1d10      	adds	r0, r2, #4
    4456:	6018      	str	r0, [r3, #0]
    4458:	6815      	ldr	r5, [r2, #0]
    445a:	0608      	lsls	r0, r1, #24
    445c:	d522      	bpl.n	44a4 <_printf_i+0x134>
    445e:	07cb      	lsls	r3, r1, #31
    4460:	d502      	bpl.n	4468 <_printf_i+0xf8>
    4462:	2320      	movs	r3, #32
    4464:	4319      	orrs	r1, r3
    4466:	6021      	str	r1, [r4, #0]
    4468:	2710      	movs	r7, #16
    446a:	2d00      	cmp	r5, #0
    446c:	d103      	bne.n	4476 <_printf_i+0x106>
    446e:	2320      	movs	r3, #32
    4470:	6822      	ldr	r2, [r4, #0]
    4472:	439a      	bics	r2, r3
    4474:	6022      	str	r2, [r4, #0]
    4476:	0023      	movs	r3, r4
    4478:	2200      	movs	r2, #0
    447a:	3343      	adds	r3, #67	; 0x43
    447c:	701a      	strb	r2, [r3, #0]
    447e:	6863      	ldr	r3, [r4, #4]
    4480:	60a3      	str	r3, [r4, #8]
    4482:	2b00      	cmp	r3, #0
    4484:	db5c      	blt.n	4540 <_printf_i+0x1d0>
    4486:	2204      	movs	r2, #4
    4488:	6821      	ldr	r1, [r4, #0]
    448a:	4391      	bics	r1, r2
    448c:	6021      	str	r1, [r4, #0]
    448e:	2d00      	cmp	r5, #0
    4490:	d158      	bne.n	4544 <_printf_i+0x1d4>
    4492:	9e04      	ldr	r6, [sp, #16]
    4494:	2b00      	cmp	r3, #0
    4496:	d064      	beq.n	4562 <_printf_i+0x1f2>
    4498:	0026      	movs	r6, r4
    449a:	9b03      	ldr	r3, [sp, #12]
    449c:	3642      	adds	r6, #66	; 0x42
    449e:	781b      	ldrb	r3, [r3, #0]
    44a0:	7033      	strb	r3, [r6, #0]
    44a2:	e05e      	b.n	4562 <_printf_i+0x1f2>
    44a4:	0648      	lsls	r0, r1, #25
    44a6:	d5da      	bpl.n	445e <_printf_i+0xee>
    44a8:	b2ad      	uxth	r5, r5
    44aa:	e7d8      	b.n	445e <_printf_i+0xee>
    44ac:	6809      	ldr	r1, [r1, #0]
    44ae:	681a      	ldr	r2, [r3, #0]
    44b0:	0608      	lsls	r0, r1, #24
    44b2:	d505      	bpl.n	44c0 <_printf_i+0x150>
    44b4:	1d11      	adds	r1, r2, #4
    44b6:	6019      	str	r1, [r3, #0]
    44b8:	6813      	ldr	r3, [r2, #0]
    44ba:	6962      	ldr	r2, [r4, #20]
    44bc:	601a      	str	r2, [r3, #0]
    44be:	e006      	b.n	44ce <_printf_i+0x15e>
    44c0:	0649      	lsls	r1, r1, #25
    44c2:	d5f7      	bpl.n	44b4 <_printf_i+0x144>
    44c4:	1d11      	adds	r1, r2, #4
    44c6:	6019      	str	r1, [r3, #0]
    44c8:	6813      	ldr	r3, [r2, #0]
    44ca:	8aa2      	ldrh	r2, [r4, #20]
    44cc:	801a      	strh	r2, [r3, #0]
    44ce:	2300      	movs	r3, #0
    44d0:	9e04      	ldr	r6, [sp, #16]
    44d2:	6123      	str	r3, [r4, #16]
    44d4:	e054      	b.n	4580 <_printf_i+0x210>
    44d6:	681a      	ldr	r2, [r3, #0]
    44d8:	1d11      	adds	r1, r2, #4
    44da:	6019      	str	r1, [r3, #0]
    44dc:	6816      	ldr	r6, [r2, #0]
    44de:	2100      	movs	r1, #0
    44e0:	6862      	ldr	r2, [r4, #4]
    44e2:	0030      	movs	r0, r6
    44e4:	f000 f85e 	bl	45a4 <memchr>
    44e8:	2800      	cmp	r0, #0
    44ea:	d001      	beq.n	44f0 <_printf_i+0x180>
    44ec:	1b80      	subs	r0, r0, r6
    44ee:	6060      	str	r0, [r4, #4]
    44f0:	6863      	ldr	r3, [r4, #4]
    44f2:	6123      	str	r3, [r4, #16]
    44f4:	2300      	movs	r3, #0
    44f6:	9a04      	ldr	r2, [sp, #16]
    44f8:	7013      	strb	r3, [r2, #0]
    44fa:	e041      	b.n	4580 <_printf_i+0x210>
    44fc:	6923      	ldr	r3, [r4, #16]
    44fe:	0032      	movs	r2, r6
    4500:	9906      	ldr	r1, [sp, #24]
    4502:	9805      	ldr	r0, [sp, #20]
    4504:	9d07      	ldr	r5, [sp, #28]
    4506:	47a8      	blx	r5
    4508:	1c43      	adds	r3, r0, #1
    450a:	d043      	beq.n	4594 <_printf_i+0x224>
    450c:	6823      	ldr	r3, [r4, #0]
    450e:	2500      	movs	r5, #0
    4510:	079b      	lsls	r3, r3, #30
    4512:	d40f      	bmi.n	4534 <_printf_i+0x1c4>
    4514:	9b09      	ldr	r3, [sp, #36]	; 0x24
    4516:	68e0      	ldr	r0, [r4, #12]
    4518:	4298      	cmp	r0, r3
    451a:	da3d      	bge.n	4598 <_printf_i+0x228>
    451c:	0018      	movs	r0, r3
    451e:	e03b      	b.n	4598 <_printf_i+0x228>
    4520:	0022      	movs	r2, r4
    4522:	2301      	movs	r3, #1
    4524:	3219      	adds	r2, #25
    4526:	9906      	ldr	r1, [sp, #24]
    4528:	9805      	ldr	r0, [sp, #20]
    452a:	9e07      	ldr	r6, [sp, #28]
    452c:	47b0      	blx	r6
    452e:	1c43      	adds	r3, r0, #1
    4530:	d030      	beq.n	4594 <_printf_i+0x224>
    4532:	3501      	adds	r5, #1
    4534:	68e3      	ldr	r3, [r4, #12]
    4536:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4538:	1a9b      	subs	r3, r3, r2
    453a:	429d      	cmp	r5, r3
    453c:	dbf0      	blt.n	4520 <_printf_i+0x1b0>
    453e:	e7e9      	b.n	4514 <_printf_i+0x1a4>
    4540:	2d00      	cmp	r5, #0
    4542:	d0a9      	beq.n	4498 <_printf_i+0x128>
    4544:	9e04      	ldr	r6, [sp, #16]
    4546:	0028      	movs	r0, r5
    4548:	0039      	movs	r1, r7
    454a:	f7ff fab1 	bl	3ab0 <__aeabi_uidivmod>
    454e:	9b03      	ldr	r3, [sp, #12]
    4550:	3e01      	subs	r6, #1
    4552:	5c5b      	ldrb	r3, [r3, r1]
    4554:	0028      	movs	r0, r5
    4556:	7033      	strb	r3, [r6, #0]
    4558:	0039      	movs	r1, r7
    455a:	f7ff fa23 	bl	39a4 <__udivsi3>
    455e:	1e05      	subs	r5, r0, #0
    4560:	d1f1      	bne.n	4546 <_printf_i+0x1d6>
    4562:	2f08      	cmp	r7, #8
    4564:	d109      	bne.n	457a <_printf_i+0x20a>
    4566:	6823      	ldr	r3, [r4, #0]
    4568:	07db      	lsls	r3, r3, #31
    456a:	d506      	bpl.n	457a <_printf_i+0x20a>
    456c:	6863      	ldr	r3, [r4, #4]
    456e:	6922      	ldr	r2, [r4, #16]
    4570:	4293      	cmp	r3, r2
    4572:	dc02      	bgt.n	457a <_printf_i+0x20a>
    4574:	2330      	movs	r3, #48	; 0x30
    4576:	3e01      	subs	r6, #1
    4578:	7033      	strb	r3, [r6, #0]
    457a:	9b04      	ldr	r3, [sp, #16]
    457c:	1b9b      	subs	r3, r3, r6
    457e:	6123      	str	r3, [r4, #16]
    4580:	9b07      	ldr	r3, [sp, #28]
    4582:	aa09      	add	r2, sp, #36	; 0x24
    4584:	9300      	str	r3, [sp, #0]
    4586:	0021      	movs	r1, r4
    4588:	9b06      	ldr	r3, [sp, #24]
    458a:	9805      	ldr	r0, [sp, #20]
    458c:	f7ff fe82 	bl	4294 <_printf_common>
    4590:	1c43      	adds	r3, r0, #1
    4592:	d1b3      	bne.n	44fc <_printf_i+0x18c>
    4594:	2001      	movs	r0, #1
    4596:	4240      	negs	r0, r0
    4598:	b00b      	add	sp, #44	; 0x2c
    459a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    459c:	0000471b 	.word	0x0000471b
    45a0:	0000470a 	.word	0x0000470a

000045a4 <memchr>:
    45a4:	b2c9      	uxtb	r1, r1
    45a6:	1882      	adds	r2, r0, r2
    45a8:	4290      	cmp	r0, r2
    45aa:	d101      	bne.n	45b0 <memchr+0xc>
    45ac:	2000      	movs	r0, #0
    45ae:	4770      	bx	lr
    45b0:	7803      	ldrb	r3, [r0, #0]
    45b2:	428b      	cmp	r3, r1
    45b4:	d0fb      	beq.n	45ae <memchr+0xa>
    45b6:	3001      	adds	r0, #1
    45b8:	e7f6      	b.n	45a8 <memchr+0x4>

000045ba <memmove>:
    45ba:	b510      	push	{r4, lr}
    45bc:	4288      	cmp	r0, r1
    45be:	d902      	bls.n	45c6 <memmove+0xc>
    45c0:	188b      	adds	r3, r1, r2
    45c2:	4298      	cmp	r0, r3
    45c4:	d308      	bcc.n	45d8 <memmove+0x1e>
    45c6:	2300      	movs	r3, #0
    45c8:	429a      	cmp	r2, r3
    45ca:	d007      	beq.n	45dc <memmove+0x22>
    45cc:	5ccc      	ldrb	r4, [r1, r3]
    45ce:	54c4      	strb	r4, [r0, r3]
    45d0:	3301      	adds	r3, #1
    45d2:	e7f9      	b.n	45c8 <memmove+0xe>
    45d4:	5c8b      	ldrb	r3, [r1, r2]
    45d6:	5483      	strb	r3, [r0, r2]
    45d8:	3a01      	subs	r2, #1
    45da:	d2fb      	bcs.n	45d4 <memmove+0x1a>
    45dc:	bd10      	pop	{r4, pc}

000045de <_realloc_r>:
    45de:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    45e0:	0007      	movs	r7, r0
    45e2:	000d      	movs	r5, r1
    45e4:	0016      	movs	r6, r2
    45e6:	2900      	cmp	r1, #0
    45e8:	d105      	bne.n	45f6 <_realloc_r+0x18>
    45ea:	0011      	movs	r1, r2
    45ec:	f7ff fc4e 	bl	3e8c <_malloc_r>
    45f0:	0004      	movs	r4, r0
    45f2:	0020      	movs	r0, r4
    45f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    45f6:	2a00      	cmp	r2, #0
    45f8:	d103      	bne.n	4602 <_realloc_r+0x24>
    45fa:	f7ff fbfd 	bl	3df8 <_free_r>
    45fe:	0034      	movs	r4, r6
    4600:	e7f7      	b.n	45f2 <_realloc_r+0x14>
    4602:	f000 f812 	bl	462a <_malloc_usable_size_r>
    4606:	002c      	movs	r4, r5
    4608:	4286      	cmp	r6, r0
    460a:	d9f2      	bls.n	45f2 <_realloc_r+0x14>
    460c:	0031      	movs	r1, r6
    460e:	0038      	movs	r0, r7
    4610:	f7ff fc3c 	bl	3e8c <_malloc_r>
    4614:	1e04      	subs	r4, r0, #0
    4616:	d0ec      	beq.n	45f2 <_realloc_r+0x14>
    4618:	0029      	movs	r1, r5
    461a:	0032      	movs	r2, r6
    461c:	f7ff fbda 	bl	3dd4 <memcpy>
    4620:	0029      	movs	r1, r5
    4622:	0038      	movs	r0, r7
    4624:	f7ff fbe8 	bl	3df8 <_free_r>
    4628:	e7e3      	b.n	45f2 <_realloc_r+0x14>

0000462a <_malloc_usable_size_r>:
    462a:	1f0b      	subs	r3, r1, #4
    462c:	681b      	ldr	r3, [r3, #0]
    462e:	1f18      	subs	r0, r3, #4
    4630:	2b00      	cmp	r3, #0
    4632:	da01      	bge.n	4638 <_malloc_usable_size_r+0xe>
    4634:	580b      	ldr	r3, [r1, r0]
    4636:	18c0      	adds	r0, r0, r3
    4638:	4770      	bx	lr
	...

0000463c <_usb_device_irq_bits>:
    463c:	0004 0008 0070 0080 0001 0100 0200 0000     ....p...........
    464c:	222a 0000 22a4 0000 22a4 0000 2248 0000     *"..."..."..H"..
    465c:	2242 0000 224e 0000 2230 0000 2254 0000     B"..N"..0"..T"..
    466c:	228a 0000 2570 0000 25c0 0000 25c0 0000     ."..p%...%...%..
    467c:	25bc 0000 2562 0000 2582 0000 2552 0000     .%..b%...%..R%..
    468c:	2594 0000 25a6 0000 260e 0000 263c 0000     .%...%...&..<&..
    469c:	263c 0000 2638 0000 2608 0000 2614 0000     <&..8&...&...&..
    46ac:	2602 0000 261a 0000 2620 0000 2020 4220     .&...&.. &..   B
    46bc:	4f4f 4954 474e 5520 2050 2020 0000 0000     OOTING UP   ....
    46cc:	5250 5345 2053 5542 5454 4e4f 5420 004f     PRESS BUTTON TO.
    46dc:	4c47 574f 4c20 4445 0000 0000 434c 2044     GLOW LED....LCD 
    46ec:	5542 5454 4e4f 5020 4552 5353 2300 302d     BUTTON PRESS.#-0
    46fc:	202b 6800 4c6c 6500 6766 4645 0047 3130     + .hlL.efgEFG.01
    470c:	3332 3534 3736 3938 4241 4443 4645 3000     23456789ABCDEF.0
    471c:	3231 3433 3635 3837 6139 6362 6564 0066     123456789abcdef.

0000472c <_init>:
    472c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    472e:	46c0      	nop			; (mov r8, r8)
    4730:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4732:	bc08      	pop	{r3}
    4734:	469e      	mov	lr, r3
    4736:	4770      	bx	lr

00004738 <__init_array_start>:
    4738:	000000dd 	.word	0x000000dd

0000473c <_fini>:
    473c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    473e:	46c0      	nop			; (mov r8, r8)
    4740:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4742:	bc08      	pop	{r3}
    4744:	469e      	mov	lr, r3
    4746:	4770      	bx	lr

00004748 <__fini_array_start>:
    4748:	000000b5 	.word	0x000000b5

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	2800      	cmp	r0, #0
20000008:	d1fa      	bne.n	20000000 <portable_delay_cycles>
		"SUB r0, r0, #1 \n"
#endif
		"CMP r0, #0  \n"
		"BNE loop         "
	);
}
2000000a:	4770      	bx	lr

2000000c <g_interrupt_enabled>:
2000000c:	0001 0000                                   ....

20000010 <_impure_ptr>:
20000010:	0014 2000                                   ... 

20000014 <impure_data>:
	...
